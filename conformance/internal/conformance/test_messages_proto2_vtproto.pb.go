// Code generated by protoc-gen-go-vtproto. DO NOT EDIT.
// protoc-gen-go-vtproto version: (devel)
// source: src/google/protobuf/test_messages_proto2.proto

package conformance

import (
	binary "encoding/binary"
	fmt "fmt"
	proto "google.golang.org/protobuf/proto"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	io "io"
	math "math"
	bits "math/bits"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

func (m *TestAllTypesProto2_NestedMessage) CloneVT() *TestAllTypesProto2_NestedMessage {
	if m == nil {
		return (*TestAllTypesProto2_NestedMessage)(nil)
	}
	r := &TestAllTypesProto2_NestedMessage{
		Corecursive: m.Corecursive.CloneVT(),
	}
	if rhs := m.A; rhs != nil {
		tmpVal := *rhs
		r.A = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *TestAllTypesProto2_NestedMessage) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *TestAllTypesProto2_Data) CloneVT() *TestAllTypesProto2_Data {
	if m == nil {
		return (*TestAllTypesProto2_Data)(nil)
	}
	r := &TestAllTypesProto2_Data{}
	if rhs := m.GroupInt32; rhs != nil {
		tmpVal := *rhs
		r.GroupInt32 = &tmpVal
	}
	if rhs := m.GroupUint32; rhs != nil {
		tmpVal := *rhs
		r.GroupUint32 = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *TestAllTypesProto2_Data) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *TestAllTypesProto2_MessageSetCorrect) CloneVT() *TestAllTypesProto2_MessageSetCorrect {
	if m == nil {
		return (*TestAllTypesProto2_MessageSetCorrect)(nil)
	}
	r := &TestAllTypesProto2_MessageSetCorrect{}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *TestAllTypesProto2_MessageSetCorrect) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension1) CloneVT() *TestAllTypesProto2_MessageSetCorrectExtension1 {
	if m == nil {
		return (*TestAllTypesProto2_MessageSetCorrectExtension1)(nil)
	}
	r := &TestAllTypesProto2_MessageSetCorrectExtension1{}
	if rhs := m.Str; rhs != nil {
		tmpVal := *rhs
		r.Str = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension1) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension2) CloneVT() *TestAllTypesProto2_MessageSetCorrectExtension2 {
	if m == nil {
		return (*TestAllTypesProto2_MessageSetCorrectExtension2)(nil)
	}
	r := &TestAllTypesProto2_MessageSetCorrectExtension2{}
	if rhs := m.I; rhs != nil {
		tmpVal := *rhs
		r.I = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension2) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *TestAllTypesProto2) CloneVT() *TestAllTypesProto2 {
	if m == nil {
		return (*TestAllTypesProto2)(nil)
	}
	r := &TestAllTypesProto2{
		OptionalNestedMessage:  m.OptionalNestedMessage.CloneVT(),
		OptionalForeignMessage: m.OptionalForeignMessage.CloneVT(),
		RecursiveMessage:       m.RecursiveMessage.CloneVT(),
		Data:                   m.Data.CloneVT(),
	}
	if rhs := m.OptionalInt32; rhs != nil {
		tmpVal := *rhs
		r.OptionalInt32 = &tmpVal
	}
	if rhs := m.OptionalInt64; rhs != nil {
		tmpVal := *rhs
		r.OptionalInt64 = &tmpVal
	}
	if rhs := m.OptionalUint32; rhs != nil {
		tmpVal := *rhs
		r.OptionalUint32 = &tmpVal
	}
	if rhs := m.OptionalUint64; rhs != nil {
		tmpVal := *rhs
		r.OptionalUint64 = &tmpVal
	}
	if rhs := m.OptionalSint32; rhs != nil {
		tmpVal := *rhs
		r.OptionalSint32 = &tmpVal
	}
	if rhs := m.OptionalSint64; rhs != nil {
		tmpVal := *rhs
		r.OptionalSint64 = &tmpVal
	}
	if rhs := m.OptionalFixed32; rhs != nil {
		tmpVal := *rhs
		r.OptionalFixed32 = &tmpVal
	}
	if rhs := m.OptionalFixed64; rhs != nil {
		tmpVal := *rhs
		r.OptionalFixed64 = &tmpVal
	}
	if rhs := m.OptionalSfixed32; rhs != nil {
		tmpVal := *rhs
		r.OptionalSfixed32 = &tmpVal
	}
	if rhs := m.OptionalSfixed64; rhs != nil {
		tmpVal := *rhs
		r.OptionalSfixed64 = &tmpVal
	}
	if rhs := m.OptionalFloat; rhs != nil {
		tmpVal := *rhs
		r.OptionalFloat = &tmpVal
	}
	if rhs := m.OptionalDouble; rhs != nil {
		tmpVal := *rhs
		r.OptionalDouble = &tmpVal
	}
	if rhs := m.OptionalBool; rhs != nil {
		tmpVal := *rhs
		r.OptionalBool = &tmpVal
	}
	if rhs := m.OptionalString; rhs != nil {
		tmpVal := *rhs
		r.OptionalString = &tmpVal
	}
	if rhs := m.OptionalBytes; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.OptionalBytes = tmpBytes
	}
	if rhs := m.OptionalNestedEnum; rhs != nil {
		tmpVal := *rhs
		r.OptionalNestedEnum = &tmpVal
	}
	if rhs := m.OptionalForeignEnum; rhs != nil {
		tmpVal := *rhs
		r.OptionalForeignEnum = &tmpVal
	}
	if rhs := m.OptionalStringPiece; rhs != nil {
		tmpVal := *rhs
		r.OptionalStringPiece = &tmpVal
	}
	if rhs := m.OptionalCord; rhs != nil {
		tmpVal := *rhs
		r.OptionalCord = &tmpVal
	}
	if rhs := m.RepeatedInt32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedInt32 = tmpContainer
	}
	if rhs := m.RepeatedInt64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedInt64 = tmpContainer
	}
	if rhs := m.RepeatedUint32; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedUint32 = tmpContainer
	}
	if rhs := m.RepeatedUint64; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedUint64 = tmpContainer
	}
	if rhs := m.RepeatedSint32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedSint32 = tmpContainer
	}
	if rhs := m.RepeatedSint64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedSint64 = tmpContainer
	}
	if rhs := m.RepeatedFixed32; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedFixed32 = tmpContainer
	}
	if rhs := m.RepeatedFixed64; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedFixed64 = tmpContainer
	}
	if rhs := m.RepeatedSfixed32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedSfixed32 = tmpContainer
	}
	if rhs := m.RepeatedSfixed64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedSfixed64 = tmpContainer
	}
	if rhs := m.RepeatedFloat; rhs != nil {
		tmpContainer := make([]float32, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedFloat = tmpContainer
	}
	if rhs := m.RepeatedDouble; rhs != nil {
		tmpContainer := make([]float64, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedDouble = tmpContainer
	}
	if rhs := m.RepeatedBool; rhs != nil {
		tmpContainer := make([]bool, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedBool = tmpContainer
	}
	if rhs := m.RepeatedString; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedString = tmpContainer
	}
	if rhs := m.RepeatedBytes; rhs != nil {
		tmpContainer := make([][]byte, len(rhs))
		for k, v := range rhs {
			tmpBytes := make([]byte, len(v))
			copy(tmpBytes, v)
			tmpContainer[k] = tmpBytes
		}
		r.RepeatedBytes = tmpContainer
	}
	if rhs := m.RepeatedNestedMessage; rhs != nil {
		tmpContainer := make([]*TestAllTypesProto2_NestedMessage, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.RepeatedNestedMessage = tmpContainer
	}
	if rhs := m.RepeatedForeignMessage; rhs != nil {
		tmpContainer := make([]*ForeignMessageProto2, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.RepeatedForeignMessage = tmpContainer
	}
	if rhs := m.RepeatedNestedEnum; rhs != nil {
		tmpContainer := make([]TestAllTypesProto2_NestedEnum, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedNestedEnum = tmpContainer
	}
	if rhs := m.RepeatedForeignEnum; rhs != nil {
		tmpContainer := make([]ForeignEnumProto2, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedForeignEnum = tmpContainer
	}
	if rhs := m.RepeatedStringPiece; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedStringPiece = tmpContainer
	}
	if rhs := m.RepeatedCord; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedCord = tmpContainer
	}
	if rhs := m.PackedInt32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedInt32 = tmpContainer
	}
	if rhs := m.PackedInt64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedInt64 = tmpContainer
	}
	if rhs := m.PackedUint32; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedUint32 = tmpContainer
	}
	if rhs := m.PackedUint64; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedUint64 = tmpContainer
	}
	if rhs := m.PackedSint32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedSint32 = tmpContainer
	}
	if rhs := m.PackedSint64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedSint64 = tmpContainer
	}
	if rhs := m.PackedFixed32; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedFixed32 = tmpContainer
	}
	if rhs := m.PackedFixed64; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedFixed64 = tmpContainer
	}
	if rhs := m.PackedSfixed32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedSfixed32 = tmpContainer
	}
	if rhs := m.PackedSfixed64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedSfixed64 = tmpContainer
	}
	if rhs := m.PackedFloat; rhs != nil {
		tmpContainer := make([]float32, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedFloat = tmpContainer
	}
	if rhs := m.PackedDouble; rhs != nil {
		tmpContainer := make([]float64, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedDouble = tmpContainer
	}
	if rhs := m.PackedBool; rhs != nil {
		tmpContainer := make([]bool, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedBool = tmpContainer
	}
	if rhs := m.PackedNestedEnum; rhs != nil {
		tmpContainer := make([]TestAllTypesProto2_NestedEnum, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedNestedEnum = tmpContainer
	}
	if rhs := m.UnpackedInt32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedInt32 = tmpContainer
	}
	if rhs := m.UnpackedInt64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedInt64 = tmpContainer
	}
	if rhs := m.UnpackedUint32; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedUint32 = tmpContainer
	}
	if rhs := m.UnpackedUint64; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedUint64 = tmpContainer
	}
	if rhs := m.UnpackedSint32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedSint32 = tmpContainer
	}
	if rhs := m.UnpackedSint64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedSint64 = tmpContainer
	}
	if rhs := m.UnpackedFixed32; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedFixed32 = tmpContainer
	}
	if rhs := m.UnpackedFixed64; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedFixed64 = tmpContainer
	}
	if rhs := m.UnpackedSfixed32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedSfixed32 = tmpContainer
	}
	if rhs := m.UnpackedSfixed64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedSfixed64 = tmpContainer
	}
	if rhs := m.UnpackedFloat; rhs != nil {
		tmpContainer := make([]float32, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedFloat = tmpContainer
	}
	if rhs := m.UnpackedDouble; rhs != nil {
		tmpContainer := make([]float64, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedDouble = tmpContainer
	}
	if rhs := m.UnpackedBool; rhs != nil {
		tmpContainer := make([]bool, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedBool = tmpContainer
	}
	if rhs := m.UnpackedNestedEnum; rhs != nil {
		tmpContainer := make([]TestAllTypesProto2_NestedEnum, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedNestedEnum = tmpContainer
	}
	if rhs := m.MapInt32Int32; rhs != nil {
		tmpContainer := make(map[int32]int32, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapInt32Int32 = tmpContainer
	}
	if rhs := m.MapInt64Int64; rhs != nil {
		tmpContainer := make(map[int64]int64, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapInt64Int64 = tmpContainer
	}
	if rhs := m.MapUint32Uint32; rhs != nil {
		tmpContainer := make(map[uint32]uint32, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapUint32Uint32 = tmpContainer
	}
	if rhs := m.MapUint64Uint64; rhs != nil {
		tmpContainer := make(map[uint64]uint64, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapUint64Uint64 = tmpContainer
	}
	if rhs := m.MapSint32Sint32; rhs != nil {
		tmpContainer := make(map[int32]int32, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapSint32Sint32 = tmpContainer
	}
	if rhs := m.MapSint64Sint64; rhs != nil {
		tmpContainer := make(map[int64]int64, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapSint64Sint64 = tmpContainer
	}
	if rhs := m.MapFixed32Fixed32; rhs != nil {
		tmpContainer := make(map[uint32]uint32, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapFixed32Fixed32 = tmpContainer
	}
	if rhs := m.MapFixed64Fixed64; rhs != nil {
		tmpContainer := make(map[uint64]uint64, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapFixed64Fixed64 = tmpContainer
	}
	if rhs := m.MapSfixed32Sfixed32; rhs != nil {
		tmpContainer := make(map[int32]int32, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapSfixed32Sfixed32 = tmpContainer
	}
	if rhs := m.MapSfixed64Sfixed64; rhs != nil {
		tmpContainer := make(map[int64]int64, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapSfixed64Sfixed64 = tmpContainer
	}
	if rhs := m.MapInt32Float; rhs != nil {
		tmpContainer := make(map[int32]float32, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapInt32Float = tmpContainer
	}
	if rhs := m.MapInt32Double; rhs != nil {
		tmpContainer := make(map[int32]float64, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapInt32Double = tmpContainer
	}
	if rhs := m.MapBoolBool; rhs != nil {
		tmpContainer := make(map[bool]bool, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapBoolBool = tmpContainer
	}
	if rhs := m.MapStringString; rhs != nil {
		tmpContainer := make(map[string]string, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapStringString = tmpContainer
	}
	if rhs := m.MapStringBytes; rhs != nil {
		tmpContainer := make(map[string][]byte, len(rhs))
		for k, v := range rhs {
			tmpBytes := make([]byte, len(v))
			copy(tmpBytes, v)
			tmpContainer[k] = tmpBytes
		}
		r.MapStringBytes = tmpContainer
	}
	if rhs := m.MapStringNestedMessage; rhs != nil {
		tmpContainer := make(map[string]*TestAllTypesProto2_NestedMessage, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.MapStringNestedMessage = tmpContainer
	}
	if rhs := m.MapStringForeignMessage; rhs != nil {
		tmpContainer := make(map[string]*ForeignMessageProto2, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.MapStringForeignMessage = tmpContainer
	}
	if rhs := m.MapStringNestedEnum; rhs != nil {
		tmpContainer := make(map[string]TestAllTypesProto2_NestedEnum, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapStringNestedEnum = tmpContainer
	}
	if rhs := m.MapStringForeignEnum; rhs != nil {
		tmpContainer := make(map[string]ForeignEnumProto2, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapStringForeignEnum = tmpContainer
	}
	if m.OneofField != nil {
		r.OneofField = m.OneofField.(interface {
			CloneVT() isTestAllTypesProto2_OneofField
		}).CloneVT()
	}
	if rhs := m.DefaultInt32; rhs != nil {
		tmpVal := *rhs
		r.DefaultInt32 = &tmpVal
	}
	if rhs := m.DefaultInt64; rhs != nil {
		tmpVal := *rhs
		r.DefaultInt64 = &tmpVal
	}
	if rhs := m.DefaultUint32; rhs != nil {
		tmpVal := *rhs
		r.DefaultUint32 = &tmpVal
	}
	if rhs := m.DefaultUint64; rhs != nil {
		tmpVal := *rhs
		r.DefaultUint64 = &tmpVal
	}
	if rhs := m.DefaultSint32; rhs != nil {
		tmpVal := *rhs
		r.DefaultSint32 = &tmpVal
	}
	if rhs := m.DefaultSint64; rhs != nil {
		tmpVal := *rhs
		r.DefaultSint64 = &tmpVal
	}
	if rhs := m.DefaultFixed32; rhs != nil {
		tmpVal := *rhs
		r.DefaultFixed32 = &tmpVal
	}
	if rhs := m.DefaultFixed64; rhs != nil {
		tmpVal := *rhs
		r.DefaultFixed64 = &tmpVal
	}
	if rhs := m.DefaultSfixed32; rhs != nil {
		tmpVal := *rhs
		r.DefaultSfixed32 = &tmpVal
	}
	if rhs := m.DefaultSfixed64; rhs != nil {
		tmpVal := *rhs
		r.DefaultSfixed64 = &tmpVal
	}
	if rhs := m.DefaultFloat; rhs != nil {
		tmpVal := *rhs
		r.DefaultFloat = &tmpVal
	}
	if rhs := m.DefaultDouble; rhs != nil {
		tmpVal := *rhs
		r.DefaultDouble = &tmpVal
	}
	if rhs := m.DefaultBool; rhs != nil {
		tmpVal := *rhs
		r.DefaultBool = &tmpVal
	}
	if rhs := m.DefaultString; rhs != nil {
		tmpVal := *rhs
		r.DefaultString = &tmpVal
	}
	if rhs := m.DefaultBytes; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.DefaultBytes = tmpBytes
	}
	if rhs := m.Fieldname1; rhs != nil {
		tmpVal := *rhs
		r.Fieldname1 = &tmpVal
	}
	if rhs := m.FieldName2; rhs != nil {
		tmpVal := *rhs
		r.FieldName2 = &tmpVal
	}
	if rhs := m.XFieldName3; rhs != nil {
		tmpVal := *rhs
		r.XFieldName3 = &tmpVal
	}
	if rhs := m.Field_Name4_; rhs != nil {
		tmpVal := *rhs
		r.Field_Name4_ = &tmpVal
	}
	if rhs := m.Field0Name5; rhs != nil {
		tmpVal := *rhs
		r.Field0Name5 = &tmpVal
	}
	if rhs := m.Field_0Name6; rhs != nil {
		tmpVal := *rhs
		r.Field_0Name6 = &tmpVal
	}
	if rhs := m.FieldName7; rhs != nil {
		tmpVal := *rhs
		r.FieldName7 = &tmpVal
	}
	if rhs := m.FieldName8; rhs != nil {
		tmpVal := *rhs
		r.FieldName8 = &tmpVal
	}
	if rhs := m.Field_Name9; rhs != nil {
		tmpVal := *rhs
		r.Field_Name9 = &tmpVal
	}
	if rhs := m.Field_Name10; rhs != nil {
		tmpVal := *rhs
		r.Field_Name10 = &tmpVal
	}
	if rhs := m.FIELD_NAME11; rhs != nil {
		tmpVal := *rhs
		r.FIELD_NAME11 = &tmpVal
	}
	if rhs := m.FIELDName12; rhs != nil {
		tmpVal := *rhs
		r.FIELDName12 = &tmpVal
	}
	if rhs := m.XFieldName13; rhs != nil {
		tmpVal := *rhs
		r.XFieldName13 = &tmpVal
	}
	if rhs := m.X_FieldName14; rhs != nil {
		tmpVal := *rhs
		r.X_FieldName14 = &tmpVal
	}
	if rhs := m.Field_Name15; rhs != nil {
		tmpVal := *rhs
		r.Field_Name15 = &tmpVal
	}
	if rhs := m.Field__Name16; rhs != nil {
		tmpVal := *rhs
		r.Field__Name16 = &tmpVal
	}
	if rhs := m.FieldName17__; rhs != nil {
		tmpVal := *rhs
		r.FieldName17__ = &tmpVal
	}
	if rhs := m.FieldName18__; rhs != nil {
		tmpVal := *rhs
		r.FieldName18__ = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *TestAllTypesProto2) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *TestAllTypesProto2_OneofUint32) CloneVT() isTestAllTypesProto2_OneofField {
	if m == nil {
		return (*TestAllTypesProto2_OneofUint32)(nil)
	}
	r := &TestAllTypesProto2_OneofUint32{
		OneofUint32: m.OneofUint32,
	}
	return r
}

func (m *TestAllTypesProto2_OneofNestedMessage) CloneVT() isTestAllTypesProto2_OneofField {
	if m == nil {
		return (*TestAllTypesProto2_OneofNestedMessage)(nil)
	}
	r := &TestAllTypesProto2_OneofNestedMessage{
		OneofNestedMessage: m.OneofNestedMessage.CloneVT(),
	}
	return r
}

func (m *TestAllTypesProto2_OneofString) CloneVT() isTestAllTypesProto2_OneofField {
	if m == nil {
		return (*TestAllTypesProto2_OneofString)(nil)
	}
	r := &TestAllTypesProto2_OneofString{
		OneofString: m.OneofString,
	}
	return r
}

func (m *TestAllTypesProto2_OneofBytes) CloneVT() isTestAllTypesProto2_OneofField {
	if m == nil {
		return (*TestAllTypesProto2_OneofBytes)(nil)
	}
	r := &TestAllTypesProto2_OneofBytes{}
	if rhs := m.OneofBytes; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.OneofBytes = tmpBytes
	}
	return r
}

func (m *TestAllTypesProto2_OneofBool) CloneVT() isTestAllTypesProto2_OneofField {
	if m == nil {
		return (*TestAllTypesProto2_OneofBool)(nil)
	}
	r := &TestAllTypesProto2_OneofBool{
		OneofBool: m.OneofBool,
	}
	return r
}

func (m *TestAllTypesProto2_OneofUint64) CloneVT() isTestAllTypesProto2_OneofField {
	if m == nil {
		return (*TestAllTypesProto2_OneofUint64)(nil)
	}
	r := &TestAllTypesProto2_OneofUint64{
		OneofUint64: m.OneofUint64,
	}
	return r
}

func (m *TestAllTypesProto2_OneofFloat) CloneVT() isTestAllTypesProto2_OneofField {
	if m == nil {
		return (*TestAllTypesProto2_OneofFloat)(nil)
	}
	r := &TestAllTypesProto2_OneofFloat{
		OneofFloat: m.OneofFloat,
	}
	return r
}

func (m *TestAllTypesProto2_OneofDouble) CloneVT() isTestAllTypesProto2_OneofField {
	if m == nil {
		return (*TestAllTypesProto2_OneofDouble)(nil)
	}
	r := &TestAllTypesProto2_OneofDouble{
		OneofDouble: m.OneofDouble,
	}
	return r
}

func (m *TestAllTypesProto2_OneofEnum) CloneVT() isTestAllTypesProto2_OneofField {
	if m == nil {
		return (*TestAllTypesProto2_OneofEnum)(nil)
	}
	r := &TestAllTypesProto2_OneofEnum{
		OneofEnum: m.OneofEnum,
	}
	return r
}

func (m *ForeignMessageProto2) CloneVT() *ForeignMessageProto2 {
	if m == nil {
		return (*ForeignMessageProto2)(nil)
	}
	r := &ForeignMessageProto2{}
	if rhs := m.C; rhs != nil {
		tmpVal := *rhs
		r.C = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ForeignMessageProto2) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *UnknownToTestAllTypes_OptionalGroup) CloneVT() *UnknownToTestAllTypes_OptionalGroup {
	if m == nil {
		return (*UnknownToTestAllTypes_OptionalGroup)(nil)
	}
	r := &UnknownToTestAllTypes_OptionalGroup{}
	if rhs := m.A; rhs != nil {
		tmpVal := *rhs
		r.A = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *UnknownToTestAllTypes_OptionalGroup) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *UnknownToTestAllTypes) CloneVT() *UnknownToTestAllTypes {
	if m == nil {
		return (*UnknownToTestAllTypes)(nil)
	}
	r := &UnknownToTestAllTypes{
		NestedMessage: m.NestedMessage.CloneVT(),
		Optionalgroup: m.Optionalgroup.CloneVT(),
	}
	if rhs := m.OptionalInt32; rhs != nil {
		tmpVal := *rhs
		r.OptionalInt32 = &tmpVal
	}
	if rhs := m.OptionalString; rhs != nil {
		tmpVal := *rhs
		r.OptionalString = &tmpVal
	}
	if rhs := m.OptionalBool; rhs != nil {
		tmpVal := *rhs
		r.OptionalBool = &tmpVal
	}
	if rhs := m.RepeatedInt32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedInt32 = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *UnknownToTestAllTypes) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *NullHypothesisProto2) CloneVT() *NullHypothesisProto2 {
	if m == nil {
		return (*NullHypothesisProto2)(nil)
	}
	r := &NullHypothesisProto2{}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *NullHypothesisProto2) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *EnumOnlyProto2) CloneVT() *EnumOnlyProto2 {
	if m == nil {
		return (*EnumOnlyProto2)(nil)
	}
	r := &EnumOnlyProto2{}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *EnumOnlyProto2) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *OneStringProto2) CloneVT() *OneStringProto2 {
	if m == nil {
		return (*OneStringProto2)(nil)
	}
	r := &OneStringProto2{}
	if rhs := m.Data; rhs != nil {
		tmpVal := *rhs
		r.Data = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *OneStringProto2) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (this *TestAllTypesProto2_NestedMessage) EqualVT(that *TestAllTypesProto2_NestedMessage) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.A, that.A; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Corecursive.EqualVT(that.Corecursive) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *TestAllTypesProto2_NestedMessage) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*TestAllTypesProto2_NestedMessage)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *TestAllTypesProto2_Data) EqualVT(that *TestAllTypesProto2_Data) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.GroupInt32, that.GroupInt32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.GroupUint32, that.GroupUint32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *TestAllTypesProto2_Data) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*TestAllTypesProto2_Data)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *TestAllTypesProto2_MessageSetCorrect) EqualVT(that *TestAllTypesProto2_MessageSetCorrect) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *TestAllTypesProto2_MessageSetCorrect) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*TestAllTypesProto2_MessageSetCorrect)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *TestAllTypesProto2_MessageSetCorrectExtension1) EqualVT(that *TestAllTypesProto2_MessageSetCorrectExtension1) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Str, that.Str; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *TestAllTypesProto2_MessageSetCorrectExtension1) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*TestAllTypesProto2_MessageSetCorrectExtension1)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *TestAllTypesProto2_MessageSetCorrectExtension2) EqualVT(that *TestAllTypesProto2_MessageSetCorrectExtension2) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.I, that.I; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *TestAllTypesProto2_MessageSetCorrectExtension2) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*TestAllTypesProto2_MessageSetCorrectExtension2)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *TestAllTypesProto2) EqualVT(that *TestAllTypesProto2) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.OneofField == nil && that.OneofField != nil {
		return false
	} else if this.OneofField != nil {
		if that.OneofField == nil {
			return false
		}
		if !this.OneofField.(interface {
			EqualVT(isTestAllTypesProto2_OneofField) bool
		}).EqualVT(that.OneofField) {
			return false
		}
	}
	if p, q := this.OptionalInt32, that.OptionalInt32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalInt64, that.OptionalInt64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalUint32, that.OptionalUint32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalUint64, that.OptionalUint64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalSint32, that.OptionalSint32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalSint64, that.OptionalSint64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalFixed32, that.OptionalFixed32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalFixed64, that.OptionalFixed64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalSfixed32, that.OptionalSfixed32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalSfixed64, that.OptionalSfixed64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalFloat, that.OptionalFloat; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalDouble, that.OptionalDouble; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalBool, that.OptionalBool; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalString, that.OptionalString; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalBytes, that.OptionalBytes; (p == nil && q != nil) || (p != nil && q == nil) || string(p) != string(q) {
		return false
	}
	if !this.OptionalNestedMessage.EqualVT(that.OptionalNestedMessage) {
		return false
	}
	if !this.OptionalForeignMessage.EqualVT(that.OptionalForeignMessage) {
		return false
	}
	if p, q := this.OptionalNestedEnum, that.OptionalNestedEnum; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalForeignEnum, that.OptionalForeignEnum; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalStringPiece, that.OptionalStringPiece; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalCord, that.OptionalCord; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.RecursiveMessage.EqualVT(that.RecursiveMessage) {
		return false
	}
	if len(this.RepeatedInt32) != len(that.RepeatedInt32) {
		return false
	}
	for i, vx := range this.RepeatedInt32 {
		vy := that.RepeatedInt32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedInt64) != len(that.RepeatedInt64) {
		return false
	}
	for i, vx := range this.RepeatedInt64 {
		vy := that.RepeatedInt64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedUint32) != len(that.RepeatedUint32) {
		return false
	}
	for i, vx := range this.RepeatedUint32 {
		vy := that.RepeatedUint32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedUint64) != len(that.RepeatedUint64) {
		return false
	}
	for i, vx := range this.RepeatedUint64 {
		vy := that.RepeatedUint64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedSint32) != len(that.RepeatedSint32) {
		return false
	}
	for i, vx := range this.RepeatedSint32 {
		vy := that.RepeatedSint32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedSint64) != len(that.RepeatedSint64) {
		return false
	}
	for i, vx := range this.RepeatedSint64 {
		vy := that.RepeatedSint64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedFixed32) != len(that.RepeatedFixed32) {
		return false
	}
	for i, vx := range this.RepeatedFixed32 {
		vy := that.RepeatedFixed32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedFixed64) != len(that.RepeatedFixed64) {
		return false
	}
	for i, vx := range this.RepeatedFixed64 {
		vy := that.RepeatedFixed64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedSfixed32) != len(that.RepeatedSfixed32) {
		return false
	}
	for i, vx := range this.RepeatedSfixed32 {
		vy := that.RepeatedSfixed32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedSfixed64) != len(that.RepeatedSfixed64) {
		return false
	}
	for i, vx := range this.RepeatedSfixed64 {
		vy := that.RepeatedSfixed64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedFloat) != len(that.RepeatedFloat) {
		return false
	}
	for i, vx := range this.RepeatedFloat {
		vy := that.RepeatedFloat[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedDouble) != len(that.RepeatedDouble) {
		return false
	}
	for i, vx := range this.RepeatedDouble {
		vy := that.RepeatedDouble[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedBool) != len(that.RepeatedBool) {
		return false
	}
	for i, vx := range this.RepeatedBool {
		vy := that.RepeatedBool[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedString) != len(that.RepeatedString) {
		return false
	}
	for i, vx := range this.RepeatedString {
		vy := that.RepeatedString[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedBytes) != len(that.RepeatedBytes) {
		return false
	}
	for i, vx := range this.RepeatedBytes {
		vy := that.RepeatedBytes[i]
		if string(vx) != string(vy) {
			return false
		}
	}
	if len(this.RepeatedNestedMessage) != len(that.RepeatedNestedMessage) {
		return false
	}
	for i, vx := range this.RepeatedNestedMessage {
		vy := that.RepeatedNestedMessage[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &TestAllTypesProto2_NestedMessage{}
			}
			if q == nil {
				q = &TestAllTypesProto2_NestedMessage{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.RepeatedForeignMessage) != len(that.RepeatedForeignMessage) {
		return false
	}
	for i, vx := range this.RepeatedForeignMessage {
		vy := that.RepeatedForeignMessage[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ForeignMessageProto2{}
			}
			if q == nil {
				q = &ForeignMessageProto2{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.RepeatedNestedEnum) != len(that.RepeatedNestedEnum) {
		return false
	}
	for i, vx := range this.RepeatedNestedEnum {
		vy := that.RepeatedNestedEnum[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedForeignEnum) != len(that.RepeatedForeignEnum) {
		return false
	}
	for i, vx := range this.RepeatedForeignEnum {
		vy := that.RepeatedForeignEnum[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedStringPiece) != len(that.RepeatedStringPiece) {
		return false
	}
	for i, vx := range this.RepeatedStringPiece {
		vy := that.RepeatedStringPiece[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedCord) != len(that.RepeatedCord) {
		return false
	}
	for i, vx := range this.RepeatedCord {
		vy := that.RepeatedCord[i]
		if vx != vy {
			return false
		}
	}
	if len(this.MapInt32Int32) != len(that.MapInt32Int32) {
		return false
	}
	for i, vx := range this.MapInt32Int32 {
		vy, ok := that.MapInt32Int32[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapInt64Int64) != len(that.MapInt64Int64) {
		return false
	}
	for i, vx := range this.MapInt64Int64 {
		vy, ok := that.MapInt64Int64[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapUint32Uint32) != len(that.MapUint32Uint32) {
		return false
	}
	for i, vx := range this.MapUint32Uint32 {
		vy, ok := that.MapUint32Uint32[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapUint64Uint64) != len(that.MapUint64Uint64) {
		return false
	}
	for i, vx := range this.MapUint64Uint64 {
		vy, ok := that.MapUint64Uint64[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapSint32Sint32) != len(that.MapSint32Sint32) {
		return false
	}
	for i, vx := range this.MapSint32Sint32 {
		vy, ok := that.MapSint32Sint32[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapSint64Sint64) != len(that.MapSint64Sint64) {
		return false
	}
	for i, vx := range this.MapSint64Sint64 {
		vy, ok := that.MapSint64Sint64[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapFixed32Fixed32) != len(that.MapFixed32Fixed32) {
		return false
	}
	for i, vx := range this.MapFixed32Fixed32 {
		vy, ok := that.MapFixed32Fixed32[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapFixed64Fixed64) != len(that.MapFixed64Fixed64) {
		return false
	}
	for i, vx := range this.MapFixed64Fixed64 {
		vy, ok := that.MapFixed64Fixed64[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapSfixed32Sfixed32) != len(that.MapSfixed32Sfixed32) {
		return false
	}
	for i, vx := range this.MapSfixed32Sfixed32 {
		vy, ok := that.MapSfixed32Sfixed32[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapSfixed64Sfixed64) != len(that.MapSfixed64Sfixed64) {
		return false
	}
	for i, vx := range this.MapSfixed64Sfixed64 {
		vy, ok := that.MapSfixed64Sfixed64[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapInt32Float) != len(that.MapInt32Float) {
		return false
	}
	for i, vx := range this.MapInt32Float {
		vy, ok := that.MapInt32Float[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapInt32Double) != len(that.MapInt32Double) {
		return false
	}
	for i, vx := range this.MapInt32Double {
		vy, ok := that.MapInt32Double[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapBoolBool) != len(that.MapBoolBool) {
		return false
	}
	for i, vx := range this.MapBoolBool {
		vy, ok := that.MapBoolBool[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapStringString) != len(that.MapStringString) {
		return false
	}
	for i, vx := range this.MapStringString {
		vy, ok := that.MapStringString[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapStringBytes) != len(that.MapStringBytes) {
		return false
	}
	for i, vx := range this.MapStringBytes {
		vy, ok := that.MapStringBytes[i]
		if !ok {
			return false
		}
		if string(vx) != string(vy) {
			return false
		}
	}
	if len(this.MapStringNestedMessage) != len(that.MapStringNestedMessage) {
		return false
	}
	for i, vx := range this.MapStringNestedMessage {
		vy, ok := that.MapStringNestedMessage[i]
		if !ok {
			return false
		}
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &TestAllTypesProto2_NestedMessage{}
			}
			if q == nil {
				q = &TestAllTypesProto2_NestedMessage{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.MapStringForeignMessage) != len(that.MapStringForeignMessage) {
		return false
	}
	for i, vx := range this.MapStringForeignMessage {
		vy, ok := that.MapStringForeignMessage[i]
		if !ok {
			return false
		}
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ForeignMessageProto2{}
			}
			if q == nil {
				q = &ForeignMessageProto2{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.MapStringNestedEnum) != len(that.MapStringNestedEnum) {
		return false
	}
	for i, vx := range this.MapStringNestedEnum {
		vy, ok := that.MapStringNestedEnum[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapStringForeignEnum) != len(that.MapStringForeignEnum) {
		return false
	}
	for i, vx := range this.MapStringForeignEnum {
		vy, ok := that.MapStringForeignEnum[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.PackedInt32) != len(that.PackedInt32) {
		return false
	}
	for i, vx := range this.PackedInt32 {
		vy := that.PackedInt32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedInt64) != len(that.PackedInt64) {
		return false
	}
	for i, vx := range this.PackedInt64 {
		vy := that.PackedInt64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedUint32) != len(that.PackedUint32) {
		return false
	}
	for i, vx := range this.PackedUint32 {
		vy := that.PackedUint32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedUint64) != len(that.PackedUint64) {
		return false
	}
	for i, vx := range this.PackedUint64 {
		vy := that.PackedUint64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedSint32) != len(that.PackedSint32) {
		return false
	}
	for i, vx := range this.PackedSint32 {
		vy := that.PackedSint32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedSint64) != len(that.PackedSint64) {
		return false
	}
	for i, vx := range this.PackedSint64 {
		vy := that.PackedSint64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedFixed32) != len(that.PackedFixed32) {
		return false
	}
	for i, vx := range this.PackedFixed32 {
		vy := that.PackedFixed32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedFixed64) != len(that.PackedFixed64) {
		return false
	}
	for i, vx := range this.PackedFixed64 {
		vy := that.PackedFixed64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedSfixed32) != len(that.PackedSfixed32) {
		return false
	}
	for i, vx := range this.PackedSfixed32 {
		vy := that.PackedSfixed32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedSfixed64) != len(that.PackedSfixed64) {
		return false
	}
	for i, vx := range this.PackedSfixed64 {
		vy := that.PackedSfixed64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedFloat) != len(that.PackedFloat) {
		return false
	}
	for i, vx := range this.PackedFloat {
		vy := that.PackedFloat[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedDouble) != len(that.PackedDouble) {
		return false
	}
	for i, vx := range this.PackedDouble {
		vy := that.PackedDouble[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedBool) != len(that.PackedBool) {
		return false
	}
	for i, vx := range this.PackedBool {
		vy := that.PackedBool[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedNestedEnum) != len(that.PackedNestedEnum) {
		return false
	}
	for i, vx := range this.PackedNestedEnum {
		vy := that.PackedNestedEnum[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedInt32) != len(that.UnpackedInt32) {
		return false
	}
	for i, vx := range this.UnpackedInt32 {
		vy := that.UnpackedInt32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedInt64) != len(that.UnpackedInt64) {
		return false
	}
	for i, vx := range this.UnpackedInt64 {
		vy := that.UnpackedInt64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedUint32) != len(that.UnpackedUint32) {
		return false
	}
	for i, vx := range this.UnpackedUint32 {
		vy := that.UnpackedUint32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedUint64) != len(that.UnpackedUint64) {
		return false
	}
	for i, vx := range this.UnpackedUint64 {
		vy := that.UnpackedUint64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedSint32) != len(that.UnpackedSint32) {
		return false
	}
	for i, vx := range this.UnpackedSint32 {
		vy := that.UnpackedSint32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedSint64) != len(that.UnpackedSint64) {
		return false
	}
	for i, vx := range this.UnpackedSint64 {
		vy := that.UnpackedSint64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedFixed32) != len(that.UnpackedFixed32) {
		return false
	}
	for i, vx := range this.UnpackedFixed32 {
		vy := that.UnpackedFixed32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedFixed64) != len(that.UnpackedFixed64) {
		return false
	}
	for i, vx := range this.UnpackedFixed64 {
		vy := that.UnpackedFixed64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedSfixed32) != len(that.UnpackedSfixed32) {
		return false
	}
	for i, vx := range this.UnpackedSfixed32 {
		vy := that.UnpackedSfixed32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedSfixed64) != len(that.UnpackedSfixed64) {
		return false
	}
	for i, vx := range this.UnpackedSfixed64 {
		vy := that.UnpackedSfixed64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedFloat) != len(that.UnpackedFloat) {
		return false
	}
	for i, vx := range this.UnpackedFloat {
		vy := that.UnpackedFloat[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedDouble) != len(that.UnpackedDouble) {
		return false
	}
	for i, vx := range this.UnpackedDouble {
		vy := that.UnpackedDouble[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedBool) != len(that.UnpackedBool) {
		return false
	}
	for i, vx := range this.UnpackedBool {
		vy := that.UnpackedBool[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedNestedEnum) != len(that.UnpackedNestedEnum) {
		return false
	}
	for i, vx := range this.UnpackedNestedEnum {
		vy := that.UnpackedNestedEnum[i]
		if vx != vy {
			return false
		}
	}
	if !this.Data.EqualVT(that.Data) {
		return false
	}
	if p, q := this.DefaultInt32, that.DefaultInt32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultInt64, that.DefaultInt64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultUint32, that.DefaultUint32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultUint64, that.DefaultUint64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultSint32, that.DefaultSint32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultSint64, that.DefaultSint64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultFixed32, that.DefaultFixed32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultFixed64, that.DefaultFixed64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultSfixed32, that.DefaultSfixed32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultSfixed64, that.DefaultSfixed64; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultFloat, that.DefaultFloat; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultDouble, that.DefaultDouble; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultBool, that.DefaultBool; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultString, that.DefaultString; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultBytes, that.DefaultBytes; (p == nil && q != nil) || (p != nil && q == nil) || string(p) != string(q) {
		return false
	}
	if p, q := this.Fieldname1, that.Fieldname1; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.FieldName2, that.FieldName2; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.XFieldName3, that.XFieldName3; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Field_Name4_, that.Field_Name4_; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Field0Name5, that.Field0Name5; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Field_0Name6, that.Field_0Name6; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.FieldName7, that.FieldName7; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.FieldName8, that.FieldName8; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Field_Name9, that.Field_Name9; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Field_Name10, that.Field_Name10; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.FIELD_NAME11, that.FIELD_NAME11; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.FIELDName12, that.FIELDName12; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.XFieldName13, that.XFieldName13; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.X_FieldName14, that.X_FieldName14; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Field_Name15, that.Field_Name15; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Field__Name16, that.Field__Name16; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.FieldName17__, that.FieldName17__; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.FieldName18__, that.FieldName18__; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *TestAllTypesProto2) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*TestAllTypesProto2)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *TestAllTypesProto2_OneofUint32) EqualVT(thatIface isTestAllTypesProto2_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto2_OneofUint32)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofUint32 != that.OneofUint32 {
		return false
	}
	return true
}

func (this *TestAllTypesProto2_OneofNestedMessage) EqualVT(thatIface isTestAllTypesProto2_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto2_OneofNestedMessage)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.OneofNestedMessage, that.OneofNestedMessage; p != q {
		if p == nil {
			p = &TestAllTypesProto2_NestedMessage{}
		}
		if q == nil {
			q = &TestAllTypesProto2_NestedMessage{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *TestAllTypesProto2_OneofString) EqualVT(thatIface isTestAllTypesProto2_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto2_OneofString)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofString != that.OneofString {
		return false
	}
	return true
}

func (this *TestAllTypesProto2_OneofBytes) EqualVT(thatIface isTestAllTypesProto2_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto2_OneofBytes)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if string(this.OneofBytes) != string(that.OneofBytes) {
		return false
	}
	return true
}

func (this *TestAllTypesProto2_OneofBool) EqualVT(thatIface isTestAllTypesProto2_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto2_OneofBool)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofBool != that.OneofBool {
		return false
	}
	return true
}

func (this *TestAllTypesProto2_OneofUint64) EqualVT(thatIface isTestAllTypesProto2_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto2_OneofUint64)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofUint64 != that.OneofUint64 {
		return false
	}
	return true
}

func (this *TestAllTypesProto2_OneofFloat) EqualVT(thatIface isTestAllTypesProto2_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto2_OneofFloat)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofFloat != that.OneofFloat {
		return false
	}
	return true
}

func (this *TestAllTypesProto2_OneofDouble) EqualVT(thatIface isTestAllTypesProto2_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto2_OneofDouble)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofDouble != that.OneofDouble {
		return false
	}
	return true
}

func (this *TestAllTypesProto2_OneofEnum) EqualVT(thatIface isTestAllTypesProto2_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto2_OneofEnum)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofEnum != that.OneofEnum {
		return false
	}
	return true
}

func (this *ForeignMessageProto2) EqualVT(that *ForeignMessageProto2) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.C, that.C; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ForeignMessageProto2) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*ForeignMessageProto2)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *UnknownToTestAllTypes_OptionalGroup) EqualVT(that *UnknownToTestAllTypes_OptionalGroup) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.A, that.A; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *UnknownToTestAllTypes_OptionalGroup) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*UnknownToTestAllTypes_OptionalGroup)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *UnknownToTestAllTypes) EqualVT(that *UnknownToTestAllTypes) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.OptionalInt32, that.OptionalInt32; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptionalString, that.OptionalString; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.NestedMessage.EqualVT(that.NestedMessage) {
		return false
	}
	if !this.Optionalgroup.EqualVT(that.Optionalgroup) {
		return false
	}
	if p, q := this.OptionalBool, that.OptionalBool; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.RepeatedInt32) != len(that.RepeatedInt32) {
		return false
	}
	for i, vx := range this.RepeatedInt32 {
		vy := that.RepeatedInt32[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *UnknownToTestAllTypes) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*UnknownToTestAllTypes)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *NullHypothesisProto2) EqualVT(that *NullHypothesisProto2) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *NullHypothesisProto2) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*NullHypothesisProto2)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *EnumOnlyProto2) EqualVT(that *EnumOnlyProto2) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnumOnlyProto2) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*EnumOnlyProto2)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *OneStringProto2) EqualVT(that *OneStringProto2) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Data, that.Data; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *OneStringProto2) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*OneStringProto2)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (m *TestAllTypesProto2_NestedMessage) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto2_NestedMessage) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_NestedMessage) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Corecursive != nil {
		size, err := m.Corecursive.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.A != nil {
		i = encodeVarint(dAtA, i, uint64(*m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto2_Data) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto2_Data) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_Data) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.GroupUint32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.GroupUint32))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd8
	}
	if m.GroupInt32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.GroupInt32))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd0
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto2_MessageSetCorrect) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto2_MessageSetCorrect) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_MessageSetCorrect) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension1) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension1) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension1) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Str != nil {
		i -= len(*m.Str)
		copy(dAtA[i:], *m.Str)
		i = encodeVarint(dAtA, i, uint64(len(*m.Str)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension2) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension2) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension2) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.I != nil {
		i = encodeVarint(dAtA, i, uint64(*m.I))
		i--
		dAtA[i] = 0x48
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto2) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto2) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if vtmsg, ok := m.OneofField.(interface {
		MarshalToSizedBufferVT([]byte) (int, error)
	}); ok {
		size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if m.FieldName18__ != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FieldName18__))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x90
	}
	if m.FieldName17__ != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FieldName17__))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x88
	}
	if m.Field__Name16 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field__Name16))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x80
	}
	if m.Field_Name15 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field_Name15))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xf8
	}
	if m.X_FieldName14 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.X_FieldName14))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xf0
	}
	if m.XFieldName13 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.XFieldName13))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xe8
	}
	if m.FIELDName12 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FIELDName12))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xe0
	}
	if m.FIELD_NAME11 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FIELD_NAME11))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xd8
	}
	if m.Field_Name10 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field_Name10))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xd0
	}
	if m.Field_Name9 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field_Name9))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xc8
	}
	if m.FieldName8 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FieldName8))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xc0
	}
	if m.FieldName7 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FieldName7))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xb8
	}
	if m.Field_0Name6 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field_0Name6))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xb0
	}
	if m.Field0Name5 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field0Name5))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xa8
	}
	if m.Field_Name4_ != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field_Name4_))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xa0
	}
	if m.XFieldName3 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.XFieldName3))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x98
	}
	if m.FieldName2 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FieldName2))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x90
	}
	if m.Fieldname1 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Fieldname1))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x88
	}
	if m.DefaultBytes != nil {
		i -= len(m.DefaultBytes)
		copy(dAtA[i:], m.DefaultBytes)
		i = encodeVarint(dAtA, i, uint64(len(m.DefaultBytes)))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xfa
	}
	if m.DefaultString != nil {
		i -= len(*m.DefaultString)
		copy(dAtA[i:], *m.DefaultString)
		i = encodeVarint(dAtA, i, uint64(len(*m.DefaultString)))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xf2
	}
	if m.DefaultBool != nil {
		i--
		if *m.DefaultBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xe8
	}
	if m.DefaultDouble != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DefaultDouble))))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xe1
	}
	if m.DefaultFloat != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DefaultFloat))))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xdd
	}
	if m.DefaultSfixed64 != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.DefaultSfixed64))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xd1
	}
	if m.DefaultSfixed32 != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.DefaultSfixed32))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xcd
	}
	if m.DefaultFixed64 != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.DefaultFixed64))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xc1
	}
	if m.DefaultFixed32 != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.DefaultFixed32))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xbd
	}
	if m.DefaultSint64 != nil {
		i = encodeVarint(dAtA, i, uint64((uint64(*m.DefaultSint64)<<1)^uint64((*m.DefaultSint64>>63))))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xb0
	}
	if m.DefaultSint32 != nil {
		i = encodeVarint(dAtA, i, uint64((uint32(*m.DefaultSint32)<<1)^uint32((*m.DefaultSint32>>31))))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xa8
	}
	if m.DefaultUint64 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.DefaultUint64))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xa0
	}
	if m.DefaultUint32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.DefaultUint32))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0x98
	}
	if m.DefaultInt64 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.DefaultInt64))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0x90
	}
	if m.DefaultInt32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.DefaultInt32))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0x88
	}
	if m.Data != nil {
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xcc
		size, err := m.Data.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xcb
	}
	if len(m.UnpackedNestedEnum) > 0 {
		for iNdEx := len(m.UnpackedNestedEnum) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedNestedEnum[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xb0
		}
	}
	if len(m.UnpackedBool) > 0 {
		for iNdEx := len(m.UnpackedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.UnpackedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa8
		}
	}
	if len(m.UnpackedDouble) > 0 {
		for iNdEx := len(m.UnpackedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float64bits(float64(m.UnpackedDouble[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f1))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa1
		}
	}
	if len(m.UnpackedFloat) > 0 {
		for iNdEx := len(m.UnpackedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f2 := math.Float32bits(float32(m.UnpackedFloat[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f2))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x9d
		}
	}
	if len(m.UnpackedSfixed64) > 0 {
		for iNdEx := len(m.UnpackedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.UnpackedSfixed64[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x91
		}
	}
	if len(m.UnpackedSfixed32) > 0 {
		for iNdEx := len(m.UnpackedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.UnpackedSfixed32[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x8d
		}
	}
	if len(m.UnpackedFixed64) > 0 {
		for iNdEx := len(m.UnpackedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.UnpackedFixed64[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x81
		}
	}
	if len(m.UnpackedFixed32) > 0 {
		for iNdEx := len(m.UnpackedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.UnpackedFixed32[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xfd
		}
	}
	if len(m.UnpackedSint64) > 0 {
		for iNdEx := len(m.UnpackedSint64) - 1; iNdEx >= 0; iNdEx-- {
			x3 := (uint64(m.UnpackedSint64[iNdEx]) << 1) ^ uint64((m.UnpackedSint64[iNdEx] >> 63))
			i = encodeVarint(dAtA, i, uint64(x3))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xf0
		}
	}
	if len(m.UnpackedSint32) > 0 {
		for iNdEx := len(m.UnpackedSint32) - 1; iNdEx >= 0; iNdEx-- {
			x4 := (uint32(m.UnpackedSint32[iNdEx]) << 1) ^ uint32((m.UnpackedSint32[iNdEx] >> 31))
			i = encodeVarint(dAtA, i, uint64(x4))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xe8
		}
	}
	if len(m.UnpackedUint64) > 0 {
		for iNdEx := len(m.UnpackedUint64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedUint64[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xe0
		}
	}
	if len(m.UnpackedUint32) > 0 {
		for iNdEx := len(m.UnpackedUint32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedUint32[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xd8
		}
	}
	if len(m.UnpackedInt64) > 0 {
		for iNdEx := len(m.UnpackedInt64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedInt64[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xd0
		}
	}
	if len(m.UnpackedInt32) > 0 {
		for iNdEx := len(m.UnpackedInt32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedInt32[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xc8
		}
	}
	if len(m.PackedNestedEnum) > 0 {
		var pksize6 int
		for _, num := range m.PackedNestedEnum {
			pksize6 += sov(uint64(num))
		}
		i -= pksize6
		j5 := i
		for _, num1 := range m.PackedNestedEnum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA[j5] = uint8(num)
			j5++
		}
		i = encodeVarint(dAtA, i, uint64(pksize6))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc2
	}
	if len(m.PackedBool) > 0 {
		for iNdEx := len(m.PackedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.PackedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedBool)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xba
	}
	if len(m.PackedDouble) > 0 {
		for iNdEx := len(m.PackedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f7 := math.Float64bits(float64(m.PackedDouble[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f7))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedDouble)*8))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xb2
	}
	if len(m.PackedFloat) > 0 {
		for iNdEx := len(m.PackedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f8 := math.Float32bits(float32(m.PackedFloat[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f8))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedFloat)*4))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xaa
	}
	if len(m.PackedSfixed64) > 0 {
		for iNdEx := len(m.PackedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PackedSfixed64[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedSfixed64)*8))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xa2
	}
	if len(m.PackedSfixed32) > 0 {
		for iNdEx := len(m.PackedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.PackedSfixed32[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedSfixed32)*4))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x9a
	}
	if len(m.PackedFixed64) > 0 {
		for iNdEx := len(m.PackedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PackedFixed64[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedFixed64)*8))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x92
	}
	if len(m.PackedFixed32) > 0 {
		for iNdEx := len(m.PackedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.PackedFixed32[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedFixed32)*4))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x8a
	}
	if len(m.PackedSint64) > 0 {
		var pksize10 int
		for _, num := range m.PackedSint64 {
			pksize10 += soz(uint64(num))
		}
		i -= pksize10
		j9 := i
		for _, num := range m.PackedSint64 {
			x11 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x11 >= 1<<7 {
				dAtA[j9] = uint8(uint64(x11)&0x7f | 0x80)
				j9++
				x11 >>= 7
			}
			dAtA[j9] = uint8(x11)
			j9++
		}
		i = encodeVarint(dAtA, i, uint64(pksize10))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x82
	}
	if len(m.PackedSint32) > 0 {
		var pksize13 int
		for _, num := range m.PackedSint32 {
			pksize13 += soz(uint64(num))
		}
		i -= pksize13
		j12 := i
		for _, num := range m.PackedSint32 {
			x14 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x14 >= 1<<7 {
				dAtA[j12] = uint8(uint64(x14)&0x7f | 0x80)
				j12++
				x14 >>= 7
			}
			dAtA[j12] = uint8(x14)
			j12++
		}
		i = encodeVarint(dAtA, i, uint64(pksize13))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xfa
	}
	if len(m.PackedUint64) > 0 {
		var pksize16 int
		for _, num := range m.PackedUint64 {
			pksize16 += sov(uint64(num))
		}
		i -= pksize16
		j15 := i
		for _, num := range m.PackedUint64 {
			for num >= 1<<7 {
				dAtA[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA[j15] = uint8(num)
			j15++
		}
		i = encodeVarint(dAtA, i, uint64(pksize16))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
	}
	if len(m.PackedUint32) > 0 {
		var pksize18 int
		for _, num := range m.PackedUint32 {
			pksize18 += sov(uint64(num))
		}
		i -= pksize18
		j17 := i
		for _, num := range m.PackedUint32 {
			for num >= 1<<7 {
				dAtA[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA[j17] = uint8(num)
			j17++
		}
		i = encodeVarint(dAtA, i, uint64(pksize18))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xea
	}
	if len(m.PackedInt64) > 0 {
		var pksize20 int
		for _, num := range m.PackedInt64 {
			pksize20 += sov(uint64(num))
		}
		i -= pksize20
		j19 := i
		for _, num1 := range m.PackedInt64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA[j19] = uint8(num)
			j19++
		}
		i = encodeVarint(dAtA, i, uint64(pksize20))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe2
	}
	if len(m.PackedInt32) > 0 {
		var pksize22 int
		for _, num := range m.PackedInt32 {
			pksize22 += sov(uint64(num))
		}
		i -= pksize22
		j21 := i
		for _, num1 := range m.PackedInt32 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA[j21] = uint8(num)
			j21++
		}
		i = encodeVarint(dAtA, i, uint64(pksize22))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xda
	}
	if len(m.MapStringForeignEnum) > 0 {
		for k := range m.MapStringForeignEnum {
			v := m.MapStringForeignEnum[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.MapStringNestedEnum) > 0 {
		for k := range m.MapStringNestedEnum {
			v := m.MapStringNestedEnum[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.MapStringForeignMessage) > 0 {
		for k := range m.MapStringForeignMessage {
			v := m.MapStringForeignMessage[k]
			baseI := i
			size, err := v.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.MapStringNestedMessage) > 0 {
		for k := range m.MapStringNestedMessage {
			v := m.MapStringNestedMessage[k]
			baseI := i
			size, err := v.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.MapStringBytes) > 0 {
		for k := range m.MapStringBytes {
			v := m.MapStringBytes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarint(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.MapStringString) > 0 {
		for k := range m.MapStringString {
			v := m.MapStringString[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarint(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.MapBoolBool) > 0 {
		for k := range m.MapBoolBool {
			v := m.MapBoolBool[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i--
			if k {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.MapInt32Double) > 0 {
		for k := range m.MapInt32Double {
			v := m.MapInt32Double[k]
			baseI := i
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i--
			dAtA[i] = 0x11
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.MapInt32Float) > 0 {
		for k := range m.MapInt32Float {
			v := m.MapInt32Float[k]
			baseI := i
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(v))))
			i--
			dAtA[i] = 0x15
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.MapSfixed64Sfixed64) > 0 {
		for k := range m.MapSfixed64Sfixed64 {
			v := m.MapSfixed64Sfixed64[k]
			baseI := i
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(v))
			i--
			dAtA[i] = 0x11
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(k))
			i--
			dAtA[i] = 0x9
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.MapSfixed32Sfixed32) > 0 {
		for k := range m.MapSfixed32Sfixed32 {
			v := m.MapSfixed32Sfixed32[k]
			baseI := i
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(v))
			i--
			dAtA[i] = 0x15
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.MapFixed64Fixed64) > 0 {
		for k := range m.MapFixed64Fixed64 {
			v := m.MapFixed64Fixed64[k]
			baseI := i
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(v))
			i--
			dAtA[i] = 0x11
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(k))
			i--
			dAtA[i] = 0x9
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.MapFixed32Fixed32) > 0 {
		for k := range m.MapFixed32Fixed32 {
			v := m.MapFixed32Fixed32[k]
			baseI := i
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(v))
			i--
			dAtA[i] = 0x15
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.MapSint64Sint64) > 0 {
		for k := range m.MapSint64Sint64 {
			v := m.MapSint64Sint64[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64((uint64(v)<<1)^uint64((v>>63))))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64((uint64(k)<<1)^uint64((k>>63))))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.MapSint32Sint32) > 0 {
		for k := range m.MapSint32Sint32 {
			v := m.MapSint32Sint32[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64((uint32(v)<<1)^uint32((v>>31))))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64((uint32(k)<<1)^uint32((k>>31))))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.MapUint64Uint64) > 0 {
		for k := range m.MapUint64Uint64 {
			v := m.MapUint64Uint64[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.MapUint32Uint32) > 0 {
		for k := range m.MapUint32Uint32 {
			v := m.MapUint32Uint32[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.MapInt64Int64) > 0 {
		for k := range m.MapInt64Int64 {
			v := m.MapInt64Int64[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.MapInt32Int32) > 0 {
		for k := range m.MapInt32Int32 {
			v := m.MapInt32Int32[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.RepeatedCord) > 0 {
		for iNdEx := len(m.RepeatedCord) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedCord[iNdEx])
			copy(dAtA[i:], m.RepeatedCord[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedCord[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.RepeatedStringPiece) > 0 {
		for iNdEx := len(m.RepeatedStringPiece) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedStringPiece[iNdEx])
			copy(dAtA[i:], m.RepeatedStringPiece[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedStringPiece[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.RepeatedForeignEnum) > 0 {
		for iNdEx := len(m.RepeatedForeignEnum) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedForeignEnum[iNdEx]))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xa0
		}
	}
	if len(m.RepeatedNestedEnum) > 0 {
		for iNdEx := len(m.RepeatedNestedEnum) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedNestedEnum[iNdEx]))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x98
		}
	}
	if len(m.RepeatedForeignMessage) > 0 {
		for iNdEx := len(m.RepeatedForeignMessage) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.RepeatedForeignMessage[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.RepeatedNestedMessage) > 0 {
		for iNdEx := len(m.RepeatedNestedMessage) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.RepeatedNestedMessage[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.RepeatedBytes) > 0 {
		for iNdEx := len(m.RepeatedBytes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedBytes[iNdEx])
			copy(dAtA[i:], m.RepeatedBytes[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedBytes[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.RepeatedString) > 0 {
		for iNdEx := len(m.RepeatedString) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedString[iNdEx])
			copy(dAtA[i:], m.RepeatedString[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedString[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.RepeatedBool) > 0 {
		for iNdEx := len(m.RepeatedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.RepeatedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd8
		}
	}
	if len(m.RepeatedDouble) > 0 {
		for iNdEx := len(m.RepeatedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f23 := math.Float64bits(float64(m.RepeatedDouble[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f23))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd1
		}
	}
	if len(m.RepeatedFloat) > 0 {
		for iNdEx := len(m.RepeatedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f24 := math.Float32bits(float32(m.RepeatedFloat[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f24))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xcd
		}
	}
	if len(m.RepeatedSfixed64) > 0 {
		for iNdEx := len(m.RepeatedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RepeatedSfixed64[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc1
		}
	}
	if len(m.RepeatedSfixed32) > 0 {
		for iNdEx := len(m.RepeatedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RepeatedSfixed32[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xbd
		}
	}
	if len(m.RepeatedFixed64) > 0 {
		for iNdEx := len(m.RepeatedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RepeatedFixed64[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb1
		}
	}
	if len(m.RepeatedFixed32) > 0 {
		for iNdEx := len(m.RepeatedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RepeatedFixed32[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xad
		}
	}
	if len(m.RepeatedSint64) > 0 {
		for iNdEx := len(m.RepeatedSint64) - 1; iNdEx >= 0; iNdEx-- {
			x25 := (uint64(m.RepeatedSint64[iNdEx]) << 1) ^ uint64((m.RepeatedSint64[iNdEx] >> 63))
			i = encodeVarint(dAtA, i, uint64(x25))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa0
		}
	}
	if len(m.RepeatedSint32) > 0 {
		for iNdEx := len(m.RepeatedSint32) - 1; iNdEx >= 0; iNdEx-- {
			x26 := (uint32(m.RepeatedSint32[iNdEx]) << 1) ^ uint32((m.RepeatedSint32[iNdEx] >> 31))
			i = encodeVarint(dAtA, i, uint64(x26))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x98
		}
	}
	if len(m.RepeatedUint64) > 0 {
		for iNdEx := len(m.RepeatedUint64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedUint64[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x90
		}
	}
	if len(m.RepeatedUint32) > 0 {
		for iNdEx := len(m.RepeatedUint32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedUint32[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x88
		}
	}
	if len(m.RepeatedInt64) > 0 {
		for iNdEx := len(m.RepeatedInt64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedInt64[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x80
		}
	}
	if len(m.RepeatedInt32) > 0 {
		for iNdEx := len(m.RepeatedInt32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedInt32[iNdEx]))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf8
		}
	}
	if m.RecursiveMessage != nil {
		size, err := m.RecursiveMessage.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.OptionalCord != nil {
		i -= len(*m.OptionalCord)
		copy(dAtA[i:], *m.OptionalCord)
		i = encodeVarint(dAtA, i, uint64(len(*m.OptionalCord)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.OptionalStringPiece != nil {
		i -= len(*m.OptionalStringPiece)
		copy(dAtA[i:], *m.OptionalStringPiece)
		i = encodeVarint(dAtA, i, uint64(len(*m.OptionalStringPiece)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.OptionalForeignEnum != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalForeignEnum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.OptionalNestedEnum != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalNestedEnum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.OptionalForeignMessage != nil {
		size, err := m.OptionalForeignMessage.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.OptionalNestedMessage != nil {
		size, err := m.OptionalNestedMessage.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.OptionalBytes != nil {
		i -= len(m.OptionalBytes)
		copy(dAtA[i:], m.OptionalBytes)
		i = encodeVarint(dAtA, i, uint64(len(m.OptionalBytes)))
		i--
		dAtA[i] = 0x7a
	}
	if m.OptionalString != nil {
		i -= len(*m.OptionalString)
		copy(dAtA[i:], *m.OptionalString)
		i = encodeVarint(dAtA, i, uint64(len(*m.OptionalString)))
		i--
		dAtA[i] = 0x72
	}
	if m.OptionalBool != nil {
		i--
		if *m.OptionalBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.OptionalDouble != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.OptionalDouble))))
		i--
		dAtA[i] = 0x61
	}
	if m.OptionalFloat != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.OptionalFloat))))
		i--
		dAtA[i] = 0x5d
	}
	if m.OptionalSfixed64 != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.OptionalSfixed64))
		i--
		dAtA[i] = 0x51
	}
	if m.OptionalSfixed32 != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.OptionalSfixed32))
		i--
		dAtA[i] = 0x4d
	}
	if m.OptionalFixed64 != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.OptionalFixed64))
		i--
		dAtA[i] = 0x41
	}
	if m.OptionalFixed32 != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.OptionalFixed32))
		i--
		dAtA[i] = 0x3d
	}
	if m.OptionalSint64 != nil {
		i = encodeVarint(dAtA, i, uint64((uint64(*m.OptionalSint64)<<1)^uint64((*m.OptionalSint64>>63))))
		i--
		dAtA[i] = 0x30
	}
	if m.OptionalSint32 != nil {
		i = encodeVarint(dAtA, i, uint64((uint32(*m.OptionalSint32)<<1)^uint32((*m.OptionalSint32>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.OptionalUint64 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalUint64))
		i--
		dAtA[i] = 0x20
	}
	if m.OptionalUint32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalUint32))
		i--
		dAtA[i] = 0x18
	}
	if m.OptionalInt64 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalInt64))
		i--
		dAtA[i] = 0x10
	}
	if m.OptionalInt32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalInt32))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto2_OneofUint32) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofUint32) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofUint32))
	i--
	dAtA[i] = 0x6
	i--
	dAtA[i] = 0xf8
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofNestedMessage) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofNestedMessage) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OneofNestedMessage != nil {
		size, err := m.OneofNestedMessage.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofString) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofString) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.OneofString)
	copy(dAtA[i:], m.OneofString)
	i = encodeVarint(dAtA, i, uint64(len(m.OneofString)))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0x8a
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofBytes) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofBytes) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.OneofBytes)
	copy(dAtA[i:], m.OneofBytes)
	i = encodeVarint(dAtA, i, uint64(len(m.OneofBytes)))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0x92
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofBool) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofBool) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.OneofBool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0x98
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofUint64) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofUint64) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofUint64))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xa0
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofFloat) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofFloat) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.OneofFloat))))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xad
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofDouble) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofDouble) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OneofDouble))))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xb1
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofEnum) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofEnum) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofEnum))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xb8
	return len(dAtA) - i, nil
}
func (m *ForeignMessageProto2) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignMessageProto2) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ForeignMessageProto2) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.C != nil {
		i = encodeVarint(dAtA, i, uint64(*m.C))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnknownToTestAllTypes_OptionalGroup) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnknownToTestAllTypes_OptionalGroup) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *UnknownToTestAllTypes_OptionalGroup) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.A != nil {
		i = encodeVarint(dAtA, i, uint64(*m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnknownToTestAllTypes) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnknownToTestAllTypes) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *UnknownToTestAllTypes) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.RepeatedInt32) > 0 {
		for iNdEx := len(m.RepeatedInt32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedInt32[iNdEx]))
			i--
			dAtA[i] = 0x3f
			i--
			dAtA[i] = 0x98
		}
	}
	if m.OptionalBool != nil {
		i--
		if *m.OptionalBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xf0
	}
	if m.Optionalgroup != nil {
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xe4
		size, err := m.Optionalgroup.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xe3
	}
	if m.NestedMessage != nil {
		size, err := m.NestedMessage.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xda
	}
	if m.OptionalString != nil {
		i -= len(*m.OptionalString)
		copy(dAtA[i:], *m.OptionalString)
		i = encodeVarint(dAtA, i, uint64(len(*m.OptionalString)))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xd2
	}
	if m.OptionalInt32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalInt32))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc8
	}
	return len(dAtA) - i, nil
}

func (m *NullHypothesisProto2) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullHypothesisProto2) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *NullHypothesisProto2) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	return len(dAtA) - i, nil
}

func (m *EnumOnlyProto2) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumOnlyProto2) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnumOnlyProto2) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	return len(dAtA) - i, nil
}

func (m *OneStringProto2) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OneStringProto2) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *OneStringProto2) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Data != nil {
		i -= len(*m.Data)
		copy(dAtA[i:], *m.Data)
		i = encodeVarint(dAtA, i, uint64(len(*m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func sov(x uint64) (n int) {
	return (bits.Len64(x|1) + 6) / 7
}
func encodeVarint(dAtA []byte, offset int, v uint64) int {
	offset -= sov(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TestAllTypesProto2_NestedMessage) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto2_NestedMessage) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_NestedMessage) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Corecursive != nil {
		size, err := m.Corecursive.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.A != nil {
		i = encodeVarint(dAtA, i, uint64(*m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto2_Data) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto2_Data) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_Data) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.GroupUint32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.GroupUint32))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd8
	}
	if m.GroupInt32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.GroupInt32))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd0
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto2_MessageSetCorrect) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto2_MessageSetCorrect) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_MessageSetCorrect) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension1) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension1) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension1) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Str != nil {
		i -= len(*m.Str)
		copy(dAtA[i:], *m.Str)
		i = encodeVarint(dAtA, i, uint64(len(*m.Str)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension2) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension2) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension2) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.I != nil {
		i = encodeVarint(dAtA, i, uint64(*m.I))
		i--
		dAtA[i] = 0x48
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto2) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto2) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.FieldName18__ != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FieldName18__))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x90
	}
	if m.FieldName17__ != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FieldName17__))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x88
	}
	if m.Field__Name16 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field__Name16))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x80
	}
	if m.Field_Name15 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field_Name15))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xf8
	}
	if m.X_FieldName14 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.X_FieldName14))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xf0
	}
	if m.XFieldName13 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.XFieldName13))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xe8
	}
	if m.FIELDName12 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FIELDName12))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xe0
	}
	if m.FIELD_NAME11 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FIELD_NAME11))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xd8
	}
	if m.Field_Name10 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field_Name10))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xd0
	}
	if m.Field_Name9 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field_Name9))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xc8
	}
	if m.FieldName8 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FieldName8))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xc0
	}
	if m.FieldName7 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FieldName7))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xb8
	}
	if m.Field_0Name6 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field_0Name6))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xb0
	}
	if m.Field0Name5 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field0Name5))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xa8
	}
	if m.Field_Name4_ != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Field_Name4_))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xa0
	}
	if m.XFieldName3 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.XFieldName3))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x98
	}
	if m.FieldName2 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.FieldName2))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x90
	}
	if m.Fieldname1 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Fieldname1))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x88
	}
	if m.DefaultBytes != nil {
		i -= len(m.DefaultBytes)
		copy(dAtA[i:], m.DefaultBytes)
		i = encodeVarint(dAtA, i, uint64(len(m.DefaultBytes)))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xfa
	}
	if m.DefaultString != nil {
		i -= len(*m.DefaultString)
		copy(dAtA[i:], *m.DefaultString)
		i = encodeVarint(dAtA, i, uint64(len(*m.DefaultString)))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xf2
	}
	if m.DefaultBool != nil {
		i--
		if *m.DefaultBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xe8
	}
	if m.DefaultDouble != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DefaultDouble))))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xe1
	}
	if m.DefaultFloat != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DefaultFloat))))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xdd
	}
	if m.DefaultSfixed64 != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.DefaultSfixed64))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xd1
	}
	if m.DefaultSfixed32 != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.DefaultSfixed32))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xcd
	}
	if m.DefaultFixed64 != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.DefaultFixed64))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xc1
	}
	if m.DefaultFixed32 != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.DefaultFixed32))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xbd
	}
	if m.DefaultSint64 != nil {
		i = encodeVarint(dAtA, i, uint64((uint64(*m.DefaultSint64)<<1)^uint64((*m.DefaultSint64>>63))))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xb0
	}
	if m.DefaultSint32 != nil {
		i = encodeVarint(dAtA, i, uint64((uint32(*m.DefaultSint32)<<1)^uint32((*m.DefaultSint32>>31))))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xa8
	}
	if m.DefaultUint64 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.DefaultUint64))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0xa0
	}
	if m.DefaultUint32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.DefaultUint32))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0x98
	}
	if m.DefaultInt64 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.DefaultInt64))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0x90
	}
	if m.DefaultInt32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.DefaultInt32))
		i--
		dAtA[i] = 0xf
		i--
		dAtA[i] = 0x88
	}
	if m.Data != nil {
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xcc
		size, err := m.Data.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xcb
	}
	if msg, ok := m.OneofField.(*TestAllTypesProto2_OneofEnum); ok {
		size, err := msg.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if msg, ok := m.OneofField.(*TestAllTypesProto2_OneofDouble); ok {
		size, err := msg.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if msg, ok := m.OneofField.(*TestAllTypesProto2_OneofFloat); ok {
		size, err := msg.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if msg, ok := m.OneofField.(*TestAllTypesProto2_OneofUint64); ok {
		size, err := msg.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if msg, ok := m.OneofField.(*TestAllTypesProto2_OneofBool); ok {
		size, err := msg.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if msg, ok := m.OneofField.(*TestAllTypesProto2_OneofBytes); ok {
		size, err := msg.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if msg, ok := m.OneofField.(*TestAllTypesProto2_OneofString); ok {
		size, err := msg.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if msg, ok := m.OneofField.(*TestAllTypesProto2_OneofNestedMessage); ok {
		size, err := msg.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if msg, ok := m.OneofField.(*TestAllTypesProto2_OneofUint32); ok {
		size, err := msg.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if len(m.UnpackedNestedEnum) > 0 {
		for iNdEx := len(m.UnpackedNestedEnum) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedNestedEnum[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xb0
		}
	}
	if len(m.UnpackedBool) > 0 {
		for iNdEx := len(m.UnpackedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.UnpackedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa8
		}
	}
	if len(m.UnpackedDouble) > 0 {
		for iNdEx := len(m.UnpackedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float64bits(float64(m.UnpackedDouble[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f1))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa1
		}
	}
	if len(m.UnpackedFloat) > 0 {
		for iNdEx := len(m.UnpackedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f2 := math.Float32bits(float32(m.UnpackedFloat[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f2))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x9d
		}
	}
	if len(m.UnpackedSfixed64) > 0 {
		for iNdEx := len(m.UnpackedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.UnpackedSfixed64[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x91
		}
	}
	if len(m.UnpackedSfixed32) > 0 {
		for iNdEx := len(m.UnpackedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.UnpackedSfixed32[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x8d
		}
	}
	if len(m.UnpackedFixed64) > 0 {
		for iNdEx := len(m.UnpackedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.UnpackedFixed64[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x81
		}
	}
	if len(m.UnpackedFixed32) > 0 {
		for iNdEx := len(m.UnpackedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.UnpackedFixed32[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xfd
		}
	}
	if len(m.UnpackedSint64) > 0 {
		for iNdEx := len(m.UnpackedSint64) - 1; iNdEx >= 0; iNdEx-- {
			x3 := (uint64(m.UnpackedSint64[iNdEx]) << 1) ^ uint64((m.UnpackedSint64[iNdEx] >> 63))
			i = encodeVarint(dAtA, i, uint64(x3))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xf0
		}
	}
	if len(m.UnpackedSint32) > 0 {
		for iNdEx := len(m.UnpackedSint32) - 1; iNdEx >= 0; iNdEx-- {
			x4 := (uint32(m.UnpackedSint32[iNdEx]) << 1) ^ uint32((m.UnpackedSint32[iNdEx] >> 31))
			i = encodeVarint(dAtA, i, uint64(x4))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xe8
		}
	}
	if len(m.UnpackedUint64) > 0 {
		for iNdEx := len(m.UnpackedUint64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedUint64[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xe0
		}
	}
	if len(m.UnpackedUint32) > 0 {
		for iNdEx := len(m.UnpackedUint32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedUint32[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xd8
		}
	}
	if len(m.UnpackedInt64) > 0 {
		for iNdEx := len(m.UnpackedInt64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedInt64[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xd0
		}
	}
	if len(m.UnpackedInt32) > 0 {
		for iNdEx := len(m.UnpackedInt32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedInt32[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xc8
		}
	}
	if len(m.PackedNestedEnum) > 0 {
		var pksize6 int
		for _, num := range m.PackedNestedEnum {
			pksize6 += sov(uint64(num))
		}
		i -= pksize6
		j5 := i
		for _, num1 := range m.PackedNestedEnum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA[j5] = uint8(num)
			j5++
		}
		i = encodeVarint(dAtA, i, uint64(pksize6))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc2
	}
	if len(m.PackedBool) > 0 {
		for iNdEx := len(m.PackedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.PackedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedBool)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xba
	}
	if len(m.PackedDouble) > 0 {
		for iNdEx := len(m.PackedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f7 := math.Float64bits(float64(m.PackedDouble[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f7))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedDouble)*8))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xb2
	}
	if len(m.PackedFloat) > 0 {
		for iNdEx := len(m.PackedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f8 := math.Float32bits(float32(m.PackedFloat[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f8))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedFloat)*4))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xaa
	}
	if len(m.PackedSfixed64) > 0 {
		for iNdEx := len(m.PackedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PackedSfixed64[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedSfixed64)*8))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xa2
	}
	if len(m.PackedSfixed32) > 0 {
		for iNdEx := len(m.PackedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.PackedSfixed32[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedSfixed32)*4))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x9a
	}
	if len(m.PackedFixed64) > 0 {
		for iNdEx := len(m.PackedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PackedFixed64[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedFixed64)*8))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x92
	}
	if len(m.PackedFixed32) > 0 {
		for iNdEx := len(m.PackedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.PackedFixed32[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedFixed32)*4))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x8a
	}
	if len(m.PackedSint64) > 0 {
		var pksize10 int
		for _, num := range m.PackedSint64 {
			pksize10 += soz(uint64(num))
		}
		i -= pksize10
		j9 := i
		for _, num := range m.PackedSint64 {
			x11 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x11 >= 1<<7 {
				dAtA[j9] = uint8(uint64(x11)&0x7f | 0x80)
				j9++
				x11 >>= 7
			}
			dAtA[j9] = uint8(x11)
			j9++
		}
		i = encodeVarint(dAtA, i, uint64(pksize10))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x82
	}
	if len(m.PackedSint32) > 0 {
		var pksize13 int
		for _, num := range m.PackedSint32 {
			pksize13 += soz(uint64(num))
		}
		i -= pksize13
		j12 := i
		for _, num := range m.PackedSint32 {
			x14 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x14 >= 1<<7 {
				dAtA[j12] = uint8(uint64(x14)&0x7f | 0x80)
				j12++
				x14 >>= 7
			}
			dAtA[j12] = uint8(x14)
			j12++
		}
		i = encodeVarint(dAtA, i, uint64(pksize13))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xfa
	}
	if len(m.PackedUint64) > 0 {
		var pksize16 int
		for _, num := range m.PackedUint64 {
			pksize16 += sov(uint64(num))
		}
		i -= pksize16
		j15 := i
		for _, num := range m.PackedUint64 {
			for num >= 1<<7 {
				dAtA[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA[j15] = uint8(num)
			j15++
		}
		i = encodeVarint(dAtA, i, uint64(pksize16))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
	}
	if len(m.PackedUint32) > 0 {
		var pksize18 int
		for _, num := range m.PackedUint32 {
			pksize18 += sov(uint64(num))
		}
		i -= pksize18
		j17 := i
		for _, num := range m.PackedUint32 {
			for num >= 1<<7 {
				dAtA[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA[j17] = uint8(num)
			j17++
		}
		i = encodeVarint(dAtA, i, uint64(pksize18))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xea
	}
	if len(m.PackedInt64) > 0 {
		var pksize20 int
		for _, num := range m.PackedInt64 {
			pksize20 += sov(uint64(num))
		}
		i -= pksize20
		j19 := i
		for _, num1 := range m.PackedInt64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA[j19] = uint8(num)
			j19++
		}
		i = encodeVarint(dAtA, i, uint64(pksize20))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe2
	}
	if len(m.PackedInt32) > 0 {
		var pksize22 int
		for _, num := range m.PackedInt32 {
			pksize22 += sov(uint64(num))
		}
		i -= pksize22
		j21 := i
		for _, num1 := range m.PackedInt32 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA[j21] = uint8(num)
			j21++
		}
		i = encodeVarint(dAtA, i, uint64(pksize22))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xda
	}
	if len(m.MapStringForeignEnum) > 0 {
		for k := range m.MapStringForeignEnum {
			v := m.MapStringForeignEnum[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.MapStringNestedEnum) > 0 {
		for k := range m.MapStringNestedEnum {
			v := m.MapStringNestedEnum[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.MapStringForeignMessage) > 0 {
		for k := range m.MapStringForeignMessage {
			v := m.MapStringForeignMessage[k]
			baseI := i
			size, err := v.MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.MapStringNestedMessage) > 0 {
		for k := range m.MapStringNestedMessage {
			v := m.MapStringNestedMessage[k]
			baseI := i
			size, err := v.MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.MapStringBytes) > 0 {
		for k := range m.MapStringBytes {
			v := m.MapStringBytes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarint(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.MapStringString) > 0 {
		for k := range m.MapStringString {
			v := m.MapStringString[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarint(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.MapBoolBool) > 0 {
		for k := range m.MapBoolBool {
			v := m.MapBoolBool[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i--
			if k {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.MapInt32Double) > 0 {
		for k := range m.MapInt32Double {
			v := m.MapInt32Double[k]
			baseI := i
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i--
			dAtA[i] = 0x11
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.MapInt32Float) > 0 {
		for k := range m.MapInt32Float {
			v := m.MapInt32Float[k]
			baseI := i
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(v))))
			i--
			dAtA[i] = 0x15
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.MapSfixed64Sfixed64) > 0 {
		for k := range m.MapSfixed64Sfixed64 {
			v := m.MapSfixed64Sfixed64[k]
			baseI := i
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(v))
			i--
			dAtA[i] = 0x11
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(k))
			i--
			dAtA[i] = 0x9
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.MapSfixed32Sfixed32) > 0 {
		for k := range m.MapSfixed32Sfixed32 {
			v := m.MapSfixed32Sfixed32[k]
			baseI := i
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(v))
			i--
			dAtA[i] = 0x15
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.MapFixed64Fixed64) > 0 {
		for k := range m.MapFixed64Fixed64 {
			v := m.MapFixed64Fixed64[k]
			baseI := i
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(v))
			i--
			dAtA[i] = 0x11
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(k))
			i--
			dAtA[i] = 0x9
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.MapFixed32Fixed32) > 0 {
		for k := range m.MapFixed32Fixed32 {
			v := m.MapFixed32Fixed32[k]
			baseI := i
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(v))
			i--
			dAtA[i] = 0x15
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.MapSint64Sint64) > 0 {
		for k := range m.MapSint64Sint64 {
			v := m.MapSint64Sint64[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64((uint64(v)<<1)^uint64((v>>63))))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64((uint64(k)<<1)^uint64((k>>63))))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.MapSint32Sint32) > 0 {
		for k := range m.MapSint32Sint32 {
			v := m.MapSint32Sint32[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64((uint32(v)<<1)^uint32((v>>31))))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64((uint32(k)<<1)^uint32((k>>31))))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.MapUint64Uint64) > 0 {
		for k := range m.MapUint64Uint64 {
			v := m.MapUint64Uint64[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.MapUint32Uint32) > 0 {
		for k := range m.MapUint32Uint32 {
			v := m.MapUint32Uint32[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.MapInt64Int64) > 0 {
		for k := range m.MapInt64Int64 {
			v := m.MapInt64Int64[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.MapInt32Int32) > 0 {
		for k := range m.MapInt32Int32 {
			v := m.MapInt32Int32[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.RepeatedCord) > 0 {
		for iNdEx := len(m.RepeatedCord) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedCord[iNdEx])
			copy(dAtA[i:], m.RepeatedCord[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedCord[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.RepeatedStringPiece) > 0 {
		for iNdEx := len(m.RepeatedStringPiece) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedStringPiece[iNdEx])
			copy(dAtA[i:], m.RepeatedStringPiece[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedStringPiece[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.RepeatedForeignEnum) > 0 {
		for iNdEx := len(m.RepeatedForeignEnum) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedForeignEnum[iNdEx]))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xa0
		}
	}
	if len(m.RepeatedNestedEnum) > 0 {
		for iNdEx := len(m.RepeatedNestedEnum) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedNestedEnum[iNdEx]))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x98
		}
	}
	if len(m.RepeatedForeignMessage) > 0 {
		for iNdEx := len(m.RepeatedForeignMessage) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.RepeatedForeignMessage[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.RepeatedNestedMessage) > 0 {
		for iNdEx := len(m.RepeatedNestedMessage) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.RepeatedNestedMessage[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.RepeatedBytes) > 0 {
		for iNdEx := len(m.RepeatedBytes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedBytes[iNdEx])
			copy(dAtA[i:], m.RepeatedBytes[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedBytes[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.RepeatedString) > 0 {
		for iNdEx := len(m.RepeatedString) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedString[iNdEx])
			copy(dAtA[i:], m.RepeatedString[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedString[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.RepeatedBool) > 0 {
		for iNdEx := len(m.RepeatedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.RepeatedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd8
		}
	}
	if len(m.RepeatedDouble) > 0 {
		for iNdEx := len(m.RepeatedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f23 := math.Float64bits(float64(m.RepeatedDouble[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f23))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd1
		}
	}
	if len(m.RepeatedFloat) > 0 {
		for iNdEx := len(m.RepeatedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f24 := math.Float32bits(float32(m.RepeatedFloat[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f24))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xcd
		}
	}
	if len(m.RepeatedSfixed64) > 0 {
		for iNdEx := len(m.RepeatedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RepeatedSfixed64[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc1
		}
	}
	if len(m.RepeatedSfixed32) > 0 {
		for iNdEx := len(m.RepeatedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RepeatedSfixed32[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xbd
		}
	}
	if len(m.RepeatedFixed64) > 0 {
		for iNdEx := len(m.RepeatedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RepeatedFixed64[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb1
		}
	}
	if len(m.RepeatedFixed32) > 0 {
		for iNdEx := len(m.RepeatedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RepeatedFixed32[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xad
		}
	}
	if len(m.RepeatedSint64) > 0 {
		for iNdEx := len(m.RepeatedSint64) - 1; iNdEx >= 0; iNdEx-- {
			x25 := (uint64(m.RepeatedSint64[iNdEx]) << 1) ^ uint64((m.RepeatedSint64[iNdEx] >> 63))
			i = encodeVarint(dAtA, i, uint64(x25))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa0
		}
	}
	if len(m.RepeatedSint32) > 0 {
		for iNdEx := len(m.RepeatedSint32) - 1; iNdEx >= 0; iNdEx-- {
			x26 := (uint32(m.RepeatedSint32[iNdEx]) << 1) ^ uint32((m.RepeatedSint32[iNdEx] >> 31))
			i = encodeVarint(dAtA, i, uint64(x26))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x98
		}
	}
	if len(m.RepeatedUint64) > 0 {
		for iNdEx := len(m.RepeatedUint64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedUint64[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x90
		}
	}
	if len(m.RepeatedUint32) > 0 {
		for iNdEx := len(m.RepeatedUint32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedUint32[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x88
		}
	}
	if len(m.RepeatedInt64) > 0 {
		for iNdEx := len(m.RepeatedInt64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedInt64[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x80
		}
	}
	if len(m.RepeatedInt32) > 0 {
		for iNdEx := len(m.RepeatedInt32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedInt32[iNdEx]))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf8
		}
	}
	if m.RecursiveMessage != nil {
		size, err := m.RecursiveMessage.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.OptionalCord != nil {
		i -= len(*m.OptionalCord)
		copy(dAtA[i:], *m.OptionalCord)
		i = encodeVarint(dAtA, i, uint64(len(*m.OptionalCord)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.OptionalStringPiece != nil {
		i -= len(*m.OptionalStringPiece)
		copy(dAtA[i:], *m.OptionalStringPiece)
		i = encodeVarint(dAtA, i, uint64(len(*m.OptionalStringPiece)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.OptionalForeignEnum != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalForeignEnum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.OptionalNestedEnum != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalNestedEnum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.OptionalForeignMessage != nil {
		size, err := m.OptionalForeignMessage.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.OptionalNestedMessage != nil {
		size, err := m.OptionalNestedMessage.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.OptionalBytes != nil {
		i -= len(m.OptionalBytes)
		copy(dAtA[i:], m.OptionalBytes)
		i = encodeVarint(dAtA, i, uint64(len(m.OptionalBytes)))
		i--
		dAtA[i] = 0x7a
	}
	if m.OptionalString != nil {
		i -= len(*m.OptionalString)
		copy(dAtA[i:], *m.OptionalString)
		i = encodeVarint(dAtA, i, uint64(len(*m.OptionalString)))
		i--
		dAtA[i] = 0x72
	}
	if m.OptionalBool != nil {
		i--
		if *m.OptionalBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.OptionalDouble != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.OptionalDouble))))
		i--
		dAtA[i] = 0x61
	}
	if m.OptionalFloat != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.OptionalFloat))))
		i--
		dAtA[i] = 0x5d
	}
	if m.OptionalSfixed64 != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.OptionalSfixed64))
		i--
		dAtA[i] = 0x51
	}
	if m.OptionalSfixed32 != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.OptionalSfixed32))
		i--
		dAtA[i] = 0x4d
	}
	if m.OptionalFixed64 != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.OptionalFixed64))
		i--
		dAtA[i] = 0x41
	}
	if m.OptionalFixed32 != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.OptionalFixed32))
		i--
		dAtA[i] = 0x3d
	}
	if m.OptionalSint64 != nil {
		i = encodeVarint(dAtA, i, uint64((uint64(*m.OptionalSint64)<<1)^uint64((*m.OptionalSint64>>63))))
		i--
		dAtA[i] = 0x30
	}
	if m.OptionalSint32 != nil {
		i = encodeVarint(dAtA, i, uint64((uint32(*m.OptionalSint32)<<1)^uint32((*m.OptionalSint32>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.OptionalUint64 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalUint64))
		i--
		dAtA[i] = 0x20
	}
	if m.OptionalUint32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalUint32))
		i--
		dAtA[i] = 0x18
	}
	if m.OptionalInt64 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalInt64))
		i--
		dAtA[i] = 0x10
	}
	if m.OptionalInt32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalInt32))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto2_OneofUint32) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofUint32) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofUint32))
	i--
	dAtA[i] = 0x6
	i--
	dAtA[i] = 0xf8
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofNestedMessage) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofNestedMessage) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OneofNestedMessage != nil {
		size, err := m.OneofNestedMessage.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofString) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofString) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.OneofString)
	copy(dAtA[i:], m.OneofString)
	i = encodeVarint(dAtA, i, uint64(len(m.OneofString)))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0x8a
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofBytes) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofBytes) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.OneofBytes)
	copy(dAtA[i:], m.OneofBytes)
	i = encodeVarint(dAtA, i, uint64(len(m.OneofBytes)))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0x92
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofBool) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofBool) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.OneofBool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0x98
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofUint64) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofUint64) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofUint64))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xa0
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofFloat) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofFloat) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.OneofFloat))))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xad
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofDouble) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofDouble) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OneofDouble))))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xb1
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto2_OneofEnum) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *TestAllTypesProto2_OneofEnum) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofEnum))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xb8
	return len(dAtA) - i, nil
}
func (m *ForeignMessageProto2) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignMessageProto2) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *ForeignMessageProto2) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.C != nil {
		i = encodeVarint(dAtA, i, uint64(*m.C))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnknownToTestAllTypes_OptionalGroup) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnknownToTestAllTypes_OptionalGroup) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *UnknownToTestAllTypes_OptionalGroup) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.A != nil {
		i = encodeVarint(dAtA, i, uint64(*m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnknownToTestAllTypes) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnknownToTestAllTypes) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *UnknownToTestAllTypes) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.RepeatedInt32) > 0 {
		for iNdEx := len(m.RepeatedInt32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.RepeatedInt32[iNdEx]))
			i--
			dAtA[i] = 0x3f
			i--
			dAtA[i] = 0x98
		}
	}
	if m.OptionalBool != nil {
		i--
		if *m.OptionalBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xf0
	}
	if m.Optionalgroup != nil {
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xe4
		size, err := m.Optionalgroup.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xe3
	}
	if m.NestedMessage != nil {
		size, err := m.NestedMessage.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xda
	}
	if m.OptionalString != nil {
		i -= len(*m.OptionalString)
		copy(dAtA[i:], *m.OptionalString)
		i = encodeVarint(dAtA, i, uint64(len(*m.OptionalString)))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xd2
	}
	if m.OptionalInt32 != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptionalInt32))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc8
	}
	return len(dAtA) - i, nil
}

func (m *NullHypothesisProto2) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullHypothesisProto2) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *NullHypothesisProto2) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	return len(dAtA) - i, nil
}

func (m *EnumOnlyProto2) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumOnlyProto2) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *EnumOnlyProto2) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	return len(dAtA) - i, nil
}

func (m *OneStringProto2) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OneStringProto2) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *OneStringProto2) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Data != nil {
		i -= len(*m.Data)
		copy(dAtA[i:], *m.Data)
		i = encodeVarint(dAtA, i, uint64(len(*m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto2_NestedMessage) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A != nil {
		n += 1 + sov(uint64(*m.A))
	}
	if m.Corecursive != nil {
		l = m.Corecursive.SizeVT()
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *TestAllTypesProto2_Data) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupInt32 != nil {
		n += 2 + sov(uint64(*m.GroupInt32))
	}
	if m.GroupUint32 != nil {
		n += 2 + sov(uint64(*m.GroupUint32))
	}
	n += len(m.unknownFields)
	return n
}

func (m *TestAllTypesProto2_MessageSetCorrect) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += len(m.unknownFields)
	return n
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension1) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Str != nil {
		l = len(*m.Str)
		n += 2 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *TestAllTypesProto2_MessageSetCorrectExtension2) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.I != nil {
		n += 1 + sov(uint64(*m.I))
	}
	n += len(m.unknownFields)
	return n
}

func (m *TestAllTypesProto2) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionalInt32 != nil {
		n += 1 + sov(uint64(*m.OptionalInt32))
	}
	if m.OptionalInt64 != nil {
		n += 1 + sov(uint64(*m.OptionalInt64))
	}
	if m.OptionalUint32 != nil {
		n += 1 + sov(uint64(*m.OptionalUint32))
	}
	if m.OptionalUint64 != nil {
		n += 1 + sov(uint64(*m.OptionalUint64))
	}
	if m.OptionalSint32 != nil {
		n += 1 + soz(uint64(*m.OptionalSint32))
	}
	if m.OptionalSint64 != nil {
		n += 1 + soz(uint64(*m.OptionalSint64))
	}
	if m.OptionalFixed32 != nil {
		n += 5
	}
	if m.OptionalFixed64 != nil {
		n += 9
	}
	if m.OptionalSfixed32 != nil {
		n += 5
	}
	if m.OptionalSfixed64 != nil {
		n += 9
	}
	if m.OptionalFloat != nil {
		n += 5
	}
	if m.OptionalDouble != nil {
		n += 9
	}
	if m.OptionalBool != nil {
		n += 2
	}
	if m.OptionalString != nil {
		l = len(*m.OptionalString)
		n += 1 + l + sov(uint64(l))
	}
	if m.OptionalBytes != nil {
		l = len(m.OptionalBytes)
		n += 1 + l + sov(uint64(l))
	}
	if m.OptionalNestedMessage != nil {
		l = m.OptionalNestedMessage.SizeVT()
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalForeignMessage != nil {
		l = m.OptionalForeignMessage.SizeVT()
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalNestedEnum != nil {
		n += 2 + sov(uint64(*m.OptionalNestedEnum))
	}
	if m.OptionalForeignEnum != nil {
		n += 2 + sov(uint64(*m.OptionalForeignEnum))
	}
	if m.OptionalStringPiece != nil {
		l = len(*m.OptionalStringPiece)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalCord != nil {
		l = len(*m.OptionalCord)
		n += 2 + l + sov(uint64(l))
	}
	if m.RecursiveMessage != nil {
		l = m.RecursiveMessage.SizeVT()
		n += 2 + l + sov(uint64(l))
	}
	if len(m.RepeatedInt32) > 0 {
		for _, e := range m.RepeatedInt32 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.RepeatedInt64) > 0 {
		for _, e := range m.RepeatedInt64 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.RepeatedUint32) > 0 {
		for _, e := range m.RepeatedUint32 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.RepeatedUint64) > 0 {
		for _, e := range m.RepeatedUint64 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.RepeatedSint32) > 0 {
		for _, e := range m.RepeatedSint32 {
			n += 2 + soz(uint64(e))
		}
	}
	if len(m.RepeatedSint64) > 0 {
		for _, e := range m.RepeatedSint64 {
			n += 2 + soz(uint64(e))
		}
	}
	if len(m.RepeatedFixed32) > 0 {
		n += 6 * len(m.RepeatedFixed32)
	}
	if len(m.RepeatedFixed64) > 0 {
		n += 10 * len(m.RepeatedFixed64)
	}
	if len(m.RepeatedSfixed32) > 0 {
		n += 6 * len(m.RepeatedSfixed32)
	}
	if len(m.RepeatedSfixed64) > 0 {
		n += 10 * len(m.RepeatedSfixed64)
	}
	if len(m.RepeatedFloat) > 0 {
		n += 6 * len(m.RepeatedFloat)
	}
	if len(m.RepeatedDouble) > 0 {
		n += 10 * len(m.RepeatedDouble)
	}
	if len(m.RepeatedBool) > 0 {
		n += 3 * len(m.RepeatedBool)
	}
	if len(m.RepeatedString) > 0 {
		for _, s := range m.RepeatedString {
			l = len(s)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedBytes) > 0 {
		for _, b := range m.RepeatedBytes {
			l = len(b)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedNestedMessage) > 0 {
		for _, e := range m.RepeatedNestedMessage {
			l = e.SizeVT()
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedForeignMessage) > 0 {
		for _, e := range m.RepeatedForeignMessage {
			l = e.SizeVT()
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedNestedEnum) > 0 {
		for _, e := range m.RepeatedNestedEnum {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.RepeatedForeignEnum) > 0 {
		for _, e := range m.RepeatedForeignEnum {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.RepeatedStringPiece) > 0 {
		for _, s := range m.RepeatedStringPiece {
			l = len(s)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedCord) > 0 {
		for _, s := range m.RepeatedCord {
			l = len(s)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.MapInt32Int32) > 0 {
		for k, v := range m.MapInt32Int32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt64Int64) > 0 {
		for k, v := range m.MapInt64Int64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapUint32Uint32) > 0 {
		for k, v := range m.MapUint32Uint32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapUint64Uint64) > 0 {
		for k, v := range m.MapUint64Uint64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapSint32Sint32) > 0 {
		for k, v := range m.MapSint32Sint32 {
			_ = k
			_ = v
			mapEntrySize := 1 + soz(uint64(k)) + 1 + soz(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapSint64Sint64) > 0 {
		for k, v := range m.MapSint64Sint64 {
			_ = k
			_ = v
			mapEntrySize := 1 + soz(uint64(k)) + 1 + soz(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapFixed32Fixed32) > 0 {
		for k, v := range m.MapFixed32Fixed32 {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapFixed64Fixed64) > 0 {
		for k, v := range m.MapFixed64Fixed64 {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapSfixed32Sfixed32) > 0 {
		for k, v := range m.MapSfixed32Sfixed32 {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapSfixed64Sfixed64) > 0 {
		for k, v := range m.MapSfixed64Sfixed64 {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt32Float) > 0 {
		for k, v := range m.MapInt32Float {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + 4
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt32Double) > 0 {
		for k, v := range m.MapInt32Double {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + 8
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapBoolBool) > 0 {
		for k, v := range m.MapBoolBool {
			_ = k
			_ = v
			mapEntrySize := 1 + 1 + 1 + 1
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringString) > 0 {
		for k, v := range m.MapStringString {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + 1 + len(v) + sov(uint64(len(v)))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringBytes) > 0 {
		for k, v := range m.MapStringBytes {
			_ = k
			_ = v
			l = 1 + len(v) + sov(uint64(len(v)))
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + l
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringNestedMessage) > 0 {
		for k, v := range m.MapStringNestedMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.SizeVT()
			}
			l += 1 + sov(uint64(l))
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + l
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringForeignMessage) > 0 {
		for k, v := range m.MapStringForeignMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.SizeVT()
			}
			l += 1 + sov(uint64(l))
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + l
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringNestedEnum) > 0 {
		for k, v := range m.MapStringNestedEnum {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringForeignEnum) > 0 {
		for k, v := range m.MapStringForeignEnum {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.PackedInt32) > 0 {
		l = 0
		for _, e := range m.PackedInt32 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedInt64) > 0 {
		l = 0
		for _, e := range m.PackedInt64 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedUint32) > 0 {
		l = 0
		for _, e := range m.PackedUint32 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedUint64) > 0 {
		l = 0
		for _, e := range m.PackedUint64 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedSint32) > 0 {
		l = 0
		for _, e := range m.PackedSint32 {
			l += soz(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedSint64) > 0 {
		l = 0
		for _, e := range m.PackedSint64 {
			l += soz(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedFixed32) > 0 {
		n += 2 + sov(uint64(len(m.PackedFixed32)*4)) + len(m.PackedFixed32)*4
	}
	if len(m.PackedFixed64) > 0 {
		n += 2 + sov(uint64(len(m.PackedFixed64)*8)) + len(m.PackedFixed64)*8
	}
	if len(m.PackedSfixed32) > 0 {
		n += 2 + sov(uint64(len(m.PackedSfixed32)*4)) + len(m.PackedSfixed32)*4
	}
	if len(m.PackedSfixed64) > 0 {
		n += 2 + sov(uint64(len(m.PackedSfixed64)*8)) + len(m.PackedSfixed64)*8
	}
	if len(m.PackedFloat) > 0 {
		n += 2 + sov(uint64(len(m.PackedFloat)*4)) + len(m.PackedFloat)*4
	}
	if len(m.PackedDouble) > 0 {
		n += 2 + sov(uint64(len(m.PackedDouble)*8)) + len(m.PackedDouble)*8
	}
	if len(m.PackedBool) > 0 {
		n += 2 + sov(uint64(len(m.PackedBool))) + len(m.PackedBool)*1
	}
	if len(m.PackedNestedEnum) > 0 {
		l = 0
		for _, e := range m.PackedNestedEnum {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.UnpackedInt32) > 0 {
		for _, e := range m.UnpackedInt32 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.UnpackedInt64) > 0 {
		for _, e := range m.UnpackedInt64 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.UnpackedUint32) > 0 {
		for _, e := range m.UnpackedUint32 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.UnpackedUint64) > 0 {
		for _, e := range m.UnpackedUint64 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.UnpackedSint32) > 0 {
		for _, e := range m.UnpackedSint32 {
			n += 2 + soz(uint64(e))
		}
	}
	if len(m.UnpackedSint64) > 0 {
		for _, e := range m.UnpackedSint64 {
			n += 2 + soz(uint64(e))
		}
	}
	if len(m.UnpackedFixed32) > 0 {
		n += 6 * len(m.UnpackedFixed32)
	}
	if len(m.UnpackedFixed64) > 0 {
		n += 10 * len(m.UnpackedFixed64)
	}
	if len(m.UnpackedSfixed32) > 0 {
		n += 6 * len(m.UnpackedSfixed32)
	}
	if len(m.UnpackedSfixed64) > 0 {
		n += 10 * len(m.UnpackedSfixed64)
	}
	if len(m.UnpackedFloat) > 0 {
		n += 6 * len(m.UnpackedFloat)
	}
	if len(m.UnpackedDouble) > 0 {
		n += 10 * len(m.UnpackedDouble)
	}
	if len(m.UnpackedBool) > 0 {
		n += 3 * len(m.UnpackedBool)
	}
	if len(m.UnpackedNestedEnum) > 0 {
		for _, e := range m.UnpackedNestedEnum {
			n += 2 + sov(uint64(e))
		}
	}
	if vtmsg, ok := m.OneofField.(interface{ SizeVT() int }); ok {
		n += vtmsg.SizeVT()
	}
	if m.Data != nil {
		l = m.Data.SizeVT()
		n += l + 4
	}
	if m.DefaultInt32 != nil {
		n += 2 + sov(uint64(*m.DefaultInt32))
	}
	if m.DefaultInt64 != nil {
		n += 2 + sov(uint64(*m.DefaultInt64))
	}
	if m.DefaultUint32 != nil {
		n += 2 + sov(uint64(*m.DefaultUint32))
	}
	if m.DefaultUint64 != nil {
		n += 2 + sov(uint64(*m.DefaultUint64))
	}
	if m.DefaultSint32 != nil {
		n += 2 + soz(uint64(*m.DefaultSint32))
	}
	if m.DefaultSint64 != nil {
		n += 2 + soz(uint64(*m.DefaultSint64))
	}
	if m.DefaultFixed32 != nil {
		n += 6
	}
	if m.DefaultFixed64 != nil {
		n += 10
	}
	if m.DefaultSfixed32 != nil {
		n += 6
	}
	if m.DefaultSfixed64 != nil {
		n += 10
	}
	if m.DefaultFloat != nil {
		n += 6
	}
	if m.DefaultDouble != nil {
		n += 10
	}
	if m.DefaultBool != nil {
		n += 3
	}
	if m.DefaultString != nil {
		l = len(*m.DefaultString)
		n += 2 + l + sov(uint64(l))
	}
	if m.DefaultBytes != nil {
		l = len(m.DefaultBytes)
		n += 2 + l + sov(uint64(l))
	}
	if m.Fieldname1 != nil {
		n += 2 + sov(uint64(*m.Fieldname1))
	}
	if m.FieldName2 != nil {
		n += 2 + sov(uint64(*m.FieldName2))
	}
	if m.XFieldName3 != nil {
		n += 2 + sov(uint64(*m.XFieldName3))
	}
	if m.Field_Name4_ != nil {
		n += 2 + sov(uint64(*m.Field_Name4_))
	}
	if m.Field0Name5 != nil {
		n += 2 + sov(uint64(*m.Field0Name5))
	}
	if m.Field_0Name6 != nil {
		n += 2 + sov(uint64(*m.Field_0Name6))
	}
	if m.FieldName7 != nil {
		n += 2 + sov(uint64(*m.FieldName7))
	}
	if m.FieldName8 != nil {
		n += 2 + sov(uint64(*m.FieldName8))
	}
	if m.Field_Name9 != nil {
		n += 2 + sov(uint64(*m.Field_Name9))
	}
	if m.Field_Name10 != nil {
		n += 2 + sov(uint64(*m.Field_Name10))
	}
	if m.FIELD_NAME11 != nil {
		n += 2 + sov(uint64(*m.FIELD_NAME11))
	}
	if m.FIELDName12 != nil {
		n += 2 + sov(uint64(*m.FIELDName12))
	}
	if m.XFieldName13 != nil {
		n += 2 + sov(uint64(*m.XFieldName13))
	}
	if m.X_FieldName14 != nil {
		n += 2 + sov(uint64(*m.X_FieldName14))
	}
	if m.Field_Name15 != nil {
		n += 2 + sov(uint64(*m.Field_Name15))
	}
	if m.Field__Name16 != nil {
		n += 2 + sov(uint64(*m.Field__Name16))
	}
	if m.FieldName17__ != nil {
		n += 2 + sov(uint64(*m.FieldName17__))
	}
	if m.FieldName18__ != nil {
		n += 2 + sov(uint64(*m.FieldName18__))
	}
	n += len(m.unknownFields)
	return n
}

func (m *TestAllTypesProto2_OneofUint32) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sov(uint64(m.OneofUint32))
	return n
}
func (m *TestAllTypesProto2_OneofNestedMessage) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OneofNestedMessage != nil {
		l = m.OneofNestedMessage.SizeVT()
		n += 2 + l + sov(uint64(l))
	}
	return n
}
func (m *TestAllTypesProto2_OneofString) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OneofString)
	n += 2 + l + sov(uint64(l))
	return n
}
func (m *TestAllTypesProto2_OneofBytes) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OneofBytes)
	n += 2 + l + sov(uint64(l))
	return n
}
func (m *TestAllTypesProto2_OneofBool) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *TestAllTypesProto2_OneofUint64) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sov(uint64(m.OneofUint64))
	return n
}
func (m *TestAllTypesProto2_OneofFloat) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 6
	return n
}
func (m *TestAllTypesProto2_OneofDouble) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 10
	return n
}
func (m *TestAllTypesProto2_OneofEnum) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sov(uint64(m.OneofEnum))
	return n
}
func (m *ForeignMessageProto2) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.C != nil {
		n += 1 + sov(uint64(*m.C))
	}
	n += len(m.unknownFields)
	return n
}

func (m *UnknownToTestAllTypes_OptionalGroup) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A != nil {
		n += 1 + sov(uint64(*m.A))
	}
	n += len(m.unknownFields)
	return n
}

func (m *UnknownToTestAllTypes) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionalInt32 != nil {
		n += 2 + sov(uint64(*m.OptionalInt32))
	}
	if m.OptionalString != nil {
		l = len(*m.OptionalString)
		n += 2 + l + sov(uint64(l))
	}
	if m.NestedMessage != nil {
		l = m.NestedMessage.SizeVT()
		n += 2 + l + sov(uint64(l))
	}
	if m.Optionalgroup != nil {
		l = m.Optionalgroup.SizeVT()
		n += l + 4
	}
	if m.OptionalBool != nil {
		n += 3
	}
	if len(m.RepeatedInt32) > 0 {
		for _, e := range m.RepeatedInt32 {
			n += 2 + sov(uint64(e))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *NullHypothesisProto2) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += len(m.unknownFields)
	return n
}

func (m *EnumOnlyProto2) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += len(m.unknownFields)
	return n
}

func (m *OneStringProto2) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = len(*m.Data)
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func soz(x uint64) (n int) {
	return sov(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TestAllTypesProto2_NestedMessage) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestAllTypesProto2_NestedMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestAllTypesProto2_NestedMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.A = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corecursive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Corecursive == nil {
				m.Corecursive = &TestAllTypesProto2{}
			}
			if err := m.Corecursive.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestAllTypesProto2_Data) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestAllTypesProto2_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestAllTypesProto2_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 202:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupInt32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GroupInt32 = &v
		case 203:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupUint32", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GroupUint32 = &v
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestAllTypesProto2_MessageSetCorrect) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestAllTypesProto2_MessageSetCorrect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestAllTypesProto2_MessageSetCorrect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			if (fieldNum >= 4) && (fieldNum < 2147483647) {
				err = proto.UnmarshalOptions{AllowPartial: true}.Unmarshal(dAtA[iNdEx:iNdEx+skippy], m)
				if err != nil {
					return err
				}
				iNdEx += skippy
			} else {
				m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestAllTypesProto2_MessageSetCorrectExtension1) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestAllTypesProto2_MessageSetCorrectExtension1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestAllTypesProto2_MessageSetCorrectExtension1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Str = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestAllTypesProto2_MessageSetCorrectExtension2) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestAllTypesProto2_MessageSetCorrectExtension2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestAllTypesProto2_MessageSetCorrectExtension2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.I = &v
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestAllTypesProto2) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestAllTypesProto2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestAllTypesProto2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalInt32 = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt64", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalInt64 = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint32", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalUint32 = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalUint64 = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSint32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OptionalSint32 = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.OptionalSint64 = &v2
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFixed32", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.OptionalFixed32 = &v
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFixed64", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OptionalFixed64 = &v
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSfixed32", wireType)
			}
			var v int32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.OptionalSfixed32 = &v
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSfixed64", wireType)
			}
			var v int64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OptionalSfixed64 = &v
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.OptionalFloat = &v2
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.OptionalDouble = &v2
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalBool = &b
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OptionalString = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalBytes = append(m.OptionalBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.OptionalBytes == nil {
				m.OptionalBytes = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalNestedMessage == nil {
				m.OptionalNestedMessage = &TestAllTypesProto2_NestedMessage{}
			}
			if err := m.OptionalNestedMessage.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalForeignMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalForeignMessage == nil {
				m.OptionalForeignMessage = &ForeignMessageProto2{}
			}
			if err := m.OptionalForeignMessage.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalNestedEnum", wireType)
			}
			var v TestAllTypesProto2_NestedEnum
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= TestAllTypesProto2_NestedEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalNestedEnum = &v
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalForeignEnum", wireType)
			}
			var v ForeignEnumProto2
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ForeignEnumProto2(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalForeignEnum = &v
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalStringPiece", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OptionalStringPiece = &s
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalCord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OptionalCord = &s
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecursiveMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecursiveMessage == nil {
				m.RecursiveMessage = &TestAllTypesProto2{}
			}
			if err := m.RecursiveMessage.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt32 = append(m.RepeatedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedInt32) == 0 {
					m.RepeatedInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt32 = append(m.RepeatedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt32", wireType)
			}
		case 32:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt64 = append(m.RepeatedInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedInt64) == 0 {
					m.RepeatedInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt64 = append(m.RepeatedInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt64", wireType)
			}
		case 33:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedUint32 = append(m.RepeatedUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedUint32) == 0 {
					m.RepeatedUint32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedUint32 = append(m.RepeatedUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint32", wireType)
			}
		case 34:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedUint64 = append(m.RepeatedUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedUint64) == 0 {
					m.RepeatedUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedUint64 = append(m.RepeatedUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint64", wireType)
			}
		case 35:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RepeatedSint32 = append(m.RepeatedSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedSint32) == 0 {
					m.RepeatedSint32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RepeatedSint32 = append(m.RepeatedSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSint32", wireType)
			}
		case 36:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.RepeatedSint64 = append(m.RepeatedSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedSint64) == 0 {
					m.RepeatedSint64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.RepeatedSint64 = append(m.RepeatedSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSint64", wireType)
			}
		case 37:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.RepeatedFixed32 = append(m.RepeatedFixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedFixed32) == 0 {
					m.RepeatedFixed32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.RepeatedFixed32 = append(m.RepeatedFixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFixed32", wireType)
			}
		case 38:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.RepeatedFixed64 = append(m.RepeatedFixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedFixed64) == 0 {
					m.RepeatedFixed64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.RepeatedFixed64 = append(m.RepeatedFixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFixed64", wireType)
			}
		case 39:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.RepeatedSfixed32 = append(m.RepeatedSfixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedSfixed32) == 0 {
					m.RepeatedSfixed32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.RepeatedSfixed32 = append(m.RepeatedSfixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSfixed32", wireType)
			}
		case 40:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.RepeatedSfixed64 = append(m.RepeatedSfixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedSfixed64) == 0 {
					m.RepeatedSfixed64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.RepeatedSfixed64 = append(m.RepeatedSfixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSfixed64", wireType)
			}
		case 41:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.RepeatedFloat = append(m.RepeatedFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedFloat) == 0 {
					m.RepeatedFloat = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.RepeatedFloat = append(m.RepeatedFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFloat", wireType)
			}
		case 42:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.RepeatedDouble = append(m.RepeatedDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedDouble) == 0 {
					m.RepeatedDouble = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.RepeatedDouble = append(m.RepeatedDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedDouble", wireType)
			}
		case 43:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedBool = append(m.RepeatedBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.RepeatedBool) == 0 {
					m.RepeatedBool = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedBool = append(m.RepeatedBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBool", wireType)
			}
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedString = append(m.RepeatedString, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedBytes = append(m.RepeatedBytes, make([]byte, postIndex-iNdEx))
			copy(m.RepeatedBytes[len(m.RepeatedBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedNestedMessage = append(m.RepeatedNestedMessage, &TestAllTypesProto2_NestedMessage{})
			if err := m.RepeatedNestedMessage[len(m.RepeatedNestedMessage)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedForeignMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedForeignMessage = append(m.RepeatedForeignMessage, &ForeignMessageProto2{})
			if err := m.RepeatedForeignMessage[len(m.RepeatedForeignMessage)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType == 0 {
				var v TestAllTypesProto2_NestedEnum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TestAllTypesProto2_NestedEnum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedNestedEnum = append(m.RepeatedNestedEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RepeatedNestedEnum) == 0 {
					m.RepeatedNestedEnum = make([]TestAllTypesProto2_NestedEnum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TestAllTypesProto2_NestedEnum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TestAllTypesProto2_NestedEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedNestedEnum = append(m.RepeatedNestedEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedNestedEnum", wireType)
			}
		case 52:
			if wireType == 0 {
				var v ForeignEnumProto2
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ForeignEnumProto2(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedForeignEnum = append(m.RepeatedForeignEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RepeatedForeignEnum) == 0 {
					m.RepeatedForeignEnum = make([]ForeignEnumProto2, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ForeignEnumProto2
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ForeignEnumProto2(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedForeignEnum = append(m.RepeatedForeignEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedForeignEnum", wireType)
			}
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedStringPiece", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedStringPiece = append(m.RepeatedStringPiece, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedCord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedCord = append(m.RepeatedCord, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Int32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32Int32 == nil {
				m.MapInt32Int32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32Int32[mapkey] = mapvalue
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt64Int64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt64Int64 == nil {
				m.MapInt64Int64 = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt64Int64[mapkey] = mapvalue
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapUint32Uint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapUint32Uint32 == nil {
				m.MapUint32Uint32 = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapUint32Uint32[mapkey] = mapvalue
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapUint64Uint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapUint64Uint64 == nil {
				m.MapUint64Uint64 = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapUint64Uint64[mapkey] = mapvalue
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSint32Sint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSint32Sint32 == nil {
				m.MapSint32Sint32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = int32((uint32(mapkeytemp) >> 1) ^ uint32(((mapkeytemp&1)<<31)>>31))
					mapkey = int32(mapkeytemp)
				} else if fieldNum == 2 {
					var mapvaluetemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = int32((uint32(mapvaluetemp) >> 1) ^ uint32(((mapvaluetemp&1)<<31)>>31))
					mapvalue = int32(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSint32Sint32[mapkey] = mapvalue
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSint64Sint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSint64Sint64 == nil {
				m.MapSint64Sint64 = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = (mapkeytemp >> 1) ^ uint64((int64(mapkeytemp&1)<<63)>>63)
					mapkey = int64(mapkeytemp)
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = (mapvaluetemp >> 1) ^ uint64((int64(mapvaluetemp&1)<<63)>>63)
					mapvalue = int64(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSint64Sint64[mapkey] = mapvalue
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapFixed32Fixed32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapFixed32Fixed32 == nil {
				m.MapFixed32Fixed32 = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapFixed32Fixed32[mapkey] = mapvalue
			iNdEx = postIndex
		case 63:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapFixed64Fixed64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapFixed64Fixed64 == nil {
				m.MapFixed64Fixed64 = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapFixed64Fixed64[mapkey] = mapvalue
			iNdEx = postIndex
		case 64:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSfixed32Sfixed32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSfixed32Sfixed32 == nil {
				m.MapSfixed32Sfixed32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSfixed32Sfixed32[mapkey] = mapvalue
			iNdEx = postIndex
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSfixed64Sfixed64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSfixed64Sfixed64 == nil {
				m.MapSfixed64Sfixed64 = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSfixed64Sfixed64[mapkey] = mapvalue
			iNdEx = postIndex
		case 66:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Float", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32Float == nil {
				m.MapInt32Float = make(map[int32]float32)
			}
			var mapkey int32
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32Float[mapkey] = mapvalue
			iNdEx = postIndex
		case 67:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Double", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32Double == nil {
				m.MapInt32Double = make(map[int32]float64)
			}
			var mapkey int32
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32Double[mapkey] = mapvalue
			iNdEx = postIndex
		case 68:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBoolBool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapBoolBool == nil {
				m.MapBoolBool = make(map[bool]bool)
			}
			var mapkey bool
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkey = bool(mapkeytemp != 0)
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapBoolBool[mapkey] = mapvalue
			iNdEx = postIndex
		case 69:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringString == nil {
				m.MapStringString = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringString[mapkey] = mapvalue
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringBytes == nil {
				m.MapStringBytes = make(map[string][]byte)
			}
			var mapkey string
			var mapvalue []byte
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLength
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLength
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringBytes[mapkey] = mapvalue
			iNdEx = postIndex
		case 71:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringNestedMessage == nil {
				m.MapStringNestedMessage = make(map[string]*TestAllTypesProto2_NestedMessage)
			}
			var mapkey string
			var mapvalue *TestAllTypesProto2_NestedMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TestAllTypesProto2_NestedMessage{}
					if err := mapvalue.UnmarshalVT(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringNestedMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 72:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringForeignMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringForeignMessage == nil {
				m.MapStringForeignMessage = make(map[string]*ForeignMessageProto2)
			}
			var mapkey string
			var mapvalue *ForeignMessageProto2
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ForeignMessageProto2{}
					if err := mapvalue.UnmarshalVT(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringForeignMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 73:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringNestedEnum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringNestedEnum == nil {
				m.MapStringNestedEnum = make(map[string]TestAllTypesProto2_NestedEnum)
			}
			var mapkey string
			var mapvalue TestAllTypesProto2_NestedEnum
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= TestAllTypesProto2_NestedEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringNestedEnum[mapkey] = mapvalue
			iNdEx = postIndex
		case 74:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringForeignEnum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringForeignEnum == nil {
				m.MapStringForeignEnum = make(map[string]ForeignEnumProto2)
			}
			var mapkey string
			var mapvalue ForeignEnumProto2
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= ForeignEnumProto2(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringForeignEnum[mapkey] = mapvalue
			iNdEx = postIndex
		case 75:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedInt32 = append(m.PackedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedInt32) == 0 {
					m.PackedInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedInt32 = append(m.PackedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedInt32", wireType)
			}
		case 76:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedInt64 = append(m.PackedInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedInt64) == 0 {
					m.PackedInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedInt64 = append(m.PackedInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedInt64", wireType)
			}
		case 77:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedUint32 = append(m.PackedUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedUint32) == 0 {
					m.PackedUint32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedUint32 = append(m.PackedUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedUint32", wireType)
			}
		case 78:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedUint64 = append(m.PackedUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedUint64) == 0 {
					m.PackedUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedUint64 = append(m.PackedUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedUint64", wireType)
			}
		case 79:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.PackedSint32 = append(m.PackedSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedSint32) == 0 {
					m.PackedSint32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.PackedSint32 = append(m.PackedSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedSint32", wireType)
			}
		case 80:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.PackedSint64 = append(m.PackedSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedSint64) == 0 {
					m.PackedSint64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.PackedSint64 = append(m.PackedSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedSint64", wireType)
			}
		case 81:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.PackedFixed32 = append(m.PackedFixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.PackedFixed32) == 0 {
					m.PackedFixed32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.PackedFixed32 = append(m.PackedFixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedFixed32", wireType)
			}
		case 82:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.PackedFixed64 = append(m.PackedFixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.PackedFixed64) == 0 {
					m.PackedFixed64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.PackedFixed64 = append(m.PackedFixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedFixed64", wireType)
			}
		case 83:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.PackedSfixed32 = append(m.PackedSfixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.PackedSfixed32) == 0 {
					m.PackedSfixed32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.PackedSfixed32 = append(m.PackedSfixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedSfixed32", wireType)
			}
		case 84:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.PackedSfixed64 = append(m.PackedSfixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.PackedSfixed64) == 0 {
					m.PackedSfixed64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.PackedSfixed64 = append(m.PackedSfixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedSfixed64", wireType)
			}
		case 85:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.PackedFloat = append(m.PackedFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.PackedFloat) == 0 {
					m.PackedFloat = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.PackedFloat = append(m.PackedFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedFloat", wireType)
			}
		case 86:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.PackedDouble = append(m.PackedDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.PackedDouble) == 0 {
					m.PackedDouble = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.PackedDouble = append(m.PackedDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedDouble", wireType)
			}
		case 87:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedBool = append(m.PackedBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.PackedBool) == 0 {
					m.PackedBool = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedBool = append(m.PackedBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedBool", wireType)
			}
		case 88:
			if wireType == 0 {
				var v TestAllTypesProto2_NestedEnum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TestAllTypesProto2_NestedEnum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedNestedEnum = append(m.PackedNestedEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.PackedNestedEnum) == 0 {
					m.PackedNestedEnum = make([]TestAllTypesProto2_NestedEnum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TestAllTypesProto2_NestedEnum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TestAllTypesProto2_NestedEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedNestedEnum = append(m.PackedNestedEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedNestedEnum", wireType)
			}
		case 89:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedInt32 = append(m.UnpackedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedInt32) == 0 {
					m.UnpackedInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedInt32 = append(m.UnpackedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedInt32", wireType)
			}
		case 90:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedInt64 = append(m.UnpackedInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedInt64) == 0 {
					m.UnpackedInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedInt64 = append(m.UnpackedInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedInt64", wireType)
			}
		case 91:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedUint32 = append(m.UnpackedUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedUint32) == 0 {
					m.UnpackedUint32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedUint32 = append(m.UnpackedUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedUint32", wireType)
			}
		case 92:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedUint64 = append(m.UnpackedUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedUint64) == 0 {
					m.UnpackedUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedUint64 = append(m.UnpackedUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedUint64", wireType)
			}
		case 93:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UnpackedSint32 = append(m.UnpackedSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedSint32) == 0 {
					m.UnpackedSint32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UnpackedSint32 = append(m.UnpackedSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedSint32", wireType)
			}
		case 94:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.UnpackedSint64 = append(m.UnpackedSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedSint64) == 0 {
					m.UnpackedSint64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.UnpackedSint64 = append(m.UnpackedSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedSint64", wireType)
			}
		case 95:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.UnpackedFixed32 = append(m.UnpackedFixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.UnpackedFixed32) == 0 {
					m.UnpackedFixed32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.UnpackedFixed32 = append(m.UnpackedFixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedFixed32", wireType)
			}
		case 96:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.UnpackedFixed64 = append(m.UnpackedFixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.UnpackedFixed64) == 0 {
					m.UnpackedFixed64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.UnpackedFixed64 = append(m.UnpackedFixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedFixed64", wireType)
			}
		case 97:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.UnpackedSfixed32 = append(m.UnpackedSfixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.UnpackedSfixed32) == 0 {
					m.UnpackedSfixed32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.UnpackedSfixed32 = append(m.UnpackedSfixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedSfixed32", wireType)
			}
		case 98:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.UnpackedSfixed64 = append(m.UnpackedSfixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.UnpackedSfixed64) == 0 {
					m.UnpackedSfixed64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.UnpackedSfixed64 = append(m.UnpackedSfixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedSfixed64", wireType)
			}
		case 99:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.UnpackedFloat = append(m.UnpackedFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.UnpackedFloat) == 0 {
					m.UnpackedFloat = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.UnpackedFloat = append(m.UnpackedFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedFloat", wireType)
			}
		case 100:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.UnpackedDouble = append(m.UnpackedDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.UnpackedDouble) == 0 {
					m.UnpackedDouble = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.UnpackedDouble = append(m.UnpackedDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedDouble", wireType)
			}
		case 101:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedBool = append(m.UnpackedBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.UnpackedBool) == 0 {
					m.UnpackedBool = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedBool = append(m.UnpackedBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedBool", wireType)
			}
		case 102:
			if wireType == 0 {
				var v TestAllTypesProto2_NestedEnum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TestAllTypesProto2_NestedEnum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedNestedEnum = append(m.UnpackedNestedEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.UnpackedNestedEnum) == 0 {
					m.UnpackedNestedEnum = make([]TestAllTypesProto2_NestedEnum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TestAllTypesProto2_NestedEnum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TestAllTypesProto2_NestedEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedNestedEnum = append(m.UnpackedNestedEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedNestedEnum", wireType)
			}
		case 111:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofUint32", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofField = &TestAllTypesProto2_OneofUint32{OneofUint32: v}
		case 112:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.OneofField.(*TestAllTypesProto2_OneofNestedMessage); ok {
				if err := oneof.OneofNestedMessage.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &TestAllTypesProto2_NestedMessage{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.OneofField = &TestAllTypesProto2_OneofNestedMessage{OneofNestedMessage: v}
			}
			iNdEx = postIndex
		case 113:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneofField = &TestAllTypesProto2_OneofString{OneofString: string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.OneofField = &TestAllTypesProto2_OneofBytes{OneofBytes: v}
			iNdEx = postIndex
		case 115:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OneofField = &TestAllTypesProto2_OneofBool{OneofBool: b}
		case 116:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofUint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofField = &TestAllTypesProto2_OneofUint64{OneofUint64: v}
		case 117:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.OneofField = &TestAllTypesProto2_OneofFloat{OneofFloat: float32(math.Float32frombits(v))}
		case 118:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OneofField = &TestAllTypesProto2_OneofDouble{OneofDouble: float64(math.Float64frombits(v))}
		case 119:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofEnum", wireType)
			}
			var v TestAllTypesProto2_NestedEnum
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= TestAllTypesProto2_NestedEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofField = &TestAllTypesProto2_OneofEnum{OneofEnum: v}
		case 201:
			if wireType != 3 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			groupStart := iNdEx
			for {
				maybeGroupEnd := iNdEx
				var groupFieldWire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					groupFieldWire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				groupWireType := int(wire & 0x7)
				if groupWireType == 4 {
					if err := m.Data.UnmarshalVT(dAtA[groupStart:maybeGroupEnd]); err != nil {
						return err
					}
					break
				}
				skippy, err := skip(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLength
				}
				iNdEx += skippy
			}
		case 241:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultInt32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultInt32 = &v
		case 242:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultInt64", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultInt64 = &v
		case 243:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultUint32", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultUint32 = &v
		case 244:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultUint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultUint64 = &v
		case 245:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSint32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DefaultSint32 = &v
		case 246:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DefaultSint64 = &v2
		case 247:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFixed32", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DefaultFixed32 = &v
		case 248:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFixed64", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DefaultFixed64 = &v
		case 249:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSfixed32", wireType)
			}
			var v int32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DefaultSfixed32 = &v
		case 250:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSfixed64", wireType)
			}
			var v int64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DefaultSfixed64 = &v
		case 251:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DefaultFloat = &v2
		case 252:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DefaultDouble = &v2
		case 253:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DefaultBool = &b
		case 254:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DefaultString = &s
			iNdEx = postIndex
		case 255:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultBytes = append(m.DefaultBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.DefaultBytes == nil {
				m.DefaultBytes = []byte{}
			}
			iNdEx = postIndex
		case 401:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fieldname1", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fieldname1 = &v
		case 402:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName2", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FieldName2 = &v
		case 403:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XFieldName3", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XFieldName3 = &v
		case 404:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_Name4_", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field_Name4_ = &v
		case 405:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field0Name5", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field0Name5 = &v
		case 406:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_0Name6", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field_0Name6 = &v
		case 407:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName7", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FieldName7 = &v
		case 408:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName8", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FieldName8 = &v
		case 409:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_Name9", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field_Name9 = &v
		case 410:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_Name10", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field_Name10 = &v
		case 411:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FIELD_NAME11", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FIELD_NAME11 = &v
		case 412:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FIELDName12", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FIELDName12 = &v
		case 413:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XFieldName13", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XFieldName13 = &v
		case 414:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X_FieldName14", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.X_FieldName14 = &v
		case 415:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_Name15", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field_Name15 = &v
		case 416:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field__Name16", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field__Name16 = &v
		case 417:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName17__", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FieldName17__ = &v
		case 418:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName18__", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FieldName18__ = &v
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			if (fieldNum >= 120) && (fieldNum < 201) {
				err = proto.UnmarshalOptions{AllowPartial: true}.Unmarshal(dAtA[iNdEx:iNdEx+skippy], m)
				if err != nil {
					return err
				}
				iNdEx += skippy
			} else {
				m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignMessageProto2) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignMessageProto2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignMessageProto2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.C = &v
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnknownToTestAllTypes_OptionalGroup) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnknownToTestAllTypes_OptionalGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnknownToTestAllTypes_OptionalGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.A = &v
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnknownToTestAllTypes) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnknownToTestAllTypes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnknownToTestAllTypes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1001:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalInt32 = &v
		case 1002:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OptionalString = &s
			iNdEx = postIndex
		case 1003:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NestedMessage == nil {
				m.NestedMessage = &ForeignMessageProto2{}
			}
			if err := m.NestedMessage.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1004:
			if wireType != 3 {
				return fmt.Errorf("proto: wrong wireType = %d for field Optionalgroup", wireType)
			}
			groupStart := iNdEx
			for {
				maybeGroupEnd := iNdEx
				var groupFieldWire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					groupFieldWire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				groupWireType := int(wire & 0x7)
				if groupWireType == 4 {
					if err := m.Optionalgroup.UnmarshalVT(dAtA[groupStart:maybeGroupEnd]); err != nil {
						return err
					}
					break
				}
				skippy, err := skip(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLength
				}
				iNdEx += skippy
			}
		case 1006:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalBool = &b
		case 1011:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt32 = append(m.RepeatedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedInt32) == 0 {
					m.RepeatedInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt32 = append(m.RepeatedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt32", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullHypothesisProto2) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullHypothesisProto2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullHypothesisProto2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumOnlyProto2) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnumOnlyProto2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnumOnlyProto2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OneStringProto2) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OneStringProto2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OneStringProto2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Data = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func skip(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLength
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroup
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLength
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLength        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflow          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroup = fmt.Errorf("proto: unexpected end of group")
)
