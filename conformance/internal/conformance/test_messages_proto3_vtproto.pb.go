// Code generated by protoc-gen-go-vtproto. DO NOT EDIT.
// protoc-gen-go-vtproto version: (devel)
// source: src/google/protobuf/test_messages_proto3.proto

package conformance

import (
	binary "encoding/binary"
	fmt "fmt"
	proto "google.golang.org/protobuf/proto"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	io "io"
	math "math"
	bits "math/bits"
)

func (m *TestAllTypesProto3_NestedMessage) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestAllTypesProto3_NestedMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestAllTypesProto3_NestedMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corecursive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Corecursive == nil {
				m.Corecursive = &TestAllTypesProto3{}
			}
			if err := m.Corecursive.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestAllTypesProto3_NestedMessage) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto3_NestedMessage) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_NestedMessage) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Corecursive != nil {
		{
			size, err := m.Corecursive.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.A != 0 {
		i = encodeVarint(dAtA, i, uint64(m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto3_NestedMessage) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A != 0 {
		n += 1 + sov(uint64(m.A))
	}
	if m.Corecursive != nil {
		l = m.Corecursive.SizeVT()
		n += 1 + l + sov(uint64(l))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestAllTypesProto3) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestAllTypesProto3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestAllTypesProto3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt32", wireType)
			}
			m.OptionalInt32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalInt32 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt64", wireType)
			}
			m.OptionalInt64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalInt64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint32", wireType)
			}
			m.OptionalUint32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalUint32 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint64", wireType)
			}
			m.OptionalUint64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalUint64 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSint32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OptionalSint32 = v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.OptionalSint64 = int64(v)
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFixed32", wireType)
			}
			m.OptionalFixed32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalFixed32 = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFixed64", wireType)
			}
			m.OptionalFixed64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalFixed64 = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSfixed32", wireType)
			}
			m.OptionalSfixed32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalSfixed32 = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSfixed64", wireType)
			}
			m.OptionalSfixed64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalSfixed64 = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.OptionalFloat = float32(math.Float32frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OptionalDouble = float64(math.Float64frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalBool = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalBytes = append(m.OptionalBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.OptionalBytes == nil {
				m.OptionalBytes = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalNestedMessage == nil {
				m.OptionalNestedMessage = &TestAllTypesProto3_NestedMessage{}
			}
			if err := m.OptionalNestedMessage.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalForeignMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalForeignMessage == nil {
				m.OptionalForeignMessage = &ForeignMessage{}
			}
			if err := m.OptionalForeignMessage.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalNestedEnum", wireType)
			}
			m.OptionalNestedEnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalNestedEnum |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalForeignEnum", wireType)
			}
			m.OptionalForeignEnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalForeignEnum |= ForeignEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalAliasedEnum", wireType)
			}
			m.OptionalAliasedEnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalAliasedEnum |= TestAllTypesProto3_AliasedEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalStringPiece", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalStringPiece = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalCord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalCord = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecursiveMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecursiveMessage == nil {
				m.RecursiveMessage = &TestAllTypesProto3{}
			}
			if err := m.RecursiveMessage.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt32 = append(m.RepeatedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedInt32) == 0 {
					m.RepeatedInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt32 = append(m.RepeatedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt32", wireType)
			}
		case 32:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt64 = append(m.RepeatedInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedInt64) == 0 {
					m.RepeatedInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt64 = append(m.RepeatedInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt64", wireType)
			}
		case 33:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedUint32 = append(m.RepeatedUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedUint32) == 0 {
					m.RepeatedUint32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedUint32 = append(m.RepeatedUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint32", wireType)
			}
		case 34:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedUint64 = append(m.RepeatedUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedUint64) == 0 {
					m.RepeatedUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedUint64 = append(m.RepeatedUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint64", wireType)
			}
		case 35:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RepeatedSint32 = append(m.RepeatedSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedSint32) == 0 {
					m.RepeatedSint32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RepeatedSint32 = append(m.RepeatedSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSint32", wireType)
			}
		case 36:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.RepeatedSint64 = append(m.RepeatedSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedSint64) == 0 {
					m.RepeatedSint64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.RepeatedSint64 = append(m.RepeatedSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSint64", wireType)
			}
		case 37:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.RepeatedFixed32 = append(m.RepeatedFixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedFixed32) == 0 {
					m.RepeatedFixed32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.RepeatedFixed32 = append(m.RepeatedFixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFixed32", wireType)
			}
		case 38:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.RepeatedFixed64 = append(m.RepeatedFixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedFixed64) == 0 {
					m.RepeatedFixed64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.RepeatedFixed64 = append(m.RepeatedFixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFixed64", wireType)
			}
		case 39:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.RepeatedSfixed32 = append(m.RepeatedSfixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedSfixed32) == 0 {
					m.RepeatedSfixed32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.RepeatedSfixed32 = append(m.RepeatedSfixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSfixed32", wireType)
			}
		case 40:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.RepeatedSfixed64 = append(m.RepeatedSfixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedSfixed64) == 0 {
					m.RepeatedSfixed64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.RepeatedSfixed64 = append(m.RepeatedSfixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSfixed64", wireType)
			}
		case 41:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.RepeatedFloat = append(m.RepeatedFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedFloat) == 0 {
					m.RepeatedFloat = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.RepeatedFloat = append(m.RepeatedFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFloat", wireType)
			}
		case 42:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.RepeatedDouble = append(m.RepeatedDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedDouble) == 0 {
					m.RepeatedDouble = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.RepeatedDouble = append(m.RepeatedDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedDouble", wireType)
			}
		case 43:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedBool = append(m.RepeatedBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.RepeatedBool) == 0 {
					m.RepeatedBool = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedBool = append(m.RepeatedBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBool", wireType)
			}
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedString = append(m.RepeatedString, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedBytes = append(m.RepeatedBytes, make([]byte, postIndex-iNdEx))
			copy(m.RepeatedBytes[len(m.RepeatedBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedNestedMessage = append(m.RepeatedNestedMessage, &TestAllTypesProto3_NestedMessage{})
			if err := m.RepeatedNestedMessage[len(m.RepeatedNestedMessage)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedForeignMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedForeignMessage = append(m.RepeatedForeignMessage, &ForeignMessage{})
			if err := m.RepeatedForeignMessage[len(m.RepeatedForeignMessage)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType == 0 {
				var v TestAllTypesProto3_NestedEnum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedNestedEnum = append(m.RepeatedNestedEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RepeatedNestedEnum) == 0 {
					m.RepeatedNestedEnum = make([]TestAllTypesProto3_NestedEnum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TestAllTypesProto3_NestedEnum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedNestedEnum = append(m.RepeatedNestedEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedNestedEnum", wireType)
			}
		case 52:
			if wireType == 0 {
				var v ForeignEnum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ForeignEnum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedForeignEnum = append(m.RepeatedForeignEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RepeatedForeignEnum) == 0 {
					m.RepeatedForeignEnum = make([]ForeignEnum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ForeignEnum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ForeignEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedForeignEnum = append(m.RepeatedForeignEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedForeignEnum", wireType)
			}
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedStringPiece", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedStringPiece = append(m.RepeatedStringPiece, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedCord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedCord = append(m.RepeatedCord, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 75:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedInt32 = append(m.PackedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedInt32) == 0 {
					m.PackedInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedInt32 = append(m.PackedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedInt32", wireType)
			}
		case 76:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedInt64 = append(m.PackedInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedInt64) == 0 {
					m.PackedInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedInt64 = append(m.PackedInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedInt64", wireType)
			}
		case 77:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedUint32 = append(m.PackedUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedUint32) == 0 {
					m.PackedUint32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedUint32 = append(m.PackedUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedUint32", wireType)
			}
		case 78:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedUint64 = append(m.PackedUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedUint64) == 0 {
					m.PackedUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedUint64 = append(m.PackedUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedUint64", wireType)
			}
		case 79:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.PackedSint32 = append(m.PackedSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedSint32) == 0 {
					m.PackedSint32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.PackedSint32 = append(m.PackedSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedSint32", wireType)
			}
		case 80:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.PackedSint64 = append(m.PackedSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedSint64) == 0 {
					m.PackedSint64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.PackedSint64 = append(m.PackedSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedSint64", wireType)
			}
		case 81:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.PackedFixed32 = append(m.PackedFixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.PackedFixed32) == 0 {
					m.PackedFixed32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.PackedFixed32 = append(m.PackedFixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedFixed32", wireType)
			}
		case 82:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.PackedFixed64 = append(m.PackedFixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.PackedFixed64) == 0 {
					m.PackedFixed64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.PackedFixed64 = append(m.PackedFixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedFixed64", wireType)
			}
		case 83:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.PackedSfixed32 = append(m.PackedSfixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.PackedSfixed32) == 0 {
					m.PackedSfixed32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.PackedSfixed32 = append(m.PackedSfixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedSfixed32", wireType)
			}
		case 84:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.PackedSfixed64 = append(m.PackedSfixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.PackedSfixed64) == 0 {
					m.PackedSfixed64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.PackedSfixed64 = append(m.PackedSfixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedSfixed64", wireType)
			}
		case 85:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.PackedFloat = append(m.PackedFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.PackedFloat) == 0 {
					m.PackedFloat = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.PackedFloat = append(m.PackedFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedFloat", wireType)
			}
		case 86:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.PackedDouble = append(m.PackedDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.PackedDouble) == 0 {
					m.PackedDouble = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.PackedDouble = append(m.PackedDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedDouble", wireType)
			}
		case 87:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedBool = append(m.PackedBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.PackedBool) == 0 {
					m.PackedBool = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedBool = append(m.PackedBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedBool", wireType)
			}
		case 88:
			if wireType == 0 {
				var v TestAllTypesProto3_NestedEnum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedNestedEnum = append(m.PackedNestedEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.PackedNestedEnum) == 0 {
					m.PackedNestedEnum = make([]TestAllTypesProto3_NestedEnum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TestAllTypesProto3_NestedEnum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedNestedEnum = append(m.PackedNestedEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedNestedEnum", wireType)
			}
		case 89:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedInt32 = append(m.UnpackedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedInt32) == 0 {
					m.UnpackedInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedInt32 = append(m.UnpackedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedInt32", wireType)
			}
		case 90:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedInt64 = append(m.UnpackedInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedInt64) == 0 {
					m.UnpackedInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedInt64 = append(m.UnpackedInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedInt64", wireType)
			}
		case 91:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedUint32 = append(m.UnpackedUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedUint32) == 0 {
					m.UnpackedUint32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedUint32 = append(m.UnpackedUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedUint32", wireType)
			}
		case 92:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedUint64 = append(m.UnpackedUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedUint64) == 0 {
					m.UnpackedUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedUint64 = append(m.UnpackedUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedUint64", wireType)
			}
		case 93:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UnpackedSint32 = append(m.UnpackedSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedSint32) == 0 {
					m.UnpackedSint32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UnpackedSint32 = append(m.UnpackedSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedSint32", wireType)
			}
		case 94:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.UnpackedSint64 = append(m.UnpackedSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedSint64) == 0 {
					m.UnpackedSint64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.UnpackedSint64 = append(m.UnpackedSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedSint64", wireType)
			}
		case 95:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.UnpackedFixed32 = append(m.UnpackedFixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.UnpackedFixed32) == 0 {
					m.UnpackedFixed32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.UnpackedFixed32 = append(m.UnpackedFixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedFixed32", wireType)
			}
		case 96:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.UnpackedFixed64 = append(m.UnpackedFixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.UnpackedFixed64) == 0 {
					m.UnpackedFixed64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.UnpackedFixed64 = append(m.UnpackedFixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedFixed64", wireType)
			}
		case 97:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.UnpackedSfixed32 = append(m.UnpackedSfixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.UnpackedSfixed32) == 0 {
					m.UnpackedSfixed32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.UnpackedSfixed32 = append(m.UnpackedSfixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedSfixed32", wireType)
			}
		case 98:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.UnpackedSfixed64 = append(m.UnpackedSfixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.UnpackedSfixed64) == 0 {
					m.UnpackedSfixed64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.UnpackedSfixed64 = append(m.UnpackedSfixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedSfixed64", wireType)
			}
		case 99:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.UnpackedFloat = append(m.UnpackedFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.UnpackedFloat) == 0 {
					m.UnpackedFloat = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.UnpackedFloat = append(m.UnpackedFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedFloat", wireType)
			}
		case 100:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.UnpackedDouble = append(m.UnpackedDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.UnpackedDouble) == 0 {
					m.UnpackedDouble = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.UnpackedDouble = append(m.UnpackedDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedDouble", wireType)
			}
		case 101:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedBool = append(m.UnpackedBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.UnpackedBool) == 0 {
					m.UnpackedBool = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedBool = append(m.UnpackedBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedBool", wireType)
			}
		case 102:
			if wireType == 0 {
				var v TestAllTypesProto3_NestedEnum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedNestedEnum = append(m.UnpackedNestedEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.UnpackedNestedEnum) == 0 {
					m.UnpackedNestedEnum = make([]TestAllTypesProto3_NestedEnum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TestAllTypesProto3_NestedEnum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedNestedEnum = append(m.UnpackedNestedEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedNestedEnum", wireType)
			}
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Int32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32Int32 == nil {
				m.MapInt32Int32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32Int32[mapkey] = mapvalue
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt64Int64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt64Int64 == nil {
				m.MapInt64Int64 = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt64Int64[mapkey] = mapvalue
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapUint32Uint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapUint32Uint32 == nil {
				m.MapUint32Uint32 = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapUint32Uint32[mapkey] = mapvalue
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapUint64Uint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapUint64Uint64 == nil {
				m.MapUint64Uint64 = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapUint64Uint64[mapkey] = mapvalue
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSint32Sint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSint32Sint32 == nil {
				m.MapSint32Sint32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = int32((uint32(mapkeytemp) >> 1) ^ uint32(((mapkeytemp&1)<<31)>>31))
					mapkey = int32(mapkeytemp)
				} else if fieldNum == 2 {
					var mapvaluetemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = int32((uint32(mapvaluetemp) >> 1) ^ uint32(((mapvaluetemp&1)<<31)>>31))
					mapvalue = int32(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSint32Sint32[mapkey] = mapvalue
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSint64Sint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSint64Sint64 == nil {
				m.MapSint64Sint64 = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = (mapkeytemp >> 1) ^ uint64((int64(mapkeytemp&1)<<63)>>63)
					mapkey = int64(mapkeytemp)
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = (mapvaluetemp >> 1) ^ uint64((int64(mapvaluetemp&1)<<63)>>63)
					mapvalue = int64(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSint64Sint64[mapkey] = mapvalue
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapFixed32Fixed32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapFixed32Fixed32 == nil {
				m.MapFixed32Fixed32 = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapFixed32Fixed32[mapkey] = mapvalue
			iNdEx = postIndex
		case 63:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapFixed64Fixed64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapFixed64Fixed64 == nil {
				m.MapFixed64Fixed64 = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapFixed64Fixed64[mapkey] = mapvalue
			iNdEx = postIndex
		case 64:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSfixed32Sfixed32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSfixed32Sfixed32 == nil {
				m.MapSfixed32Sfixed32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSfixed32Sfixed32[mapkey] = mapvalue
			iNdEx = postIndex
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSfixed64Sfixed64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSfixed64Sfixed64 == nil {
				m.MapSfixed64Sfixed64 = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSfixed64Sfixed64[mapkey] = mapvalue
			iNdEx = postIndex
		case 66:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Float", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32Float == nil {
				m.MapInt32Float = make(map[int32]float32)
			}
			var mapkey int32
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32Float[mapkey] = mapvalue
			iNdEx = postIndex
		case 67:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Double", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32Double == nil {
				m.MapInt32Double = make(map[int32]float64)
			}
			var mapkey int32
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32Double[mapkey] = mapvalue
			iNdEx = postIndex
		case 68:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBoolBool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapBoolBool == nil {
				m.MapBoolBool = make(map[bool]bool)
			}
			var mapkey bool
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkey = bool(mapkeytemp != 0)
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapBoolBool[mapkey] = mapvalue
			iNdEx = postIndex
		case 69:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringString == nil {
				m.MapStringString = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringString[mapkey] = mapvalue
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringBytes == nil {
				m.MapStringBytes = make(map[string][]byte)
			}
			var mapkey string
			var mapvalue []byte
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLength
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLength
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringBytes[mapkey] = mapvalue
			iNdEx = postIndex
		case 71:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringNestedMessage == nil {
				m.MapStringNestedMessage = make(map[string]*TestAllTypesProto3_NestedMessage)
			}
			var mapkey string
			var mapvalue *TestAllTypesProto3_NestedMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TestAllTypesProto3_NestedMessage{}
					if err := mapvalue.UnmarshalVT(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringNestedMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 72:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringForeignMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringForeignMessage == nil {
				m.MapStringForeignMessage = make(map[string]*ForeignMessage)
			}
			var mapkey string
			var mapvalue *ForeignMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ForeignMessage{}
					if err := mapvalue.UnmarshalVT(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringForeignMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 73:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringNestedEnum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringNestedEnum == nil {
				m.MapStringNestedEnum = make(map[string]TestAllTypesProto3_NestedEnum)
			}
			var mapkey string
			var mapvalue TestAllTypesProto3_NestedEnum
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringNestedEnum[mapkey] = mapvalue
			iNdEx = postIndex
		case 74:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringForeignEnum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringForeignEnum == nil {
				m.MapStringForeignEnum = make(map[string]ForeignEnum)
			}
			var mapkey string
			var mapvalue ForeignEnum
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= ForeignEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringForeignEnum[mapkey] = mapvalue
			iNdEx = postIndex
		case 111:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofUint32", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofField = &TestAllTypesProto3_OneofUint32{v}
		case 112:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.OneofField.(*TestAllTypesProto3_OneofNestedMessage); ok {
				if err := oneof.OneofNestedMessage.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &TestAllTypesProto3_NestedMessage{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.OneofField = &TestAllTypesProto3_OneofNestedMessage{v}
			}
			iNdEx = postIndex
		case 113:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneofField = &TestAllTypesProto3_OneofString{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.OneofField = &TestAllTypesProto3_OneofBytes{v}
			iNdEx = postIndex
		case 115:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OneofField = &TestAllTypesProto3_OneofBool{b}
		case 116:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofUint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofField = &TestAllTypesProto3_OneofUint64{v}
		case 117:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.OneofField = &TestAllTypesProto3_OneofFloat{float32(math.Float32frombits(v))}
		case 118:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OneofField = &TestAllTypesProto3_OneofDouble{float64(math.Float64frombits(v))}
		case 119:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofEnum", wireType)
			}
			var v TestAllTypesProto3_NestedEnum
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofField = &TestAllTypesProto3_OneofEnum{v}
		case 120:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofNullValue", wireType)
			}
			var v structpb.NullValue
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= structpb.NullValue(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofField = &TestAllTypesProto3_OneofNullValue{v}
		case 201:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBoolWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalBoolWrapper == nil {
				m.OptionalBoolWrapper = &wrapperspb.BoolValue{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalBoolWrapper); err != nil {
				return err
			}
			iNdEx = postIndex
		case 202:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt32Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalInt32Wrapper == nil {
				m.OptionalInt32Wrapper = &wrapperspb.Int32Value{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalInt32Wrapper); err != nil {
				return err
			}
			iNdEx = postIndex
		case 203:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt64Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalInt64Wrapper == nil {
				m.OptionalInt64Wrapper = &wrapperspb.Int64Value{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalInt64Wrapper); err != nil {
				return err
			}
			iNdEx = postIndex
		case 204:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint32Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalUint32Wrapper == nil {
				m.OptionalUint32Wrapper = &wrapperspb.UInt32Value{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalUint32Wrapper); err != nil {
				return err
			}
			iNdEx = postIndex
		case 205:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint64Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalUint64Wrapper == nil {
				m.OptionalUint64Wrapper = &wrapperspb.UInt64Value{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalUint64Wrapper); err != nil {
				return err
			}
			iNdEx = postIndex
		case 206:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFloatWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalFloatWrapper == nil {
				m.OptionalFloatWrapper = &wrapperspb.FloatValue{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalFloatWrapper); err != nil {
				return err
			}
			iNdEx = postIndex
		case 207:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalDoubleWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalDoubleWrapper == nil {
				m.OptionalDoubleWrapper = &wrapperspb.DoubleValue{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalDoubleWrapper); err != nil {
				return err
			}
			iNdEx = postIndex
		case 208:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalStringWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalStringWrapper == nil {
				m.OptionalStringWrapper = &wrapperspb.StringValue{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalStringWrapper); err != nil {
				return err
			}
			iNdEx = postIndex
		case 209:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBytesWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalBytesWrapper == nil {
				m.OptionalBytesWrapper = &wrapperspb.BytesValue{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalBytesWrapper); err != nil {
				return err
			}
			iNdEx = postIndex
		case 211:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBoolWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedBoolWrapper = append(m.RepeatedBoolWrapper, &wrapperspb.BoolValue{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedBoolWrapper[len(m.RepeatedBoolWrapper)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 212:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt32Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedInt32Wrapper = append(m.RepeatedInt32Wrapper, &wrapperspb.Int32Value{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedInt32Wrapper[len(m.RepeatedInt32Wrapper)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 213:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt64Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedInt64Wrapper = append(m.RepeatedInt64Wrapper, &wrapperspb.Int64Value{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedInt64Wrapper[len(m.RepeatedInt64Wrapper)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 214:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint32Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedUint32Wrapper = append(m.RepeatedUint32Wrapper, &wrapperspb.UInt32Value{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedUint32Wrapper[len(m.RepeatedUint32Wrapper)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 215:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint64Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedUint64Wrapper = append(m.RepeatedUint64Wrapper, &wrapperspb.UInt64Value{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedUint64Wrapper[len(m.RepeatedUint64Wrapper)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 216:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFloatWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedFloatWrapper = append(m.RepeatedFloatWrapper, &wrapperspb.FloatValue{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedFloatWrapper[len(m.RepeatedFloatWrapper)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 217:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedDoubleWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedDoubleWrapper = append(m.RepeatedDoubleWrapper, &wrapperspb.DoubleValue{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedDoubleWrapper[len(m.RepeatedDoubleWrapper)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 218:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedStringWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedStringWrapper = append(m.RepeatedStringWrapper, &wrapperspb.StringValue{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedStringWrapper[len(m.RepeatedStringWrapper)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 219:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBytesWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedBytesWrapper = append(m.RepeatedBytesWrapper, &wrapperspb.BytesValue{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedBytesWrapper[len(m.RepeatedBytesWrapper)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 301:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalDuration == nil {
				m.OptionalDuration = &durationpb.Duration{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalDuration); err != nil {
				return err
			}
			iNdEx = postIndex
		case 302:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalTimestamp == nil {
				m.OptionalTimestamp = &timestamppb.Timestamp{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalTimestamp); err != nil {
				return err
			}
			iNdEx = postIndex
		case 303:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFieldMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalFieldMask == nil {
				m.OptionalFieldMask = &fieldmaskpb.FieldMask{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalFieldMask); err != nil {
				return err
			}
			iNdEx = postIndex
		case 304:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalStruct", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalStruct == nil {
				m.OptionalStruct = &structpb.Struct{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalStruct); err != nil {
				return err
			}
			iNdEx = postIndex
		case 305:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalAny", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalAny == nil {
				m.OptionalAny = &anypb.Any{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalAny); err != nil {
				return err
			}
			iNdEx = postIndex
		case 306:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalValue == nil {
				m.OptionalValue = &structpb.Value{}
			}
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalValue); err != nil {
				return err
			}
			iNdEx = postIndex
		case 307:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalNullValue", wireType)
			}
			m.OptionalNullValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalNullValue |= structpb.NullValue(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 311:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedDuration = append(m.RepeatedDuration, &durationpb.Duration{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedDuration[len(m.RepeatedDuration)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 312:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedTimestamp = append(m.RepeatedTimestamp, &timestamppb.Timestamp{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedTimestamp[len(m.RepeatedTimestamp)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 313:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFieldmask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedFieldmask = append(m.RepeatedFieldmask, &fieldmaskpb.FieldMask{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedFieldmask[len(m.RepeatedFieldmask)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 324:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedStruct", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedStruct = append(m.RepeatedStruct, &structpb.Struct{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedStruct[len(m.RepeatedStruct)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 315:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedAny", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedAny = append(m.RepeatedAny, &anypb.Any{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedAny[len(m.RepeatedAny)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 316:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedValue = append(m.RepeatedValue, &structpb.Value{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedValue[len(m.RepeatedValue)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 317:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedListValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedListValue = append(m.RepeatedListValue, &structpb.ListValue{})
			if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedListValue[len(m.RepeatedListValue)-1]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 401:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fieldname1", wireType)
			}
			m.Fieldname1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fieldname1 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 402:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName2", wireType)
			}
			m.FieldName2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldName2 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 403:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XFieldName3", wireType)
			}
			m.XFieldName3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XFieldName3 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 404:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_Name4_", wireType)
			}
			m.Field_Name4_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field_Name4_ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 405:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field0Name5", wireType)
			}
			m.Field0Name5 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field0Name5 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 406:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_0Name6", wireType)
			}
			m.Field_0Name6 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field_0Name6 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 407:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName7", wireType)
			}
			m.FieldName7 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldName7 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 408:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName8", wireType)
			}
			m.FieldName8 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldName8 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 409:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_Name9", wireType)
			}
			m.Field_Name9 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field_Name9 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 410:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_Name10", wireType)
			}
			m.Field_Name10 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field_Name10 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 411:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FIELD_NAME11", wireType)
			}
			m.FIELD_NAME11 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FIELD_NAME11 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 412:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FIELDName12", wireType)
			}
			m.FIELDName12 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FIELDName12 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 413:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XFieldName13", wireType)
			}
			m.XFieldName13 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XFieldName13 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 414:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X_FieldName14", wireType)
			}
			m.X_FieldName14 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X_FieldName14 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 415:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_Name15", wireType)
			}
			m.Field_Name15 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field_Name15 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 416:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field__Name16", wireType)
			}
			m.Field__Name16 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field__Name16 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 417:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName17__", wireType)
			}
			m.FieldName17__ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldName17__ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 418:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName18__", wireType)
			}
			m.FieldName18__ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldName18__ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestAllTypesProto3) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto3) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.FieldName18__ != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FieldName18__))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x90
	}
	if m.FieldName17__ != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FieldName17__))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x88
	}
	if m.Field__Name16 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field__Name16))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x80
	}
	if m.Field_Name15 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field_Name15))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xf8
	}
	if m.X_FieldName14 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.X_FieldName14))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xf0
	}
	if m.XFieldName13 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.XFieldName13))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xe8
	}
	if m.FIELDName12 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FIELDName12))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xe0
	}
	if m.FIELD_NAME11 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FIELD_NAME11))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xd8
	}
	if m.Field_Name10 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field_Name10))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xd0
	}
	if m.Field_Name9 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field_Name9))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xc8
	}
	if m.FieldName8 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FieldName8))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xc0
	}
	if m.FieldName7 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FieldName7))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xb8
	}
	if m.Field_0Name6 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field_0Name6))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xb0
	}
	if m.Field0Name5 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field0Name5))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xa8
	}
	if m.Field_Name4_ != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field_Name4_))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xa0
	}
	if m.XFieldName3 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.XFieldName3))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x98
	}
	if m.FieldName2 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FieldName2))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x90
	}
	if m.Fieldname1 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Fieldname1))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x88
	}
	if len(m.RepeatedStruct) > 0 {
		for iNdEx := len(m.RepeatedStruct) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedStruct[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x14
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.RepeatedListValue) > 0 {
		for iNdEx := len(m.RepeatedListValue) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedListValue[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.RepeatedValue) > 0 {
		for iNdEx := len(m.RepeatedValue) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedValue[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.RepeatedAny) > 0 {
		for iNdEx := len(m.RepeatedAny) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedAny[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.RepeatedFieldmask) > 0 {
		for iNdEx := len(m.RepeatedFieldmask) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedFieldmask[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.RepeatedTimestamp) > 0 {
		for iNdEx := len(m.RepeatedTimestamp) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedTimestamp[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.RepeatedDuration) > 0 {
		for iNdEx := len(m.RepeatedDuration) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedDuration[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xba
		}
	}
	if m.OptionalNullValue != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalNullValue))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x98
	}
	if m.OptionalValue != nil {
		{
			encoded, err := proto.Marshal(m.OptionalValue)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x92
	}
	if m.OptionalAny != nil {
		{
			encoded, err := proto.Marshal(m.OptionalAny)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x8a
	}
	if m.OptionalStruct != nil {
		{
			encoded, err := proto.Marshal(m.OptionalStruct)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x82
	}
	if m.OptionalFieldMask != nil {
		{
			encoded, err := proto.Marshal(m.OptionalFieldMask)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xfa
	}
	if m.OptionalTimestamp != nil {
		{
			encoded, err := proto.Marshal(m.OptionalTimestamp)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xf2
	}
	if m.OptionalDuration != nil {
		{
			encoded, err := proto.Marshal(m.OptionalDuration)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xea
	}
	if len(m.RepeatedBytesWrapper) > 0 {
		for iNdEx := len(m.RepeatedBytesWrapper) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedBytesWrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.RepeatedStringWrapper) > 0 {
		for iNdEx := len(m.RepeatedStringWrapper) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedStringWrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.RepeatedDoubleWrapper) > 0 {
		for iNdEx := len(m.RepeatedDoubleWrapper) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedDoubleWrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.RepeatedFloatWrapper) > 0 {
		for iNdEx := len(m.RepeatedFloatWrapper) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedFloatWrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.RepeatedUint64Wrapper) > 0 {
		for iNdEx := len(m.RepeatedUint64Wrapper) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedUint64Wrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.RepeatedUint32Wrapper) > 0 {
		for iNdEx := len(m.RepeatedUint32Wrapper) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedUint32Wrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.RepeatedInt64Wrapper) > 0 {
		for iNdEx := len(m.RepeatedInt64Wrapper) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedInt64Wrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.RepeatedInt32Wrapper) > 0 {
		for iNdEx := len(m.RepeatedInt32Wrapper) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedInt32Wrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.RepeatedBoolWrapper) > 0 {
		for iNdEx := len(m.RepeatedBoolWrapper) - 1; iNdEx >= 0; iNdEx-- {
			{
				encoded, err := proto.Marshal(m.RepeatedBoolWrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.OptionalBytesWrapper != nil {
		{
			encoded, err := proto.Marshal(m.OptionalBytesWrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x8a
	}
	if m.OptionalStringWrapper != nil {
		{
			encoded, err := proto.Marshal(m.OptionalStringWrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x82
	}
	if m.OptionalDoubleWrapper != nil {
		{
			encoded, err := proto.Marshal(m.OptionalDoubleWrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xfa
	}
	if m.OptionalFloatWrapper != nil {
		{
			encoded, err := proto.Marshal(m.OptionalFloatWrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xf2
	}
	if m.OptionalUint64Wrapper != nil {
		{
			encoded, err := proto.Marshal(m.OptionalUint64Wrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xea
	}
	if m.OptionalUint32Wrapper != nil {
		{
			encoded, err := proto.Marshal(m.OptionalUint32Wrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xe2
	}
	if m.OptionalInt64Wrapper != nil {
		{
			encoded, err := proto.Marshal(m.OptionalInt64Wrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xda
	}
	if m.OptionalInt32Wrapper != nil {
		{
			encoded, err := proto.Marshal(m.OptionalInt32Wrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd2
	}
	if m.OptionalBoolWrapper != nil {
		{
			encoded, err := proto.Marshal(m.OptionalBoolWrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xca
	}
	if vtmsg, ok := m.OneofField.(vtprotoMessage); ok {
		{
			size := vtmsg.SizeVT()
			i -= size
			if _, err := vtmsg.MarshalToVT(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.UnpackedNestedEnum) > 0 {
		for iNdEx := len(m.UnpackedNestedEnum) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedNestedEnum[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xb0
		}
	}
	if len(m.UnpackedBool) > 0 {
		for iNdEx := len(m.UnpackedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.UnpackedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa8
		}
	}
	if len(m.UnpackedDouble) > 0 {
		for iNdEx := len(m.UnpackedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float64bits(float64(m.UnpackedDouble[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f1))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa1
		}
	}
	if len(m.UnpackedFloat) > 0 {
		for iNdEx := len(m.UnpackedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f2 := math.Float32bits(float32(m.UnpackedFloat[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f2))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x9d
		}
	}
	if len(m.UnpackedSfixed64) > 0 {
		for iNdEx := len(m.UnpackedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.UnpackedSfixed64[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x91
		}
	}
	if len(m.UnpackedSfixed32) > 0 {
		for iNdEx := len(m.UnpackedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.UnpackedSfixed32[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x8d
		}
	}
	if len(m.UnpackedFixed64) > 0 {
		for iNdEx := len(m.UnpackedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.UnpackedFixed64[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x81
		}
	}
	if len(m.UnpackedFixed32) > 0 {
		for iNdEx := len(m.UnpackedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.UnpackedFixed32[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xfd
		}
	}
	if len(m.UnpackedSint64) > 0 {
		for iNdEx := len(m.UnpackedSint64) - 1; iNdEx >= 0; iNdEx-- {
			x3 := (uint64(m.UnpackedSint64[iNdEx]) << 1) ^ uint64((m.UnpackedSint64[iNdEx] >> 63))
			i = encodeVarint(dAtA, i, uint64(x3))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xf0
		}
	}
	if len(m.UnpackedSint32) > 0 {
		for iNdEx := len(m.UnpackedSint32) - 1; iNdEx >= 0; iNdEx-- {
			x4 := (uint32(m.UnpackedSint32[iNdEx]) << 1) ^ uint32((m.UnpackedSint32[iNdEx] >> 31))
			i = encodeVarint(dAtA, i, uint64(x4))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xe8
		}
	}
	if len(m.UnpackedUint64) > 0 {
		for iNdEx := len(m.UnpackedUint64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedUint64[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xe0
		}
	}
	if len(m.UnpackedUint32) > 0 {
		for iNdEx := len(m.UnpackedUint32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedUint32[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xd8
		}
	}
	if len(m.UnpackedInt64) > 0 {
		for iNdEx := len(m.UnpackedInt64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedInt64[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xd0
		}
	}
	if len(m.UnpackedInt32) > 0 {
		for iNdEx := len(m.UnpackedInt32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedInt32[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xc8
		}
	}
	if len(m.PackedNestedEnum) > 0 {
		var pksize6 int
		for _, num := range m.PackedNestedEnum {
			pksize6 += sov(uint64(num))
		}
		i -= pksize6
		j5 := i
		for _, num1 := range m.PackedNestedEnum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA[j5] = uint8(num)
			j5++
		}
		i = encodeVarint(dAtA, i, uint64(pksize6))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc2
	}
	if len(m.PackedBool) > 0 {
		for iNdEx := len(m.PackedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.PackedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedBool)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xba
	}
	if len(m.PackedDouble) > 0 {
		for iNdEx := len(m.PackedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f7 := math.Float64bits(float64(m.PackedDouble[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f7))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedDouble)*8))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xb2
	}
	if len(m.PackedFloat) > 0 {
		for iNdEx := len(m.PackedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f8 := math.Float32bits(float32(m.PackedFloat[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f8))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedFloat)*4))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xaa
	}
	if len(m.PackedSfixed64) > 0 {
		for iNdEx := len(m.PackedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PackedSfixed64[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedSfixed64)*8))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xa2
	}
	if len(m.PackedSfixed32) > 0 {
		for iNdEx := len(m.PackedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.PackedSfixed32[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedSfixed32)*4))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x9a
	}
	if len(m.PackedFixed64) > 0 {
		for iNdEx := len(m.PackedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PackedFixed64[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedFixed64)*8))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x92
	}
	if len(m.PackedFixed32) > 0 {
		for iNdEx := len(m.PackedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.PackedFixed32[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedFixed32)*4))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x8a
	}
	if len(m.PackedSint64) > 0 {
		var pksize10 int
		for _, num := range m.PackedSint64 {
			pksize10 += soz(uint64(num))
		}
		i -= pksize10
		j9 := i
		for _, num := range m.PackedSint64 {
			x11 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x11 >= 1<<7 {
				dAtA[j9] = uint8(uint64(x11)&0x7f | 0x80)
				j9++
				x11 >>= 7
			}
			dAtA[j9] = uint8(x11)
			j9++
		}
		i = encodeVarint(dAtA, i, uint64(pksize10))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x82
	}
	if len(m.PackedSint32) > 0 {
		var pksize13 int
		for _, num := range m.PackedSint32 {
			pksize13 += soz(uint64(num))
		}
		i -= pksize13
		j12 := i
		for _, num := range m.PackedSint32 {
			x14 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x14 >= 1<<7 {
				dAtA[j12] = uint8(uint64(x14)&0x7f | 0x80)
				j12++
				x14 >>= 7
			}
			dAtA[j12] = uint8(x14)
			j12++
		}
		i = encodeVarint(dAtA, i, uint64(pksize13))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xfa
	}
	if len(m.PackedUint64) > 0 {
		var pksize16 int
		for _, num := range m.PackedUint64 {
			pksize16 += sov(uint64(num))
		}
		i -= pksize16
		j15 := i
		for _, num := range m.PackedUint64 {
			for num >= 1<<7 {
				dAtA[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA[j15] = uint8(num)
			j15++
		}
		i = encodeVarint(dAtA, i, uint64(pksize16))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
	}
	if len(m.PackedUint32) > 0 {
		var pksize18 int
		for _, num := range m.PackedUint32 {
			pksize18 += sov(uint64(num))
		}
		i -= pksize18
		j17 := i
		for _, num := range m.PackedUint32 {
			for num >= 1<<7 {
				dAtA[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA[j17] = uint8(num)
			j17++
		}
		i = encodeVarint(dAtA, i, uint64(pksize18))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xea
	}
	if len(m.PackedInt64) > 0 {
		var pksize20 int
		for _, num := range m.PackedInt64 {
			pksize20 += sov(uint64(num))
		}
		i -= pksize20
		j19 := i
		for _, num1 := range m.PackedInt64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA[j19] = uint8(num)
			j19++
		}
		i = encodeVarint(dAtA, i, uint64(pksize20))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe2
	}
	if len(m.PackedInt32) > 0 {
		var pksize22 int
		for _, num := range m.PackedInt32 {
			pksize22 += sov(uint64(num))
		}
		i -= pksize22
		j21 := i
		for _, num1 := range m.PackedInt32 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA[j21] = uint8(num)
			j21++
		}
		i = encodeVarint(dAtA, i, uint64(pksize22))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xda
	}
	if len(m.MapStringForeignEnum) > 0 {
		for k := range m.MapStringForeignEnum {
			v := m.MapStringForeignEnum[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.MapStringNestedEnum) > 0 {
		for k := range m.MapStringNestedEnum {
			v := m.MapStringNestedEnum[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.MapStringForeignMessage) > 0 {
		for k := range m.MapStringForeignMessage {
			v := m.MapStringForeignMessage[k]
			baseI := i
			{
				size, err := v.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.MapStringNestedMessage) > 0 {
		for k := range m.MapStringNestedMessage {
			v := m.MapStringNestedMessage[k]
			baseI := i
			{
				size, err := v.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.MapStringBytes) > 0 {
		for k := range m.MapStringBytes {
			v := m.MapStringBytes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarint(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.MapStringString) > 0 {
		for k := range m.MapStringString {
			v := m.MapStringString[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarint(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.MapBoolBool) > 0 {
		for k := range m.MapBoolBool {
			v := m.MapBoolBool[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i--
			if k {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.MapInt32Double) > 0 {
		for k := range m.MapInt32Double {
			v := m.MapInt32Double[k]
			baseI := i
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i--
			dAtA[i] = 0x11
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.MapInt32Float) > 0 {
		for k := range m.MapInt32Float {
			v := m.MapInt32Float[k]
			baseI := i
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(v))))
			i--
			dAtA[i] = 0x15
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.MapSfixed64Sfixed64) > 0 {
		for k := range m.MapSfixed64Sfixed64 {
			v := m.MapSfixed64Sfixed64[k]
			baseI := i
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(v))
			i--
			dAtA[i] = 0x11
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(k))
			i--
			dAtA[i] = 0x9
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.MapSfixed32Sfixed32) > 0 {
		for k := range m.MapSfixed32Sfixed32 {
			v := m.MapSfixed32Sfixed32[k]
			baseI := i
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(v))
			i--
			dAtA[i] = 0x15
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.MapFixed64Fixed64) > 0 {
		for k := range m.MapFixed64Fixed64 {
			v := m.MapFixed64Fixed64[k]
			baseI := i
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(v))
			i--
			dAtA[i] = 0x11
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(k))
			i--
			dAtA[i] = 0x9
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.MapFixed32Fixed32) > 0 {
		for k := range m.MapFixed32Fixed32 {
			v := m.MapFixed32Fixed32[k]
			baseI := i
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(v))
			i--
			dAtA[i] = 0x15
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.MapSint64Sint64) > 0 {
		for k := range m.MapSint64Sint64 {
			v := m.MapSint64Sint64[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64((uint64(v)<<1)^uint64((v>>63))))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64((uint64(k)<<1)^uint64((k>>63))))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.MapSint32Sint32) > 0 {
		for k := range m.MapSint32Sint32 {
			v := m.MapSint32Sint32[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64((uint32(v)<<1)^uint32((v>>31))))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64((uint32(k)<<1)^uint32((k>>31))))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.MapUint64Uint64) > 0 {
		for k := range m.MapUint64Uint64 {
			v := m.MapUint64Uint64[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.MapUint32Uint32) > 0 {
		for k := range m.MapUint32Uint32 {
			v := m.MapUint32Uint32[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.MapInt64Int64) > 0 {
		for k := range m.MapInt64Int64 {
			v := m.MapInt64Int64[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.MapInt32Int32) > 0 {
		for k := range m.MapInt32Int32 {
			v := m.MapInt32Int32[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.RepeatedCord) > 0 {
		for iNdEx := len(m.RepeatedCord) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedCord[iNdEx])
			copy(dAtA[i:], m.RepeatedCord[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedCord[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.RepeatedStringPiece) > 0 {
		for iNdEx := len(m.RepeatedStringPiece) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedStringPiece[iNdEx])
			copy(dAtA[i:], m.RepeatedStringPiece[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedStringPiece[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.RepeatedForeignEnum) > 0 {
		var pksize24 int
		for _, num := range m.RepeatedForeignEnum {
			pksize24 += sov(uint64(num))
		}
		i -= pksize24
		j23 := i
		for _, num1 := range m.RepeatedForeignEnum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA[j23] = uint8(num)
			j23++
		}
		i = encodeVarint(dAtA, i, uint64(pksize24))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	if len(m.RepeatedNestedEnum) > 0 {
		var pksize26 int
		for _, num := range m.RepeatedNestedEnum {
			pksize26 += sov(uint64(num))
		}
		i -= pksize26
		j25 := i
		for _, num1 := range m.RepeatedNestedEnum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA[j25] = uint8(num)
			j25++
		}
		i = encodeVarint(dAtA, i, uint64(pksize26))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	if len(m.RepeatedForeignMessage) > 0 {
		for iNdEx := len(m.RepeatedForeignMessage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RepeatedForeignMessage[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.RepeatedNestedMessage) > 0 {
		for iNdEx := len(m.RepeatedNestedMessage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RepeatedNestedMessage[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.RepeatedBytes) > 0 {
		for iNdEx := len(m.RepeatedBytes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedBytes[iNdEx])
			copy(dAtA[i:], m.RepeatedBytes[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedBytes[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.RepeatedString) > 0 {
		for iNdEx := len(m.RepeatedString) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedString[iNdEx])
			copy(dAtA[i:], m.RepeatedString[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedString[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.RepeatedBool) > 0 {
		for iNdEx := len(m.RepeatedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.RepeatedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedBool)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if len(m.RepeatedDouble) > 0 {
		for iNdEx := len(m.RepeatedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f27 := math.Float64bits(float64(m.RepeatedDouble[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f27))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedDouble)*8))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if len(m.RepeatedFloat) > 0 {
		for iNdEx := len(m.RepeatedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f28 := math.Float32bits(float32(m.RepeatedFloat[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f28))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedFloat)*4))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if len(m.RepeatedSfixed64) > 0 {
		for iNdEx := len(m.RepeatedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RepeatedSfixed64[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedSfixed64)*8))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if len(m.RepeatedSfixed32) > 0 {
		for iNdEx := len(m.RepeatedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RepeatedSfixed32[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedSfixed32)*4))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if len(m.RepeatedFixed64) > 0 {
		for iNdEx := len(m.RepeatedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RepeatedFixed64[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedFixed64)*8))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if len(m.RepeatedFixed32) > 0 {
		for iNdEx := len(m.RepeatedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RepeatedFixed32[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedFixed32)*4))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if len(m.RepeatedSint64) > 0 {
		var pksize30 int
		for _, num := range m.RepeatedSint64 {
			pksize30 += soz(uint64(num))
		}
		i -= pksize30
		j29 := i
		for _, num := range m.RepeatedSint64 {
			x31 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x31 >= 1<<7 {
				dAtA[j29] = uint8(uint64(x31)&0x7f | 0x80)
				j29++
				x31 >>= 7
			}
			dAtA[j29] = uint8(x31)
			j29++
		}
		i = encodeVarint(dAtA, i, uint64(pksize30))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if len(m.RepeatedSint32) > 0 {
		var pksize33 int
		for _, num := range m.RepeatedSint32 {
			pksize33 += soz(uint64(num))
		}
		i -= pksize33
		j32 := i
		for _, num := range m.RepeatedSint32 {
			x34 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x34 >= 1<<7 {
				dAtA[j32] = uint8(uint64(x34)&0x7f | 0x80)
				j32++
				x34 >>= 7
			}
			dAtA[j32] = uint8(x34)
			j32++
		}
		i = encodeVarint(dAtA, i, uint64(pksize33))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if len(m.RepeatedUint64) > 0 {
		var pksize36 int
		for _, num := range m.RepeatedUint64 {
			pksize36 += sov(uint64(num))
		}
		i -= pksize36
		j35 := i
		for _, num := range m.RepeatedUint64 {
			for num >= 1<<7 {
				dAtA[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA[j35] = uint8(num)
			j35++
		}
		i = encodeVarint(dAtA, i, uint64(pksize36))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if len(m.RepeatedUint32) > 0 {
		var pksize38 int
		for _, num := range m.RepeatedUint32 {
			pksize38 += sov(uint64(num))
		}
		i -= pksize38
		j37 := i
		for _, num := range m.RepeatedUint32 {
			for num >= 1<<7 {
				dAtA[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA[j37] = uint8(num)
			j37++
		}
		i = encodeVarint(dAtA, i, uint64(pksize38))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.RepeatedInt64) > 0 {
		var pksize40 int
		for _, num := range m.RepeatedInt64 {
			pksize40 += sov(uint64(num))
		}
		i -= pksize40
		j39 := i
		for _, num1 := range m.RepeatedInt64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA[j39] = uint8(num)
			j39++
		}
		i = encodeVarint(dAtA, i, uint64(pksize40))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.RepeatedInt32) > 0 {
		var pksize42 int
		for _, num := range m.RepeatedInt32 {
			pksize42 += sov(uint64(num))
		}
		i -= pksize42
		j41 := i
		for _, num1 := range m.RepeatedInt32 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA[j41] = uint8(num)
			j41++
		}
		i = encodeVarint(dAtA, i, uint64(pksize42))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.RecursiveMessage != nil {
		{
			size, err := m.RecursiveMessage.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.OptionalCord) > 0 {
		i -= len(m.OptionalCord)
		copy(dAtA[i:], m.OptionalCord)
		i = encodeVarint(dAtA, i, uint64(len(m.OptionalCord)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.OptionalStringPiece) > 0 {
		i -= len(m.OptionalStringPiece)
		copy(dAtA[i:], m.OptionalStringPiece)
		i = encodeVarint(dAtA, i, uint64(len(m.OptionalStringPiece)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.OptionalAliasedEnum != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalAliasedEnum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.OptionalForeignEnum != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalForeignEnum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.OptionalNestedEnum != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalNestedEnum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.OptionalForeignMessage != nil {
		{
			size, err := m.OptionalForeignMessage.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.OptionalNestedMessage != nil {
		{
			size, err := m.OptionalNestedMessage.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.OptionalBytes) > 0 {
		i -= len(m.OptionalBytes)
		copy(dAtA[i:], m.OptionalBytes)
		i = encodeVarint(dAtA, i, uint64(len(m.OptionalBytes)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.OptionalString) > 0 {
		i -= len(m.OptionalString)
		copy(dAtA[i:], m.OptionalString)
		i = encodeVarint(dAtA, i, uint64(len(m.OptionalString)))
		i--
		dAtA[i] = 0x72
	}
	if m.OptionalBool {
		i--
		if m.OptionalBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.OptionalDouble != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OptionalDouble))))
		i--
		dAtA[i] = 0x61
	}
	if m.OptionalFloat != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.OptionalFloat))))
		i--
		dAtA[i] = 0x5d
	}
	if m.OptionalSfixed64 != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.OptionalSfixed64))
		i--
		dAtA[i] = 0x51
	}
	if m.OptionalSfixed32 != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.OptionalSfixed32))
		i--
		dAtA[i] = 0x4d
	}
	if m.OptionalFixed64 != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.OptionalFixed64))
		i--
		dAtA[i] = 0x41
	}
	if m.OptionalFixed32 != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.OptionalFixed32))
		i--
		dAtA[i] = 0x3d
	}
	if m.OptionalSint64 != 0 {
		i = encodeVarint(dAtA, i, uint64((uint64(m.OptionalSint64)<<1)^uint64((m.OptionalSint64>>63))))
		i--
		dAtA[i] = 0x30
	}
	if m.OptionalSint32 != 0 {
		i = encodeVarint(dAtA, i, uint64((uint32(m.OptionalSint32)<<1)^uint32((m.OptionalSint32>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.OptionalUint64 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalUint64))
		i--
		dAtA[i] = 0x20
	}
	if m.OptionalUint32 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalUint32))
		i--
		dAtA[i] = 0x18
	}
	if m.OptionalInt64 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalInt64))
		i--
		dAtA[i] = 0x10
	}
	if m.OptionalInt32 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalInt32))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto3_OneofUint32) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofUint32) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofUint32))
	i--
	dAtA[i] = 0x6
	i--
	dAtA[i] = 0xf8
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofNestedMessage) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofNestedMessage) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OneofNestedMessage != nil {
		{
			size, err := m.OneofNestedMessage.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofString) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofString) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.OneofString)
	copy(dAtA[i:], m.OneofString)
	i = encodeVarint(dAtA, i, uint64(len(m.OneofString)))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0x8a
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofBytes) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofBytes) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.OneofBytes)
	copy(dAtA[i:], m.OneofBytes)
	i = encodeVarint(dAtA, i, uint64(len(m.OneofBytes)))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0x92
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofBool) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofBool) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.OneofBool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0x98
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofUint64) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofUint64) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofUint64))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xa0
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofFloat) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofFloat) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.OneofFloat))))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xad
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofDouble) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofDouble) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OneofDouble))))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xb1
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofEnum) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofEnum) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofEnum))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xb8
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofNullValue) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofNullValue) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofNullValue))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xc0
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionalInt32 != 0 {
		n += 1 + sov(uint64(m.OptionalInt32))
	}
	if m.OptionalInt64 != 0 {
		n += 1 + sov(uint64(m.OptionalInt64))
	}
	if m.OptionalUint32 != 0 {
		n += 1 + sov(uint64(m.OptionalUint32))
	}
	if m.OptionalUint64 != 0 {
		n += 1 + sov(uint64(m.OptionalUint64))
	}
	if m.OptionalSint32 != 0 {
		n += 1 + soz(uint64(m.OptionalSint32))
	}
	if m.OptionalSint64 != 0 {
		n += 1 + soz(uint64(m.OptionalSint64))
	}
	if m.OptionalFixed32 != 0 {
		n += 5
	}
	if m.OptionalFixed64 != 0 {
		n += 9
	}
	if m.OptionalSfixed32 != 0 {
		n += 5
	}
	if m.OptionalSfixed64 != 0 {
		n += 9
	}
	if m.OptionalFloat != 0 {
		n += 5
	}
	if m.OptionalDouble != 0 {
		n += 9
	}
	if m.OptionalBool {
		n += 2
	}
	l = len(m.OptionalString)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.OptionalBytes)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.OptionalNestedMessage != nil {
		l = m.OptionalNestedMessage.SizeVT()
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalForeignMessage != nil {
		l = m.OptionalForeignMessage.SizeVT()
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalNestedEnum != 0 {
		n += 2 + sov(uint64(m.OptionalNestedEnum))
	}
	if m.OptionalForeignEnum != 0 {
		n += 2 + sov(uint64(m.OptionalForeignEnum))
	}
	if m.OptionalAliasedEnum != 0 {
		n += 2 + sov(uint64(m.OptionalAliasedEnum))
	}
	l = len(m.OptionalStringPiece)
	if l > 0 {
		n += 2 + l + sov(uint64(l))
	}
	l = len(m.OptionalCord)
	if l > 0 {
		n += 2 + l + sov(uint64(l))
	}
	if m.RecursiveMessage != nil {
		l = m.RecursiveMessage.SizeVT()
		n += 2 + l + sov(uint64(l))
	}
	if len(m.RepeatedInt32) > 0 {
		l = 0
		for _, e := range m.RepeatedInt32 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedInt64) > 0 {
		l = 0
		for _, e := range m.RepeatedInt64 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedUint32) > 0 {
		l = 0
		for _, e := range m.RepeatedUint32 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedUint64) > 0 {
		l = 0
		for _, e := range m.RepeatedUint64 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedSint32) > 0 {
		l = 0
		for _, e := range m.RepeatedSint32 {
			l += soz(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedSint64) > 0 {
		l = 0
		for _, e := range m.RepeatedSint64 {
			l += soz(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedFixed32) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedFixed32)*4)) + len(m.RepeatedFixed32)*4
	}
	if len(m.RepeatedFixed64) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedFixed64)*8)) + len(m.RepeatedFixed64)*8
	}
	if len(m.RepeatedSfixed32) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedSfixed32)*4)) + len(m.RepeatedSfixed32)*4
	}
	if len(m.RepeatedSfixed64) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedSfixed64)*8)) + len(m.RepeatedSfixed64)*8
	}
	if len(m.RepeatedFloat) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedFloat)*4)) + len(m.RepeatedFloat)*4
	}
	if len(m.RepeatedDouble) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedDouble)*8)) + len(m.RepeatedDouble)*8
	}
	if len(m.RepeatedBool) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedBool))) + len(m.RepeatedBool)*1
	}
	if len(m.RepeatedString) > 0 {
		for _, s := range m.RepeatedString {
			l = len(s)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedBytes) > 0 {
		for _, b := range m.RepeatedBytes {
			l = len(b)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedNestedMessage) > 0 {
		for _, e := range m.RepeatedNestedMessage {
			l = e.SizeVT()
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedForeignMessage) > 0 {
		for _, e := range m.RepeatedForeignMessage {
			l = e.SizeVT()
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedNestedEnum) > 0 {
		l = 0
		for _, e := range m.RepeatedNestedEnum {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedForeignEnum) > 0 {
		l = 0
		for _, e := range m.RepeatedForeignEnum {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedStringPiece) > 0 {
		for _, s := range m.RepeatedStringPiece {
			l = len(s)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedCord) > 0 {
		for _, s := range m.RepeatedCord {
			l = len(s)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.MapInt32Int32) > 0 {
		for k, v := range m.MapInt32Int32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt64Int64) > 0 {
		for k, v := range m.MapInt64Int64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapUint32Uint32) > 0 {
		for k, v := range m.MapUint32Uint32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapUint64Uint64) > 0 {
		for k, v := range m.MapUint64Uint64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapSint32Sint32) > 0 {
		for k, v := range m.MapSint32Sint32 {
			_ = k
			_ = v
			mapEntrySize := 1 + soz(uint64(k)) + 1 + soz(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapSint64Sint64) > 0 {
		for k, v := range m.MapSint64Sint64 {
			_ = k
			_ = v
			mapEntrySize := 1 + soz(uint64(k)) + 1 + soz(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapFixed32Fixed32) > 0 {
		for k, v := range m.MapFixed32Fixed32 {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapFixed64Fixed64) > 0 {
		for k, v := range m.MapFixed64Fixed64 {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapSfixed32Sfixed32) > 0 {
		for k, v := range m.MapSfixed32Sfixed32 {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapSfixed64Sfixed64) > 0 {
		for k, v := range m.MapSfixed64Sfixed64 {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt32Float) > 0 {
		for k, v := range m.MapInt32Float {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + 4
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt32Double) > 0 {
		for k, v := range m.MapInt32Double {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + 8
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapBoolBool) > 0 {
		for k, v := range m.MapBoolBool {
			_ = k
			_ = v
			mapEntrySize := 1 + 1 + 1 + 1
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringString) > 0 {
		for k, v := range m.MapStringString {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + 1 + len(v) + sov(uint64(len(v)))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringBytes) > 0 {
		for k, v := range m.MapStringBytes {
			_ = k
			_ = v
			l = 1 + len(v) + sov(uint64(len(v)))
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + l
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringNestedMessage) > 0 {
		for k, v := range m.MapStringNestedMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.SizeVT()
			}
			l += 1 + sov(uint64(l))
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + l
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringForeignMessage) > 0 {
		for k, v := range m.MapStringForeignMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.SizeVT()
			}
			l += 1 + sov(uint64(l))
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + l
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringNestedEnum) > 0 {
		for k, v := range m.MapStringNestedEnum {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringForeignEnum) > 0 {
		for k, v := range m.MapStringForeignEnum {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.PackedInt32) > 0 {
		l = 0
		for _, e := range m.PackedInt32 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedInt64) > 0 {
		l = 0
		for _, e := range m.PackedInt64 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedUint32) > 0 {
		l = 0
		for _, e := range m.PackedUint32 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedUint64) > 0 {
		l = 0
		for _, e := range m.PackedUint64 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedSint32) > 0 {
		l = 0
		for _, e := range m.PackedSint32 {
			l += soz(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedSint64) > 0 {
		l = 0
		for _, e := range m.PackedSint64 {
			l += soz(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedFixed32) > 0 {
		n += 2 + sov(uint64(len(m.PackedFixed32)*4)) + len(m.PackedFixed32)*4
	}
	if len(m.PackedFixed64) > 0 {
		n += 2 + sov(uint64(len(m.PackedFixed64)*8)) + len(m.PackedFixed64)*8
	}
	if len(m.PackedSfixed32) > 0 {
		n += 2 + sov(uint64(len(m.PackedSfixed32)*4)) + len(m.PackedSfixed32)*4
	}
	if len(m.PackedSfixed64) > 0 {
		n += 2 + sov(uint64(len(m.PackedSfixed64)*8)) + len(m.PackedSfixed64)*8
	}
	if len(m.PackedFloat) > 0 {
		n += 2 + sov(uint64(len(m.PackedFloat)*4)) + len(m.PackedFloat)*4
	}
	if len(m.PackedDouble) > 0 {
		n += 2 + sov(uint64(len(m.PackedDouble)*8)) + len(m.PackedDouble)*8
	}
	if len(m.PackedBool) > 0 {
		n += 2 + sov(uint64(len(m.PackedBool))) + len(m.PackedBool)*1
	}
	if len(m.PackedNestedEnum) > 0 {
		l = 0
		for _, e := range m.PackedNestedEnum {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.UnpackedInt32) > 0 {
		for _, e := range m.UnpackedInt32 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.UnpackedInt64) > 0 {
		for _, e := range m.UnpackedInt64 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.UnpackedUint32) > 0 {
		for _, e := range m.UnpackedUint32 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.UnpackedUint64) > 0 {
		for _, e := range m.UnpackedUint64 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.UnpackedSint32) > 0 {
		for _, e := range m.UnpackedSint32 {
			n += 2 + soz(uint64(e))
		}
	}
	if len(m.UnpackedSint64) > 0 {
		for _, e := range m.UnpackedSint64 {
			n += 2 + soz(uint64(e))
		}
	}
	if len(m.UnpackedFixed32) > 0 {
		n += 6 * len(m.UnpackedFixed32)
	}
	if len(m.UnpackedFixed64) > 0 {
		n += 10 * len(m.UnpackedFixed64)
	}
	if len(m.UnpackedSfixed32) > 0 {
		n += 6 * len(m.UnpackedSfixed32)
	}
	if len(m.UnpackedSfixed64) > 0 {
		n += 10 * len(m.UnpackedSfixed64)
	}
	if len(m.UnpackedFloat) > 0 {
		n += 6 * len(m.UnpackedFloat)
	}
	if len(m.UnpackedDouble) > 0 {
		n += 10 * len(m.UnpackedDouble)
	}
	if len(m.UnpackedBool) > 0 {
		n += 3 * len(m.UnpackedBool)
	}
	if len(m.UnpackedNestedEnum) > 0 {
		for _, e := range m.UnpackedNestedEnum {
			n += 2 + sov(uint64(e))
		}
	}
	if vtmsg, ok := m.OneofField.(vtprotoMessage); ok {
		n += vtmsg.SizeVT()
	}
	if m.OptionalBoolWrapper != nil {
		l = proto.Size(m.OptionalBoolWrapper)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalInt32Wrapper != nil {
		l = proto.Size(m.OptionalInt32Wrapper)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalInt64Wrapper != nil {
		l = proto.Size(m.OptionalInt64Wrapper)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalUint32Wrapper != nil {
		l = proto.Size(m.OptionalUint32Wrapper)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalUint64Wrapper != nil {
		l = proto.Size(m.OptionalUint64Wrapper)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalFloatWrapper != nil {
		l = proto.Size(m.OptionalFloatWrapper)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalDoubleWrapper != nil {
		l = proto.Size(m.OptionalDoubleWrapper)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalStringWrapper != nil {
		l = proto.Size(m.OptionalStringWrapper)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalBytesWrapper != nil {
		l = proto.Size(m.OptionalBytesWrapper)
		n += 2 + l + sov(uint64(l))
	}
	if len(m.RepeatedBoolWrapper) > 0 {
		for _, e := range m.RepeatedBoolWrapper {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedInt32Wrapper) > 0 {
		for _, e := range m.RepeatedInt32Wrapper {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedInt64Wrapper) > 0 {
		for _, e := range m.RepeatedInt64Wrapper {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedUint32Wrapper) > 0 {
		for _, e := range m.RepeatedUint32Wrapper {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedUint64Wrapper) > 0 {
		for _, e := range m.RepeatedUint64Wrapper {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedFloatWrapper) > 0 {
		for _, e := range m.RepeatedFloatWrapper {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedDoubleWrapper) > 0 {
		for _, e := range m.RepeatedDoubleWrapper {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedStringWrapper) > 0 {
		for _, e := range m.RepeatedStringWrapper {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedBytesWrapper) > 0 {
		for _, e := range m.RepeatedBytesWrapper {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if m.OptionalDuration != nil {
		l = proto.Size(m.OptionalDuration)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalTimestamp != nil {
		l = proto.Size(m.OptionalTimestamp)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalFieldMask != nil {
		l = proto.Size(m.OptionalFieldMask)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalStruct != nil {
		l = proto.Size(m.OptionalStruct)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalAny != nil {
		l = proto.Size(m.OptionalAny)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalValue != nil {
		l = proto.Size(m.OptionalValue)
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalNullValue != 0 {
		n += 2 + sov(uint64(m.OptionalNullValue))
	}
	if len(m.RepeatedDuration) > 0 {
		for _, e := range m.RepeatedDuration {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedTimestamp) > 0 {
		for _, e := range m.RepeatedTimestamp {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedFieldmask) > 0 {
		for _, e := range m.RepeatedFieldmask {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedAny) > 0 {
		for _, e := range m.RepeatedAny {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedValue) > 0 {
		for _, e := range m.RepeatedValue {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedListValue) > 0 {
		for _, e := range m.RepeatedListValue {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedStruct) > 0 {
		for _, e := range m.RepeatedStruct {
			l = proto.Size(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	if m.Fieldname1 != 0 {
		n += 2 + sov(uint64(m.Fieldname1))
	}
	if m.FieldName2 != 0 {
		n += 2 + sov(uint64(m.FieldName2))
	}
	if m.XFieldName3 != 0 {
		n += 2 + sov(uint64(m.XFieldName3))
	}
	if m.Field_Name4_ != 0 {
		n += 2 + sov(uint64(m.Field_Name4_))
	}
	if m.Field0Name5 != 0 {
		n += 2 + sov(uint64(m.Field0Name5))
	}
	if m.Field_0Name6 != 0 {
		n += 2 + sov(uint64(m.Field_0Name6))
	}
	if m.FieldName7 != 0 {
		n += 2 + sov(uint64(m.FieldName7))
	}
	if m.FieldName8 != 0 {
		n += 2 + sov(uint64(m.FieldName8))
	}
	if m.Field_Name9 != 0 {
		n += 2 + sov(uint64(m.Field_Name9))
	}
	if m.Field_Name10 != 0 {
		n += 2 + sov(uint64(m.Field_Name10))
	}
	if m.FIELD_NAME11 != 0 {
		n += 2 + sov(uint64(m.FIELD_NAME11))
	}
	if m.FIELDName12 != 0 {
		n += 2 + sov(uint64(m.FIELDName12))
	}
	if m.XFieldName13 != 0 {
		n += 2 + sov(uint64(m.XFieldName13))
	}
	if m.X_FieldName14 != 0 {
		n += 2 + sov(uint64(m.X_FieldName14))
	}
	if m.Field_Name15 != 0 {
		n += 2 + sov(uint64(m.Field_Name15))
	}
	if m.Field__Name16 != 0 {
		n += 2 + sov(uint64(m.Field__Name16))
	}
	if m.FieldName17__ != 0 {
		n += 2 + sov(uint64(m.FieldName17__))
	}
	if m.FieldName18__ != 0 {
		n += 2 + sov(uint64(m.FieldName18__))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func (m *TestAllTypesProto3_OneofUint32) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sov(uint64(m.OneofUint32))
	return n
}
func (m *TestAllTypesProto3_OneofNestedMessage) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OneofNestedMessage != nil {
		l = m.OneofNestedMessage.SizeVT()
		n += 2 + l + sov(uint64(l))
	}
	return n
}
func (m *TestAllTypesProto3_OneofString) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OneofString)
	n += 2 + l + sov(uint64(l))
	return n
}
func (m *TestAllTypesProto3_OneofBytes) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OneofBytes)
	n += 2 + l + sov(uint64(l))
	return n
}
func (m *TestAllTypesProto3_OneofBool) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *TestAllTypesProto3_OneofUint64) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sov(uint64(m.OneofUint64))
	return n
}
func (m *TestAllTypesProto3_OneofFloat) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 6
	return n
}
func (m *TestAllTypesProto3_OneofDouble) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 10
	return n
}
func (m *TestAllTypesProto3_OneofEnum) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sov(uint64(m.OneofEnum))
	return n
}
func (m *TestAllTypesProto3_OneofNullValue) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sov(uint64(m.OneofNullValue))
	return n
}
func (m *ForeignMessage) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			m.C = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.C |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignMessage) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignMessage) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ForeignMessage) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.C != 0 {
		i = encodeVarint(dAtA, i, uint64(m.C))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForeignMessage) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.C != 0 {
		n += 1 + sov(uint64(m.C))
	}
	if m.unknownFields != nil {
		n += len(m.unknownFields)
	}
	return n
}

func skip(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLength
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroup
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLength
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLength        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflow          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroup = fmt.Errorf("proto: unexpected end of group")
)

func encodeVarint(dAtA []byte, offset int, v uint64) int {
	offset -= sov(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

func sov(x uint64) (n int) {
	return (bits.Len64(x|1) + 6) / 7
}
func soz(x uint64) (n int) {
	return sov(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}

type vtprotoMessage interface {
	MarshalToVT([]byte) (int, error)
	SizeVT() int
}
