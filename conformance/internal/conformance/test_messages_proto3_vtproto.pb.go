// Code generated by protoc-gen-go-vtproto. DO NOT EDIT.
// protoc-gen-go-vtproto version: (devel)
// source: src/google/protobuf/test_messages_proto3.proto

package conformance

import (
	binary "encoding/binary"
	fmt "fmt"
	proto "google.golang.org/protobuf/proto"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	io "io"
	math "math"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

func (m *TestAllTypesProto3_NestedMessage) CloneVT() *TestAllTypesProto3_NestedMessage {
	if m == nil {
		return (*TestAllTypesProto3_NestedMessage)(nil)
	}
	r := &TestAllTypesProto3_NestedMessage{
		A:           m.A,
		Corecursive: m.Corecursive.CloneVT(),
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *TestAllTypesProto3_NestedMessage) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

// Deprecated: use CloneMessageVT instead
func (m *TestAllTypesProto3_NestedMessage) CloneGenericVT() proto.Message {
	return m.CloneMessageVT()
}

func (m *TestAllTypesProto3) CloneVT() *TestAllTypesProto3 {
	if m == nil {
		return (*TestAllTypesProto3)(nil)
	}
	r := &TestAllTypesProto3{
		OptionalInt32:          m.OptionalInt32,
		OptionalInt64:          m.OptionalInt64,
		OptionalUint32:         m.OptionalUint32,
		OptionalUint64:         m.OptionalUint64,
		OptionalSint32:         m.OptionalSint32,
		OptionalSint64:         m.OptionalSint64,
		OptionalFixed32:        m.OptionalFixed32,
		OptionalFixed64:        m.OptionalFixed64,
		OptionalSfixed32:       m.OptionalSfixed32,
		OptionalSfixed64:       m.OptionalSfixed64,
		OptionalFloat:          m.OptionalFloat,
		OptionalDouble:         m.OptionalDouble,
		OptionalBool:           m.OptionalBool,
		OptionalString:         m.OptionalString,
		OptionalNestedMessage:  m.OptionalNestedMessage.CloneVT(),
		OptionalForeignMessage: m.OptionalForeignMessage.CloneVT(),
		OptionalNestedEnum:     m.OptionalNestedEnum,
		OptionalForeignEnum:    m.OptionalForeignEnum,
		OptionalAliasedEnum:    m.OptionalAliasedEnum,
		OptionalStringPiece:    m.OptionalStringPiece,
		OptionalCord:           m.OptionalCord,
		RecursiveMessage:       m.RecursiveMessage.CloneVT(),
		OptionalNullValue:      m.OptionalNullValue,
		Fieldname1:             m.Fieldname1,
		FieldName2:             m.FieldName2,
		XFieldName3:            m.XFieldName3,
		Field_Name4_:           m.Field_Name4_,
		Field0Name5:            m.Field0Name5,
		Field_0Name6:           m.Field_0Name6,
		FieldName7:             m.FieldName7,
		FieldName8:             m.FieldName8,
		Field_Name9:            m.Field_Name9,
		Field_Name10:           m.Field_Name10,
		FIELD_NAME11:           m.FIELD_NAME11,
		FIELDName12:            m.FIELDName12,
		XFieldName13:           m.XFieldName13,
		X_FieldName14:          m.X_FieldName14,
		Field_Name15:           m.Field_Name15,
		Field__Name16:          m.Field__Name16,
		FieldName17__:          m.FieldName17__,
		FieldName18__:          m.FieldName18__,
	}
	if rhs := m.OptionalBytes; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.OptionalBytes = tmpBytes
	}
	if rhs := m.RepeatedInt32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedInt32 = tmpContainer
	}
	if rhs := m.RepeatedInt64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedInt64 = tmpContainer
	}
	if rhs := m.RepeatedUint32; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedUint32 = tmpContainer
	}
	if rhs := m.RepeatedUint64; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedUint64 = tmpContainer
	}
	if rhs := m.RepeatedSint32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedSint32 = tmpContainer
	}
	if rhs := m.RepeatedSint64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedSint64 = tmpContainer
	}
	if rhs := m.RepeatedFixed32; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedFixed32 = tmpContainer
	}
	if rhs := m.RepeatedFixed64; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedFixed64 = tmpContainer
	}
	if rhs := m.RepeatedSfixed32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedSfixed32 = tmpContainer
	}
	if rhs := m.RepeatedSfixed64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedSfixed64 = tmpContainer
	}
	if rhs := m.RepeatedFloat; rhs != nil {
		tmpContainer := make([]float32, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedFloat = tmpContainer
	}
	if rhs := m.RepeatedDouble; rhs != nil {
		tmpContainer := make([]float64, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedDouble = tmpContainer
	}
	if rhs := m.RepeatedBool; rhs != nil {
		tmpContainer := make([]bool, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedBool = tmpContainer
	}
	if rhs := m.RepeatedString; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedString = tmpContainer
	}
	if rhs := m.RepeatedBytes; rhs != nil {
		tmpContainer := make([][]byte, len(rhs))
		for k, v := range rhs {
			tmpBytes := make([]byte, len(v))
			copy(tmpBytes, v)
			tmpContainer[k] = tmpBytes
		}
		r.RepeatedBytes = tmpContainer
	}
	if rhs := m.RepeatedNestedMessage; rhs != nil {
		tmpContainer := make([]*TestAllTypesProto3_NestedMessage, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.RepeatedNestedMessage = tmpContainer
	}
	if rhs := m.RepeatedForeignMessage; rhs != nil {
		tmpContainer := make([]*ForeignMessage, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.RepeatedForeignMessage = tmpContainer
	}
	if rhs := m.RepeatedNestedEnum; rhs != nil {
		tmpContainer := make([]TestAllTypesProto3_NestedEnum, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedNestedEnum = tmpContainer
	}
	if rhs := m.RepeatedForeignEnum; rhs != nil {
		tmpContainer := make([]ForeignEnum, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedForeignEnum = tmpContainer
	}
	if rhs := m.RepeatedStringPiece; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedStringPiece = tmpContainer
	}
	if rhs := m.RepeatedCord; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.RepeatedCord = tmpContainer
	}
	if rhs := m.PackedInt32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedInt32 = tmpContainer
	}
	if rhs := m.PackedInt64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedInt64 = tmpContainer
	}
	if rhs := m.PackedUint32; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedUint32 = tmpContainer
	}
	if rhs := m.PackedUint64; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedUint64 = tmpContainer
	}
	if rhs := m.PackedSint32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedSint32 = tmpContainer
	}
	if rhs := m.PackedSint64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedSint64 = tmpContainer
	}
	if rhs := m.PackedFixed32; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedFixed32 = tmpContainer
	}
	if rhs := m.PackedFixed64; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedFixed64 = tmpContainer
	}
	if rhs := m.PackedSfixed32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedSfixed32 = tmpContainer
	}
	if rhs := m.PackedSfixed64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedSfixed64 = tmpContainer
	}
	if rhs := m.PackedFloat; rhs != nil {
		tmpContainer := make([]float32, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedFloat = tmpContainer
	}
	if rhs := m.PackedDouble; rhs != nil {
		tmpContainer := make([]float64, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedDouble = tmpContainer
	}
	if rhs := m.PackedBool; rhs != nil {
		tmpContainer := make([]bool, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedBool = tmpContainer
	}
	if rhs := m.PackedNestedEnum; rhs != nil {
		tmpContainer := make([]TestAllTypesProto3_NestedEnum, len(rhs))
		copy(tmpContainer, rhs)
		r.PackedNestedEnum = tmpContainer
	}
	if rhs := m.UnpackedInt32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedInt32 = tmpContainer
	}
	if rhs := m.UnpackedInt64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedInt64 = tmpContainer
	}
	if rhs := m.UnpackedUint32; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedUint32 = tmpContainer
	}
	if rhs := m.UnpackedUint64; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedUint64 = tmpContainer
	}
	if rhs := m.UnpackedSint32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedSint32 = tmpContainer
	}
	if rhs := m.UnpackedSint64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedSint64 = tmpContainer
	}
	if rhs := m.UnpackedFixed32; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedFixed32 = tmpContainer
	}
	if rhs := m.UnpackedFixed64; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedFixed64 = tmpContainer
	}
	if rhs := m.UnpackedSfixed32; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedSfixed32 = tmpContainer
	}
	if rhs := m.UnpackedSfixed64; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedSfixed64 = tmpContainer
	}
	if rhs := m.UnpackedFloat; rhs != nil {
		tmpContainer := make([]float32, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedFloat = tmpContainer
	}
	if rhs := m.UnpackedDouble; rhs != nil {
		tmpContainer := make([]float64, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedDouble = tmpContainer
	}
	if rhs := m.UnpackedBool; rhs != nil {
		tmpContainer := make([]bool, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedBool = tmpContainer
	}
	if rhs := m.UnpackedNestedEnum; rhs != nil {
		tmpContainer := make([]TestAllTypesProto3_NestedEnum, len(rhs))
		copy(tmpContainer, rhs)
		r.UnpackedNestedEnum = tmpContainer
	}
	if rhs := m.MapInt32Int32; rhs != nil {
		tmpContainer := make(map[int32]int32, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapInt32Int32 = tmpContainer
	}
	if rhs := m.MapInt64Int64; rhs != nil {
		tmpContainer := make(map[int64]int64, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapInt64Int64 = tmpContainer
	}
	if rhs := m.MapUint32Uint32; rhs != nil {
		tmpContainer := make(map[uint32]uint32, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapUint32Uint32 = tmpContainer
	}
	if rhs := m.MapUint64Uint64; rhs != nil {
		tmpContainer := make(map[uint64]uint64, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapUint64Uint64 = tmpContainer
	}
	if rhs := m.MapSint32Sint32; rhs != nil {
		tmpContainer := make(map[int32]int32, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapSint32Sint32 = tmpContainer
	}
	if rhs := m.MapSint64Sint64; rhs != nil {
		tmpContainer := make(map[int64]int64, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapSint64Sint64 = tmpContainer
	}
	if rhs := m.MapFixed32Fixed32; rhs != nil {
		tmpContainer := make(map[uint32]uint32, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapFixed32Fixed32 = tmpContainer
	}
	if rhs := m.MapFixed64Fixed64; rhs != nil {
		tmpContainer := make(map[uint64]uint64, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapFixed64Fixed64 = tmpContainer
	}
	if rhs := m.MapSfixed32Sfixed32; rhs != nil {
		tmpContainer := make(map[int32]int32, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapSfixed32Sfixed32 = tmpContainer
	}
	if rhs := m.MapSfixed64Sfixed64; rhs != nil {
		tmpContainer := make(map[int64]int64, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapSfixed64Sfixed64 = tmpContainer
	}
	if rhs := m.MapInt32Float; rhs != nil {
		tmpContainer := make(map[int32]float32, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapInt32Float = tmpContainer
	}
	if rhs := m.MapInt32Double; rhs != nil {
		tmpContainer := make(map[int32]float64, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapInt32Double = tmpContainer
	}
	if rhs := m.MapBoolBool; rhs != nil {
		tmpContainer := make(map[bool]bool, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapBoolBool = tmpContainer
	}
	if rhs := m.MapStringString; rhs != nil {
		tmpContainer := make(map[string]string, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapStringString = tmpContainer
	}
	if rhs := m.MapStringBytes; rhs != nil {
		tmpContainer := make(map[string][]byte, len(rhs))
		for k, v := range rhs {
			tmpBytes := make([]byte, len(v))
			copy(tmpBytes, v)
			tmpContainer[k] = tmpBytes
		}
		r.MapStringBytes = tmpContainer
	}
	if rhs := m.MapStringNestedMessage; rhs != nil {
		tmpContainer := make(map[string]*TestAllTypesProto3_NestedMessage, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.MapStringNestedMessage = tmpContainer
	}
	if rhs := m.MapStringForeignMessage; rhs != nil {
		tmpContainer := make(map[string]*ForeignMessage, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.MapStringForeignMessage = tmpContainer
	}
	if rhs := m.MapStringNestedEnum; rhs != nil {
		tmpContainer := make(map[string]TestAllTypesProto3_NestedEnum, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapStringNestedEnum = tmpContainer
	}
	if rhs := m.MapStringForeignEnum; rhs != nil {
		tmpContainer := make(map[string]ForeignEnum, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v
		}
		r.MapStringForeignEnum = tmpContainer
	}
	if m.OneofField != nil {
		r.OneofField = m.OneofField.(interface {
			CloneVT() isTestAllTypesProto3_OneofField
		}).CloneVT()
	}
	if rhs := m.OptionalBoolWrapper; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *wrapperspb.BoolValue }); ok {
			r.OptionalBoolWrapper = vtpb.CloneVT()
		} else {
			r.OptionalBoolWrapper = proto.Clone(rhs).(*wrapperspb.BoolValue)
		}
	}
	if rhs := m.OptionalInt32Wrapper; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *wrapperspb.Int32Value }); ok {
			r.OptionalInt32Wrapper = vtpb.CloneVT()
		} else {
			r.OptionalInt32Wrapper = proto.Clone(rhs).(*wrapperspb.Int32Value)
		}
	}
	if rhs := m.OptionalInt64Wrapper; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *wrapperspb.Int64Value }); ok {
			r.OptionalInt64Wrapper = vtpb.CloneVT()
		} else {
			r.OptionalInt64Wrapper = proto.Clone(rhs).(*wrapperspb.Int64Value)
		}
	}
	if rhs := m.OptionalUint32Wrapper; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *wrapperspb.UInt32Value
		}); ok {
			r.OptionalUint32Wrapper = vtpb.CloneVT()
		} else {
			r.OptionalUint32Wrapper = proto.Clone(rhs).(*wrapperspb.UInt32Value)
		}
	}
	if rhs := m.OptionalUint64Wrapper; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *wrapperspb.UInt64Value
		}); ok {
			r.OptionalUint64Wrapper = vtpb.CloneVT()
		} else {
			r.OptionalUint64Wrapper = proto.Clone(rhs).(*wrapperspb.UInt64Value)
		}
	}
	if rhs := m.OptionalFloatWrapper; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *wrapperspb.FloatValue }); ok {
			r.OptionalFloatWrapper = vtpb.CloneVT()
		} else {
			r.OptionalFloatWrapper = proto.Clone(rhs).(*wrapperspb.FloatValue)
		}
	}
	if rhs := m.OptionalDoubleWrapper; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *wrapperspb.DoubleValue
		}); ok {
			r.OptionalDoubleWrapper = vtpb.CloneVT()
		} else {
			r.OptionalDoubleWrapper = proto.Clone(rhs).(*wrapperspb.DoubleValue)
		}
	}
	if rhs := m.OptionalStringWrapper; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *wrapperspb.StringValue
		}); ok {
			r.OptionalStringWrapper = vtpb.CloneVT()
		} else {
			r.OptionalStringWrapper = proto.Clone(rhs).(*wrapperspb.StringValue)
		}
	}
	if rhs := m.OptionalBytesWrapper; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *wrapperspb.BytesValue }); ok {
			r.OptionalBytesWrapper = vtpb.CloneVT()
		} else {
			r.OptionalBytesWrapper = proto.Clone(rhs).(*wrapperspb.BytesValue)
		}
	}
	if rhs := m.RepeatedBoolWrapper; rhs != nil {
		tmpContainer := make([]*wrapperspb.BoolValue, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *wrapperspb.BoolValue }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*wrapperspb.BoolValue)
			}
		}
		r.RepeatedBoolWrapper = tmpContainer
	}
	if rhs := m.RepeatedInt32Wrapper; rhs != nil {
		tmpContainer := make([]*wrapperspb.Int32Value, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *wrapperspb.Int32Value }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*wrapperspb.Int32Value)
			}
		}
		r.RepeatedInt32Wrapper = tmpContainer
	}
	if rhs := m.RepeatedInt64Wrapper; rhs != nil {
		tmpContainer := make([]*wrapperspb.Int64Value, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *wrapperspb.Int64Value }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*wrapperspb.Int64Value)
			}
		}
		r.RepeatedInt64Wrapper = tmpContainer
	}
	if rhs := m.RepeatedUint32Wrapper; rhs != nil {
		tmpContainer := make([]*wrapperspb.UInt32Value, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface {
				CloneVT() *wrapperspb.UInt32Value
			}); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*wrapperspb.UInt32Value)
			}
		}
		r.RepeatedUint32Wrapper = tmpContainer
	}
	if rhs := m.RepeatedUint64Wrapper; rhs != nil {
		tmpContainer := make([]*wrapperspb.UInt64Value, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface {
				CloneVT() *wrapperspb.UInt64Value
			}); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*wrapperspb.UInt64Value)
			}
		}
		r.RepeatedUint64Wrapper = tmpContainer
	}
	if rhs := m.RepeatedFloatWrapper; rhs != nil {
		tmpContainer := make([]*wrapperspb.FloatValue, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *wrapperspb.FloatValue }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*wrapperspb.FloatValue)
			}
		}
		r.RepeatedFloatWrapper = tmpContainer
	}
	if rhs := m.RepeatedDoubleWrapper; rhs != nil {
		tmpContainer := make([]*wrapperspb.DoubleValue, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface {
				CloneVT() *wrapperspb.DoubleValue
			}); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*wrapperspb.DoubleValue)
			}
		}
		r.RepeatedDoubleWrapper = tmpContainer
	}
	if rhs := m.RepeatedStringWrapper; rhs != nil {
		tmpContainer := make([]*wrapperspb.StringValue, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface {
				CloneVT() *wrapperspb.StringValue
			}); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*wrapperspb.StringValue)
			}
		}
		r.RepeatedStringWrapper = tmpContainer
	}
	if rhs := m.RepeatedBytesWrapper; rhs != nil {
		tmpContainer := make([]*wrapperspb.BytesValue, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *wrapperspb.BytesValue }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*wrapperspb.BytesValue)
			}
		}
		r.RepeatedBytesWrapper = tmpContainer
	}
	if rhs := m.OptionalDuration; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *durationpb.Duration }); ok {
			r.OptionalDuration = vtpb.CloneVT()
		} else {
			r.OptionalDuration = proto.Clone(rhs).(*durationpb.Duration)
		}
	}
	if rhs := m.OptionalTimestamp; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *timestamppb.Timestamp }); ok {
			r.OptionalTimestamp = vtpb.CloneVT()
		} else {
			r.OptionalTimestamp = proto.Clone(rhs).(*timestamppb.Timestamp)
		}
	}
	if rhs := m.OptionalFieldMask; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *fieldmaskpb.FieldMask }); ok {
			r.OptionalFieldMask = vtpb.CloneVT()
		} else {
			r.OptionalFieldMask = proto.Clone(rhs).(*fieldmaskpb.FieldMask)
		}
	}
	if rhs := m.OptionalStruct; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *structpb.Struct }); ok {
			r.OptionalStruct = vtpb.CloneVT()
		} else {
			r.OptionalStruct = proto.Clone(rhs).(*structpb.Struct)
		}
	}
	if rhs := m.OptionalAny; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *anypb.Any }); ok {
			r.OptionalAny = vtpb.CloneVT()
		} else {
			r.OptionalAny = proto.Clone(rhs).(*anypb.Any)
		}
	}
	if rhs := m.OptionalValue; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *structpb.Value }); ok {
			r.OptionalValue = vtpb.CloneVT()
		} else {
			r.OptionalValue = proto.Clone(rhs).(*structpb.Value)
		}
	}
	if rhs := m.RepeatedDuration; rhs != nil {
		tmpContainer := make([]*durationpb.Duration, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *durationpb.Duration }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*durationpb.Duration)
			}
		}
		r.RepeatedDuration = tmpContainer
	}
	if rhs := m.RepeatedTimestamp; rhs != nil {
		tmpContainer := make([]*timestamppb.Timestamp, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *timestamppb.Timestamp }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*timestamppb.Timestamp)
			}
		}
		r.RepeatedTimestamp = tmpContainer
	}
	if rhs := m.RepeatedFieldmask; rhs != nil {
		tmpContainer := make([]*fieldmaskpb.FieldMask, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *fieldmaskpb.FieldMask }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*fieldmaskpb.FieldMask)
			}
		}
		r.RepeatedFieldmask = tmpContainer
	}
	if rhs := m.RepeatedStruct; rhs != nil {
		tmpContainer := make([]*structpb.Struct, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *structpb.Struct }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*structpb.Struct)
			}
		}
		r.RepeatedStruct = tmpContainer
	}
	if rhs := m.RepeatedAny; rhs != nil {
		tmpContainer := make([]*anypb.Any, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *anypb.Any }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*anypb.Any)
			}
		}
		r.RepeatedAny = tmpContainer
	}
	if rhs := m.RepeatedValue; rhs != nil {
		tmpContainer := make([]*structpb.Value, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *structpb.Value }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*structpb.Value)
			}
		}
		r.RepeatedValue = tmpContainer
	}
	if rhs := m.RepeatedListValue; rhs != nil {
		tmpContainer := make([]*structpb.ListValue, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *structpb.ListValue }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*structpb.ListValue)
			}
		}
		r.RepeatedListValue = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *TestAllTypesProto3) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

// Deprecated: use CloneMessageVT instead
func (m *TestAllTypesProto3) CloneGenericVT() proto.Message {
	return m.CloneMessageVT()
}

func (m *TestAllTypesProto3_OneofUint32) CloneVT() isTestAllTypesProto3_OneofField {
	if m == nil {
		return (*TestAllTypesProto3_OneofUint32)(nil)
	}
	r := &TestAllTypesProto3_OneofUint32{
		OneofUint32: m.OneofUint32,
	}
	return r
}

func (m *TestAllTypesProto3_OneofNestedMessage) CloneVT() isTestAllTypesProto3_OneofField {
	if m == nil {
		return (*TestAllTypesProto3_OneofNestedMessage)(nil)
	}
	r := &TestAllTypesProto3_OneofNestedMessage{
		OneofNestedMessage: m.OneofNestedMessage.CloneVT(),
	}
	return r
}

func (m *TestAllTypesProto3_OneofString) CloneVT() isTestAllTypesProto3_OneofField {
	if m == nil {
		return (*TestAllTypesProto3_OneofString)(nil)
	}
	r := &TestAllTypesProto3_OneofString{
		OneofString: m.OneofString,
	}
	return r
}

func (m *TestAllTypesProto3_OneofBytes) CloneVT() isTestAllTypesProto3_OneofField {
	if m == nil {
		return (*TestAllTypesProto3_OneofBytes)(nil)
	}
	r := &TestAllTypesProto3_OneofBytes{}
	if rhs := m.OneofBytes; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.OneofBytes = tmpBytes
	}
	return r
}

func (m *TestAllTypesProto3_OneofBool) CloneVT() isTestAllTypesProto3_OneofField {
	if m == nil {
		return (*TestAllTypesProto3_OneofBool)(nil)
	}
	r := &TestAllTypesProto3_OneofBool{
		OneofBool: m.OneofBool,
	}
	return r
}

func (m *TestAllTypesProto3_OneofUint64) CloneVT() isTestAllTypesProto3_OneofField {
	if m == nil {
		return (*TestAllTypesProto3_OneofUint64)(nil)
	}
	r := &TestAllTypesProto3_OneofUint64{
		OneofUint64: m.OneofUint64,
	}
	return r
}

func (m *TestAllTypesProto3_OneofFloat) CloneVT() isTestAllTypesProto3_OneofField {
	if m == nil {
		return (*TestAllTypesProto3_OneofFloat)(nil)
	}
	r := &TestAllTypesProto3_OneofFloat{
		OneofFloat: m.OneofFloat,
	}
	return r
}

func (m *TestAllTypesProto3_OneofDouble) CloneVT() isTestAllTypesProto3_OneofField {
	if m == nil {
		return (*TestAllTypesProto3_OneofDouble)(nil)
	}
	r := &TestAllTypesProto3_OneofDouble{
		OneofDouble: m.OneofDouble,
	}
	return r
}

func (m *TestAllTypesProto3_OneofEnum) CloneVT() isTestAllTypesProto3_OneofField {
	if m == nil {
		return (*TestAllTypesProto3_OneofEnum)(nil)
	}
	r := &TestAllTypesProto3_OneofEnum{
		OneofEnum: m.OneofEnum,
	}
	return r
}

func (m *TestAllTypesProto3_OneofNullValue) CloneVT() isTestAllTypesProto3_OneofField {
	if m == nil {
		return (*TestAllTypesProto3_OneofNullValue)(nil)
	}
	r := &TestAllTypesProto3_OneofNullValue{
		OneofNullValue: m.OneofNullValue,
	}
	return r
}

func (m *ForeignMessage) CloneVT() *ForeignMessage {
	if m == nil {
		return (*ForeignMessage)(nil)
	}
	r := &ForeignMessage{
		C: m.C,
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ForeignMessage) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

// Deprecated: use CloneMessageVT instead
func (m *ForeignMessage) CloneGenericVT() proto.Message {
	return m.CloneMessageVT()
}

func (m *NullHypothesisProto3) CloneVT() *NullHypothesisProto3 {
	if m == nil {
		return (*NullHypothesisProto3)(nil)
	}
	r := &NullHypothesisProto3{}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *NullHypothesisProto3) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

// Deprecated: use CloneMessageVT instead
func (m *NullHypothesisProto3) CloneGenericVT() proto.Message {
	return m.CloneMessageVT()
}

func (m *EnumOnlyProto3) CloneVT() *EnumOnlyProto3 {
	if m == nil {
		return (*EnumOnlyProto3)(nil)
	}
	r := &EnumOnlyProto3{}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *EnumOnlyProto3) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

// Deprecated: use CloneMessageVT instead
func (m *EnumOnlyProto3) CloneGenericVT() proto.Message {
	return m.CloneMessageVT()
}

func (this *TestAllTypesProto3_NestedMessage) EqualVT(that *TestAllTypesProto3_NestedMessage) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.A != that.A {
		return false
	}
	if !this.Corecursive.EqualVT(that.Corecursive) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *TestAllTypesProto3_NestedMessage) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*TestAllTypesProto3_NestedMessage)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *TestAllTypesProto3) EqualVT(that *TestAllTypesProto3) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.OneofField == nil && that.OneofField != nil {
		return false
	} else if this.OneofField != nil {
		if that.OneofField == nil {
			return false
		}
		if !this.OneofField.(interface {
			EqualVT(isTestAllTypesProto3_OneofField) bool
		}).EqualVT(that.OneofField) {
			return false
		}
	}
	if this.OptionalInt32 != that.OptionalInt32 {
		return false
	}
	if this.OptionalInt64 != that.OptionalInt64 {
		return false
	}
	if this.OptionalUint32 != that.OptionalUint32 {
		return false
	}
	if this.OptionalUint64 != that.OptionalUint64 {
		return false
	}
	if this.OptionalSint32 != that.OptionalSint32 {
		return false
	}
	if this.OptionalSint64 != that.OptionalSint64 {
		return false
	}
	if this.OptionalFixed32 != that.OptionalFixed32 {
		return false
	}
	if this.OptionalFixed64 != that.OptionalFixed64 {
		return false
	}
	if this.OptionalSfixed32 != that.OptionalSfixed32 {
		return false
	}
	if this.OptionalSfixed64 != that.OptionalSfixed64 {
		return false
	}
	if this.OptionalFloat != that.OptionalFloat {
		return false
	}
	if this.OptionalDouble != that.OptionalDouble {
		return false
	}
	if this.OptionalBool != that.OptionalBool {
		return false
	}
	if this.OptionalString != that.OptionalString {
		return false
	}
	if string(this.OptionalBytes) != string(that.OptionalBytes) {
		return false
	}
	if !this.OptionalNestedMessage.EqualVT(that.OptionalNestedMessage) {
		return false
	}
	if !this.OptionalForeignMessage.EqualVT(that.OptionalForeignMessage) {
		return false
	}
	if this.OptionalNestedEnum != that.OptionalNestedEnum {
		return false
	}
	if this.OptionalForeignEnum != that.OptionalForeignEnum {
		return false
	}
	if this.OptionalAliasedEnum != that.OptionalAliasedEnum {
		return false
	}
	if this.OptionalStringPiece != that.OptionalStringPiece {
		return false
	}
	if this.OptionalCord != that.OptionalCord {
		return false
	}
	if !this.RecursiveMessage.EqualVT(that.RecursiveMessage) {
		return false
	}
	if len(this.RepeatedInt32) != len(that.RepeatedInt32) {
		return false
	}
	for i, vx := range this.RepeatedInt32 {
		vy := that.RepeatedInt32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedInt64) != len(that.RepeatedInt64) {
		return false
	}
	for i, vx := range this.RepeatedInt64 {
		vy := that.RepeatedInt64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedUint32) != len(that.RepeatedUint32) {
		return false
	}
	for i, vx := range this.RepeatedUint32 {
		vy := that.RepeatedUint32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedUint64) != len(that.RepeatedUint64) {
		return false
	}
	for i, vx := range this.RepeatedUint64 {
		vy := that.RepeatedUint64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedSint32) != len(that.RepeatedSint32) {
		return false
	}
	for i, vx := range this.RepeatedSint32 {
		vy := that.RepeatedSint32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedSint64) != len(that.RepeatedSint64) {
		return false
	}
	for i, vx := range this.RepeatedSint64 {
		vy := that.RepeatedSint64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedFixed32) != len(that.RepeatedFixed32) {
		return false
	}
	for i, vx := range this.RepeatedFixed32 {
		vy := that.RepeatedFixed32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedFixed64) != len(that.RepeatedFixed64) {
		return false
	}
	for i, vx := range this.RepeatedFixed64 {
		vy := that.RepeatedFixed64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedSfixed32) != len(that.RepeatedSfixed32) {
		return false
	}
	for i, vx := range this.RepeatedSfixed32 {
		vy := that.RepeatedSfixed32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedSfixed64) != len(that.RepeatedSfixed64) {
		return false
	}
	for i, vx := range this.RepeatedSfixed64 {
		vy := that.RepeatedSfixed64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedFloat) != len(that.RepeatedFloat) {
		return false
	}
	for i, vx := range this.RepeatedFloat {
		vy := that.RepeatedFloat[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedDouble) != len(that.RepeatedDouble) {
		return false
	}
	for i, vx := range this.RepeatedDouble {
		vy := that.RepeatedDouble[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedBool) != len(that.RepeatedBool) {
		return false
	}
	for i, vx := range this.RepeatedBool {
		vy := that.RepeatedBool[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedString) != len(that.RepeatedString) {
		return false
	}
	for i, vx := range this.RepeatedString {
		vy := that.RepeatedString[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedBytes) != len(that.RepeatedBytes) {
		return false
	}
	for i, vx := range this.RepeatedBytes {
		vy := that.RepeatedBytes[i]
		if string(vx) != string(vy) {
			return false
		}
	}
	if len(this.RepeatedNestedMessage) != len(that.RepeatedNestedMessage) {
		return false
	}
	for i, vx := range this.RepeatedNestedMessage {
		vy := that.RepeatedNestedMessage[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &TestAllTypesProto3_NestedMessage{}
			}
			if q == nil {
				q = &TestAllTypesProto3_NestedMessage{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.RepeatedForeignMessage) != len(that.RepeatedForeignMessage) {
		return false
	}
	for i, vx := range this.RepeatedForeignMessage {
		vy := that.RepeatedForeignMessage[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ForeignMessage{}
			}
			if q == nil {
				q = &ForeignMessage{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.RepeatedNestedEnum) != len(that.RepeatedNestedEnum) {
		return false
	}
	for i, vx := range this.RepeatedNestedEnum {
		vy := that.RepeatedNestedEnum[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedForeignEnum) != len(that.RepeatedForeignEnum) {
		return false
	}
	for i, vx := range this.RepeatedForeignEnum {
		vy := that.RepeatedForeignEnum[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedStringPiece) != len(that.RepeatedStringPiece) {
		return false
	}
	for i, vx := range this.RepeatedStringPiece {
		vy := that.RepeatedStringPiece[i]
		if vx != vy {
			return false
		}
	}
	if len(this.RepeatedCord) != len(that.RepeatedCord) {
		return false
	}
	for i, vx := range this.RepeatedCord {
		vy := that.RepeatedCord[i]
		if vx != vy {
			return false
		}
	}
	if len(this.MapInt32Int32) != len(that.MapInt32Int32) {
		return false
	}
	for i, vx := range this.MapInt32Int32 {
		vy, ok := that.MapInt32Int32[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapInt64Int64) != len(that.MapInt64Int64) {
		return false
	}
	for i, vx := range this.MapInt64Int64 {
		vy, ok := that.MapInt64Int64[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapUint32Uint32) != len(that.MapUint32Uint32) {
		return false
	}
	for i, vx := range this.MapUint32Uint32 {
		vy, ok := that.MapUint32Uint32[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapUint64Uint64) != len(that.MapUint64Uint64) {
		return false
	}
	for i, vx := range this.MapUint64Uint64 {
		vy, ok := that.MapUint64Uint64[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapSint32Sint32) != len(that.MapSint32Sint32) {
		return false
	}
	for i, vx := range this.MapSint32Sint32 {
		vy, ok := that.MapSint32Sint32[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapSint64Sint64) != len(that.MapSint64Sint64) {
		return false
	}
	for i, vx := range this.MapSint64Sint64 {
		vy, ok := that.MapSint64Sint64[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapFixed32Fixed32) != len(that.MapFixed32Fixed32) {
		return false
	}
	for i, vx := range this.MapFixed32Fixed32 {
		vy, ok := that.MapFixed32Fixed32[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapFixed64Fixed64) != len(that.MapFixed64Fixed64) {
		return false
	}
	for i, vx := range this.MapFixed64Fixed64 {
		vy, ok := that.MapFixed64Fixed64[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapSfixed32Sfixed32) != len(that.MapSfixed32Sfixed32) {
		return false
	}
	for i, vx := range this.MapSfixed32Sfixed32 {
		vy, ok := that.MapSfixed32Sfixed32[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapSfixed64Sfixed64) != len(that.MapSfixed64Sfixed64) {
		return false
	}
	for i, vx := range this.MapSfixed64Sfixed64 {
		vy, ok := that.MapSfixed64Sfixed64[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapInt32Float) != len(that.MapInt32Float) {
		return false
	}
	for i, vx := range this.MapInt32Float {
		vy, ok := that.MapInt32Float[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapInt32Double) != len(that.MapInt32Double) {
		return false
	}
	for i, vx := range this.MapInt32Double {
		vy, ok := that.MapInt32Double[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapBoolBool) != len(that.MapBoolBool) {
		return false
	}
	for i, vx := range this.MapBoolBool {
		vy, ok := that.MapBoolBool[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapStringString) != len(that.MapStringString) {
		return false
	}
	for i, vx := range this.MapStringString {
		vy, ok := that.MapStringString[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapStringBytes) != len(that.MapStringBytes) {
		return false
	}
	for i, vx := range this.MapStringBytes {
		vy, ok := that.MapStringBytes[i]
		if !ok {
			return false
		}
		if string(vx) != string(vy) {
			return false
		}
	}
	if len(this.MapStringNestedMessage) != len(that.MapStringNestedMessage) {
		return false
	}
	for i, vx := range this.MapStringNestedMessage {
		vy, ok := that.MapStringNestedMessage[i]
		if !ok {
			return false
		}
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &TestAllTypesProto3_NestedMessage{}
			}
			if q == nil {
				q = &TestAllTypesProto3_NestedMessage{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.MapStringForeignMessage) != len(that.MapStringForeignMessage) {
		return false
	}
	for i, vx := range this.MapStringForeignMessage {
		vy, ok := that.MapStringForeignMessage[i]
		if !ok {
			return false
		}
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ForeignMessage{}
			}
			if q == nil {
				q = &ForeignMessage{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.MapStringNestedEnum) != len(that.MapStringNestedEnum) {
		return false
	}
	for i, vx := range this.MapStringNestedEnum {
		vy, ok := that.MapStringNestedEnum[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.MapStringForeignEnum) != len(that.MapStringForeignEnum) {
		return false
	}
	for i, vx := range this.MapStringForeignEnum {
		vy, ok := that.MapStringForeignEnum[i]
		if !ok {
			return false
		}
		if vx != vy {
			return false
		}
	}
	if len(this.PackedInt32) != len(that.PackedInt32) {
		return false
	}
	for i, vx := range this.PackedInt32 {
		vy := that.PackedInt32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedInt64) != len(that.PackedInt64) {
		return false
	}
	for i, vx := range this.PackedInt64 {
		vy := that.PackedInt64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedUint32) != len(that.PackedUint32) {
		return false
	}
	for i, vx := range this.PackedUint32 {
		vy := that.PackedUint32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedUint64) != len(that.PackedUint64) {
		return false
	}
	for i, vx := range this.PackedUint64 {
		vy := that.PackedUint64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedSint32) != len(that.PackedSint32) {
		return false
	}
	for i, vx := range this.PackedSint32 {
		vy := that.PackedSint32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedSint64) != len(that.PackedSint64) {
		return false
	}
	for i, vx := range this.PackedSint64 {
		vy := that.PackedSint64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedFixed32) != len(that.PackedFixed32) {
		return false
	}
	for i, vx := range this.PackedFixed32 {
		vy := that.PackedFixed32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedFixed64) != len(that.PackedFixed64) {
		return false
	}
	for i, vx := range this.PackedFixed64 {
		vy := that.PackedFixed64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedSfixed32) != len(that.PackedSfixed32) {
		return false
	}
	for i, vx := range this.PackedSfixed32 {
		vy := that.PackedSfixed32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedSfixed64) != len(that.PackedSfixed64) {
		return false
	}
	for i, vx := range this.PackedSfixed64 {
		vy := that.PackedSfixed64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedFloat) != len(that.PackedFloat) {
		return false
	}
	for i, vx := range this.PackedFloat {
		vy := that.PackedFloat[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedDouble) != len(that.PackedDouble) {
		return false
	}
	for i, vx := range this.PackedDouble {
		vy := that.PackedDouble[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedBool) != len(that.PackedBool) {
		return false
	}
	for i, vx := range this.PackedBool {
		vy := that.PackedBool[i]
		if vx != vy {
			return false
		}
	}
	if len(this.PackedNestedEnum) != len(that.PackedNestedEnum) {
		return false
	}
	for i, vx := range this.PackedNestedEnum {
		vy := that.PackedNestedEnum[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedInt32) != len(that.UnpackedInt32) {
		return false
	}
	for i, vx := range this.UnpackedInt32 {
		vy := that.UnpackedInt32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedInt64) != len(that.UnpackedInt64) {
		return false
	}
	for i, vx := range this.UnpackedInt64 {
		vy := that.UnpackedInt64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedUint32) != len(that.UnpackedUint32) {
		return false
	}
	for i, vx := range this.UnpackedUint32 {
		vy := that.UnpackedUint32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedUint64) != len(that.UnpackedUint64) {
		return false
	}
	for i, vx := range this.UnpackedUint64 {
		vy := that.UnpackedUint64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedSint32) != len(that.UnpackedSint32) {
		return false
	}
	for i, vx := range this.UnpackedSint32 {
		vy := that.UnpackedSint32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedSint64) != len(that.UnpackedSint64) {
		return false
	}
	for i, vx := range this.UnpackedSint64 {
		vy := that.UnpackedSint64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedFixed32) != len(that.UnpackedFixed32) {
		return false
	}
	for i, vx := range this.UnpackedFixed32 {
		vy := that.UnpackedFixed32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedFixed64) != len(that.UnpackedFixed64) {
		return false
	}
	for i, vx := range this.UnpackedFixed64 {
		vy := that.UnpackedFixed64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedSfixed32) != len(that.UnpackedSfixed32) {
		return false
	}
	for i, vx := range this.UnpackedSfixed32 {
		vy := that.UnpackedSfixed32[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedSfixed64) != len(that.UnpackedSfixed64) {
		return false
	}
	for i, vx := range this.UnpackedSfixed64 {
		vy := that.UnpackedSfixed64[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedFloat) != len(that.UnpackedFloat) {
		return false
	}
	for i, vx := range this.UnpackedFloat {
		vy := that.UnpackedFloat[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedDouble) != len(that.UnpackedDouble) {
		return false
	}
	for i, vx := range this.UnpackedDouble {
		vy := that.UnpackedDouble[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedBool) != len(that.UnpackedBool) {
		return false
	}
	for i, vx := range this.UnpackedBool {
		vy := that.UnpackedBool[i]
		if vx != vy {
			return false
		}
	}
	if len(this.UnpackedNestedEnum) != len(that.UnpackedNestedEnum) {
		return false
	}
	for i, vx := range this.UnpackedNestedEnum {
		vy := that.UnpackedNestedEnum[i]
		if vx != vy {
			return false
		}
	}
	if equal, ok := interface{}(this.OptionalBoolWrapper).(interface {
		EqualVT(*wrapperspb.BoolValue) bool
	}); ok {
		if !equal.EqualVT(that.OptionalBoolWrapper) {
			return false
		}
	} else if !proto.Equal(this.OptionalBoolWrapper, that.OptionalBoolWrapper) {
		return false
	}
	if equal, ok := interface{}(this.OptionalInt32Wrapper).(interface {
		EqualVT(*wrapperspb.Int32Value) bool
	}); ok {
		if !equal.EqualVT(that.OptionalInt32Wrapper) {
			return false
		}
	} else if !proto.Equal(this.OptionalInt32Wrapper, that.OptionalInt32Wrapper) {
		return false
	}
	if equal, ok := interface{}(this.OptionalInt64Wrapper).(interface {
		EqualVT(*wrapperspb.Int64Value) bool
	}); ok {
		if !equal.EqualVT(that.OptionalInt64Wrapper) {
			return false
		}
	} else if !proto.Equal(this.OptionalInt64Wrapper, that.OptionalInt64Wrapper) {
		return false
	}
	if equal, ok := interface{}(this.OptionalUint32Wrapper).(interface {
		EqualVT(*wrapperspb.UInt32Value) bool
	}); ok {
		if !equal.EqualVT(that.OptionalUint32Wrapper) {
			return false
		}
	} else if !proto.Equal(this.OptionalUint32Wrapper, that.OptionalUint32Wrapper) {
		return false
	}
	if equal, ok := interface{}(this.OptionalUint64Wrapper).(interface {
		EqualVT(*wrapperspb.UInt64Value) bool
	}); ok {
		if !equal.EqualVT(that.OptionalUint64Wrapper) {
			return false
		}
	} else if !proto.Equal(this.OptionalUint64Wrapper, that.OptionalUint64Wrapper) {
		return false
	}
	if equal, ok := interface{}(this.OptionalFloatWrapper).(interface {
		EqualVT(*wrapperspb.FloatValue) bool
	}); ok {
		if !equal.EqualVT(that.OptionalFloatWrapper) {
			return false
		}
	} else if !proto.Equal(this.OptionalFloatWrapper, that.OptionalFloatWrapper) {
		return false
	}
	if equal, ok := interface{}(this.OptionalDoubleWrapper).(interface {
		EqualVT(*wrapperspb.DoubleValue) bool
	}); ok {
		if !equal.EqualVT(that.OptionalDoubleWrapper) {
			return false
		}
	} else if !proto.Equal(this.OptionalDoubleWrapper, that.OptionalDoubleWrapper) {
		return false
	}
	if equal, ok := interface{}(this.OptionalStringWrapper).(interface {
		EqualVT(*wrapperspb.StringValue) bool
	}); ok {
		if !equal.EqualVT(that.OptionalStringWrapper) {
			return false
		}
	} else if !proto.Equal(this.OptionalStringWrapper, that.OptionalStringWrapper) {
		return false
	}
	if equal, ok := interface{}(this.OptionalBytesWrapper).(interface {
		EqualVT(*wrapperspb.BytesValue) bool
	}); ok {
		if !equal.EqualVT(that.OptionalBytesWrapper) {
			return false
		}
	} else if !proto.Equal(this.OptionalBytesWrapper, that.OptionalBytesWrapper) {
		return false
	}
	if len(this.RepeatedBoolWrapper) != len(that.RepeatedBoolWrapper) {
		return false
	}
	for i, vx := range this.RepeatedBoolWrapper {
		vy := that.RepeatedBoolWrapper[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &wrapperspb.BoolValue{}
			}
			if q == nil {
				q = &wrapperspb.BoolValue{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*wrapperspb.BoolValue) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedInt32Wrapper) != len(that.RepeatedInt32Wrapper) {
		return false
	}
	for i, vx := range this.RepeatedInt32Wrapper {
		vy := that.RepeatedInt32Wrapper[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &wrapperspb.Int32Value{}
			}
			if q == nil {
				q = &wrapperspb.Int32Value{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*wrapperspb.Int32Value) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedInt64Wrapper) != len(that.RepeatedInt64Wrapper) {
		return false
	}
	for i, vx := range this.RepeatedInt64Wrapper {
		vy := that.RepeatedInt64Wrapper[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &wrapperspb.Int64Value{}
			}
			if q == nil {
				q = &wrapperspb.Int64Value{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*wrapperspb.Int64Value) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedUint32Wrapper) != len(that.RepeatedUint32Wrapper) {
		return false
	}
	for i, vx := range this.RepeatedUint32Wrapper {
		vy := that.RepeatedUint32Wrapper[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &wrapperspb.UInt32Value{}
			}
			if q == nil {
				q = &wrapperspb.UInt32Value{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*wrapperspb.UInt32Value) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedUint64Wrapper) != len(that.RepeatedUint64Wrapper) {
		return false
	}
	for i, vx := range this.RepeatedUint64Wrapper {
		vy := that.RepeatedUint64Wrapper[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &wrapperspb.UInt64Value{}
			}
			if q == nil {
				q = &wrapperspb.UInt64Value{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*wrapperspb.UInt64Value) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedFloatWrapper) != len(that.RepeatedFloatWrapper) {
		return false
	}
	for i, vx := range this.RepeatedFloatWrapper {
		vy := that.RepeatedFloatWrapper[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &wrapperspb.FloatValue{}
			}
			if q == nil {
				q = &wrapperspb.FloatValue{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*wrapperspb.FloatValue) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedDoubleWrapper) != len(that.RepeatedDoubleWrapper) {
		return false
	}
	for i, vx := range this.RepeatedDoubleWrapper {
		vy := that.RepeatedDoubleWrapper[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &wrapperspb.DoubleValue{}
			}
			if q == nil {
				q = &wrapperspb.DoubleValue{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*wrapperspb.DoubleValue) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedStringWrapper) != len(that.RepeatedStringWrapper) {
		return false
	}
	for i, vx := range this.RepeatedStringWrapper {
		vy := that.RepeatedStringWrapper[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &wrapperspb.StringValue{}
			}
			if q == nil {
				q = &wrapperspb.StringValue{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*wrapperspb.StringValue) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedBytesWrapper) != len(that.RepeatedBytesWrapper) {
		return false
	}
	for i, vx := range this.RepeatedBytesWrapper {
		vy := that.RepeatedBytesWrapper[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &wrapperspb.BytesValue{}
			}
			if q == nil {
				q = &wrapperspb.BytesValue{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*wrapperspb.BytesValue) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if equal, ok := interface{}(this.OptionalDuration).(interface {
		EqualVT(*durationpb.Duration) bool
	}); ok {
		if !equal.EqualVT(that.OptionalDuration) {
			return false
		}
	} else if !proto.Equal(this.OptionalDuration, that.OptionalDuration) {
		return false
	}
	if equal, ok := interface{}(this.OptionalTimestamp).(interface {
		EqualVT(*timestamppb.Timestamp) bool
	}); ok {
		if !equal.EqualVT(that.OptionalTimestamp) {
			return false
		}
	} else if !proto.Equal(this.OptionalTimestamp, that.OptionalTimestamp) {
		return false
	}
	if equal, ok := interface{}(this.OptionalFieldMask).(interface {
		EqualVT(*fieldmaskpb.FieldMask) bool
	}); ok {
		if !equal.EqualVT(that.OptionalFieldMask) {
			return false
		}
	} else if !proto.Equal(this.OptionalFieldMask, that.OptionalFieldMask) {
		return false
	}
	if equal, ok := interface{}(this.OptionalStruct).(interface{ EqualVT(*structpb.Struct) bool }); ok {
		if !equal.EqualVT(that.OptionalStruct) {
			return false
		}
	} else if !proto.Equal(this.OptionalStruct, that.OptionalStruct) {
		return false
	}
	if equal, ok := interface{}(this.OptionalAny).(interface{ EqualVT(*anypb.Any) bool }); ok {
		if !equal.EqualVT(that.OptionalAny) {
			return false
		}
	} else if !proto.Equal(this.OptionalAny, that.OptionalAny) {
		return false
	}
	if equal, ok := interface{}(this.OptionalValue).(interface{ EqualVT(*structpb.Value) bool }); ok {
		if !equal.EqualVT(that.OptionalValue) {
			return false
		}
	} else if !proto.Equal(this.OptionalValue, that.OptionalValue) {
		return false
	}
	if this.OptionalNullValue != that.OptionalNullValue {
		return false
	}
	if len(this.RepeatedDuration) != len(that.RepeatedDuration) {
		return false
	}
	for i, vx := range this.RepeatedDuration {
		vy := that.RepeatedDuration[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &durationpb.Duration{}
			}
			if q == nil {
				q = &durationpb.Duration{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*durationpb.Duration) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedTimestamp) != len(that.RepeatedTimestamp) {
		return false
	}
	for i, vx := range this.RepeatedTimestamp {
		vy := that.RepeatedTimestamp[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &timestamppb.Timestamp{}
			}
			if q == nil {
				q = &timestamppb.Timestamp{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*timestamppb.Timestamp) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedFieldmask) != len(that.RepeatedFieldmask) {
		return false
	}
	for i, vx := range this.RepeatedFieldmask {
		vy := that.RepeatedFieldmask[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &fieldmaskpb.FieldMask{}
			}
			if q == nil {
				q = &fieldmaskpb.FieldMask{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*fieldmaskpb.FieldMask) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedAny) != len(that.RepeatedAny) {
		return false
	}
	for i, vx := range this.RepeatedAny {
		vy := that.RepeatedAny[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &anypb.Any{}
			}
			if q == nil {
				q = &anypb.Any{}
			}
			if equal, ok := interface{}(p).(interface{ EqualVT(*anypb.Any) bool }); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedValue) != len(that.RepeatedValue) {
		return false
	}
	for i, vx := range this.RepeatedValue {
		vy := that.RepeatedValue[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &structpb.Value{}
			}
			if q == nil {
				q = &structpb.Value{}
			}
			if equal, ok := interface{}(p).(interface{ EqualVT(*structpb.Value) bool }); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedListValue) != len(that.RepeatedListValue) {
		return false
	}
	for i, vx := range this.RepeatedListValue {
		vy := that.RepeatedListValue[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &structpb.ListValue{}
			}
			if q == nil {
				q = &structpb.ListValue{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*structpb.ListValue) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.RepeatedStruct) != len(that.RepeatedStruct) {
		return false
	}
	for i, vx := range this.RepeatedStruct {
		vy := that.RepeatedStruct[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &structpb.Struct{}
			}
			if q == nil {
				q = &structpb.Struct{}
			}
			if equal, ok := interface{}(p).(interface{ EqualVT(*structpb.Struct) bool }); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if this.Fieldname1 != that.Fieldname1 {
		return false
	}
	if this.FieldName2 != that.FieldName2 {
		return false
	}
	if this.XFieldName3 != that.XFieldName3 {
		return false
	}
	if this.Field_Name4_ != that.Field_Name4_ {
		return false
	}
	if this.Field0Name5 != that.Field0Name5 {
		return false
	}
	if this.Field_0Name6 != that.Field_0Name6 {
		return false
	}
	if this.FieldName7 != that.FieldName7 {
		return false
	}
	if this.FieldName8 != that.FieldName8 {
		return false
	}
	if this.Field_Name9 != that.Field_Name9 {
		return false
	}
	if this.Field_Name10 != that.Field_Name10 {
		return false
	}
	if this.FIELD_NAME11 != that.FIELD_NAME11 {
		return false
	}
	if this.FIELDName12 != that.FIELDName12 {
		return false
	}
	if this.XFieldName13 != that.XFieldName13 {
		return false
	}
	if this.X_FieldName14 != that.X_FieldName14 {
		return false
	}
	if this.Field_Name15 != that.Field_Name15 {
		return false
	}
	if this.Field__Name16 != that.Field__Name16 {
		return false
	}
	if this.FieldName17__ != that.FieldName17__ {
		return false
	}
	if this.FieldName18__ != that.FieldName18__ {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *TestAllTypesProto3) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*TestAllTypesProto3)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *TestAllTypesProto3_OneofUint32) EqualVT(thatIface isTestAllTypesProto3_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto3_OneofUint32)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofUint32 != that.OneofUint32 {
		return false
	}
	return true
}

func (this *TestAllTypesProto3_OneofNestedMessage) EqualVT(thatIface isTestAllTypesProto3_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto3_OneofNestedMessage)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.OneofNestedMessage, that.OneofNestedMessage; p != q {
		if p == nil {
			p = &TestAllTypesProto3_NestedMessage{}
		}
		if q == nil {
			q = &TestAllTypesProto3_NestedMessage{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *TestAllTypesProto3_OneofString) EqualVT(thatIface isTestAllTypesProto3_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto3_OneofString)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofString != that.OneofString {
		return false
	}
	return true
}

func (this *TestAllTypesProto3_OneofBytes) EqualVT(thatIface isTestAllTypesProto3_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto3_OneofBytes)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if string(this.OneofBytes) != string(that.OneofBytes) {
		return false
	}
	return true
}

func (this *TestAllTypesProto3_OneofBool) EqualVT(thatIface isTestAllTypesProto3_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto3_OneofBool)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofBool != that.OneofBool {
		return false
	}
	return true
}

func (this *TestAllTypesProto3_OneofUint64) EqualVT(thatIface isTestAllTypesProto3_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto3_OneofUint64)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofUint64 != that.OneofUint64 {
		return false
	}
	return true
}

func (this *TestAllTypesProto3_OneofFloat) EqualVT(thatIface isTestAllTypesProto3_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto3_OneofFloat)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofFloat != that.OneofFloat {
		return false
	}
	return true
}

func (this *TestAllTypesProto3_OneofDouble) EqualVT(thatIface isTestAllTypesProto3_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto3_OneofDouble)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofDouble != that.OneofDouble {
		return false
	}
	return true
}

func (this *TestAllTypesProto3_OneofEnum) EqualVT(thatIface isTestAllTypesProto3_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto3_OneofEnum)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofEnum != that.OneofEnum {
		return false
	}
	return true
}

func (this *TestAllTypesProto3_OneofNullValue) EqualVT(thatIface isTestAllTypesProto3_OneofField) bool {
	that, ok := thatIface.(*TestAllTypesProto3_OneofNullValue)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.OneofNullValue != that.OneofNullValue {
		return false
	}
	return true
}

func (this *ForeignMessage) EqualVT(that *ForeignMessage) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.C != that.C {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ForeignMessage) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*ForeignMessage)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *NullHypothesisProto3) EqualVT(that *NullHypothesisProto3) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *NullHypothesisProto3) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*NullHypothesisProto3)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *EnumOnlyProto3) EqualVT(that *EnumOnlyProto3) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnumOnlyProto3) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*EnumOnlyProto3)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (m *TestAllTypesProto3_NestedMessage) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto3_NestedMessage) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_NestedMessage) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Corecursive != nil {
		size, err := m.Corecursive.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.A != 0 {
		i = encodeVarint(dAtA, i, uint64(m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto3) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypesProto3) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if vtmsg, ok := m.OneofField.(interface {
		MarshalToSizedBufferVT([]byte) (int, error)
	}); ok {
		size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if m.FieldName18__ != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FieldName18__))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x90
	}
	if m.FieldName17__ != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FieldName17__))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x88
	}
	if m.Field__Name16 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field__Name16))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x80
	}
	if m.Field_Name15 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field_Name15))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xf8
	}
	if m.X_FieldName14 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.X_FieldName14))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xf0
	}
	if m.XFieldName13 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.XFieldName13))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xe8
	}
	if m.FIELDName12 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FIELDName12))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xe0
	}
	if m.FIELD_NAME11 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FIELD_NAME11))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xd8
	}
	if m.Field_Name10 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field_Name10))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xd0
	}
	if m.Field_Name9 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field_Name9))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xc8
	}
	if m.FieldName8 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FieldName8))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xc0
	}
	if m.FieldName7 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FieldName7))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xb8
	}
	if m.Field_0Name6 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field_0Name6))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xb0
	}
	if m.Field0Name5 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field0Name5))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xa8
	}
	if m.Field_Name4_ != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Field_Name4_))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xa0
	}
	if m.XFieldName3 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.XFieldName3))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x98
	}
	if m.FieldName2 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.FieldName2))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x90
	}
	if m.Fieldname1 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Fieldname1))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x88
	}
	if len(m.RepeatedStruct) > 0 {
		for iNdEx := len(m.RepeatedStruct) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedStruct[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedStruct[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x14
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.RepeatedListValue) > 0 {
		for iNdEx := len(m.RepeatedListValue) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedListValue[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedListValue[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.RepeatedValue) > 0 {
		for iNdEx := len(m.RepeatedValue) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedValue[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedValue[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.RepeatedAny) > 0 {
		for iNdEx := len(m.RepeatedAny) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedAny[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedAny[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.RepeatedFieldmask) > 0 {
		for iNdEx := len(m.RepeatedFieldmask) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedFieldmask[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedFieldmask[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.RepeatedTimestamp) > 0 {
		for iNdEx := len(m.RepeatedTimestamp) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedTimestamp[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedTimestamp[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.RepeatedDuration) > 0 {
		for iNdEx := len(m.RepeatedDuration) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedDuration[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedDuration[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xba
		}
	}
	if m.OptionalNullValue != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalNullValue))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x98
	}
	if m.OptionalValue != nil {
		if vtmsg, ok := interface{}(m.OptionalValue).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalValue)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x92
	}
	if m.OptionalAny != nil {
		if vtmsg, ok := interface{}(m.OptionalAny).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalAny)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x8a
	}
	if m.OptionalStruct != nil {
		if vtmsg, ok := interface{}(m.OptionalStruct).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalStruct)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x82
	}
	if m.OptionalFieldMask != nil {
		if vtmsg, ok := interface{}(m.OptionalFieldMask).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalFieldMask)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xfa
	}
	if m.OptionalTimestamp != nil {
		if vtmsg, ok := interface{}(m.OptionalTimestamp).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalTimestamp)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xf2
	}
	if m.OptionalDuration != nil {
		if vtmsg, ok := interface{}(m.OptionalDuration).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalDuration)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xea
	}
	if len(m.RepeatedBytesWrapper) > 0 {
		for iNdEx := len(m.RepeatedBytesWrapper) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedBytesWrapper[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedBytesWrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.RepeatedStringWrapper) > 0 {
		for iNdEx := len(m.RepeatedStringWrapper) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedStringWrapper[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedStringWrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.RepeatedDoubleWrapper) > 0 {
		for iNdEx := len(m.RepeatedDoubleWrapper) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedDoubleWrapper[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedDoubleWrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.RepeatedFloatWrapper) > 0 {
		for iNdEx := len(m.RepeatedFloatWrapper) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedFloatWrapper[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedFloatWrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.RepeatedUint64Wrapper) > 0 {
		for iNdEx := len(m.RepeatedUint64Wrapper) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedUint64Wrapper[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedUint64Wrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.RepeatedUint32Wrapper) > 0 {
		for iNdEx := len(m.RepeatedUint32Wrapper) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedUint32Wrapper[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedUint32Wrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.RepeatedInt64Wrapper) > 0 {
		for iNdEx := len(m.RepeatedInt64Wrapper) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedInt64Wrapper[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedInt64Wrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.RepeatedInt32Wrapper) > 0 {
		for iNdEx := len(m.RepeatedInt32Wrapper) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedInt32Wrapper[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedInt32Wrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.RepeatedBoolWrapper) > 0 {
		for iNdEx := len(m.RepeatedBoolWrapper) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.RepeatedBoolWrapper[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.RepeatedBoolWrapper[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.OptionalBytesWrapper != nil {
		if vtmsg, ok := interface{}(m.OptionalBytesWrapper).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalBytesWrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x8a
	}
	if m.OptionalStringWrapper != nil {
		if vtmsg, ok := interface{}(m.OptionalStringWrapper).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalStringWrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x82
	}
	if m.OptionalDoubleWrapper != nil {
		if vtmsg, ok := interface{}(m.OptionalDoubleWrapper).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalDoubleWrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xfa
	}
	if m.OptionalFloatWrapper != nil {
		if vtmsg, ok := interface{}(m.OptionalFloatWrapper).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalFloatWrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xf2
	}
	if m.OptionalUint64Wrapper != nil {
		if vtmsg, ok := interface{}(m.OptionalUint64Wrapper).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalUint64Wrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xea
	}
	if m.OptionalUint32Wrapper != nil {
		if vtmsg, ok := interface{}(m.OptionalUint32Wrapper).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalUint32Wrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xe2
	}
	if m.OptionalInt64Wrapper != nil {
		if vtmsg, ok := interface{}(m.OptionalInt64Wrapper).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalInt64Wrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xda
	}
	if m.OptionalInt32Wrapper != nil {
		if vtmsg, ok := interface{}(m.OptionalInt32Wrapper).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalInt32Wrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd2
	}
	if m.OptionalBoolWrapper != nil {
		if vtmsg, ok := interface{}(m.OptionalBoolWrapper).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OptionalBoolWrapper)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xca
	}
	if len(m.UnpackedNestedEnum) > 0 {
		for iNdEx := len(m.UnpackedNestedEnum) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedNestedEnum[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xb0
		}
	}
	if len(m.UnpackedBool) > 0 {
		for iNdEx := len(m.UnpackedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.UnpackedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa8
		}
	}
	if len(m.UnpackedDouble) > 0 {
		for iNdEx := len(m.UnpackedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float64bits(float64(m.UnpackedDouble[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f1))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa1
		}
	}
	if len(m.UnpackedFloat) > 0 {
		for iNdEx := len(m.UnpackedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f2 := math.Float32bits(float32(m.UnpackedFloat[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f2))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x9d
		}
	}
	if len(m.UnpackedSfixed64) > 0 {
		for iNdEx := len(m.UnpackedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.UnpackedSfixed64[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x91
		}
	}
	if len(m.UnpackedSfixed32) > 0 {
		for iNdEx := len(m.UnpackedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.UnpackedSfixed32[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x8d
		}
	}
	if len(m.UnpackedFixed64) > 0 {
		for iNdEx := len(m.UnpackedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.UnpackedFixed64[iNdEx]))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x81
		}
	}
	if len(m.UnpackedFixed32) > 0 {
		for iNdEx := len(m.UnpackedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.UnpackedFixed32[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xfd
		}
	}
	if len(m.UnpackedSint64) > 0 {
		for iNdEx := len(m.UnpackedSint64) - 1; iNdEx >= 0; iNdEx-- {
			x3 := (uint64(m.UnpackedSint64[iNdEx]) << 1) ^ uint64((m.UnpackedSint64[iNdEx] >> 63))
			i = encodeVarint(dAtA, i, uint64(x3))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xf0
		}
	}
	if len(m.UnpackedSint32) > 0 {
		for iNdEx := len(m.UnpackedSint32) - 1; iNdEx >= 0; iNdEx-- {
			x4 := (uint32(m.UnpackedSint32[iNdEx]) << 1) ^ uint32((m.UnpackedSint32[iNdEx] >> 31))
			i = encodeVarint(dAtA, i, uint64(x4))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xe8
		}
	}
	if len(m.UnpackedUint64) > 0 {
		for iNdEx := len(m.UnpackedUint64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedUint64[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xe0
		}
	}
	if len(m.UnpackedUint32) > 0 {
		for iNdEx := len(m.UnpackedUint32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedUint32[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xd8
		}
	}
	if len(m.UnpackedInt64) > 0 {
		for iNdEx := len(m.UnpackedInt64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedInt64[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xd0
		}
	}
	if len(m.UnpackedInt32) > 0 {
		for iNdEx := len(m.UnpackedInt32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.UnpackedInt32[iNdEx]))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xc8
		}
	}
	if len(m.PackedNestedEnum) > 0 {
		var pksize6 int
		for _, num := range m.PackedNestedEnum {
			pksize6 += sov(uint64(num))
		}
		i -= pksize6
		j5 := i
		for _, num1 := range m.PackedNestedEnum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA[j5] = uint8(num)
			j5++
		}
		i = encodeVarint(dAtA, i, uint64(pksize6))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc2
	}
	if len(m.PackedBool) > 0 {
		for iNdEx := len(m.PackedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.PackedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedBool)))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xba
	}
	if len(m.PackedDouble) > 0 {
		for iNdEx := len(m.PackedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f7 := math.Float64bits(float64(m.PackedDouble[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f7))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedDouble)*8))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xb2
	}
	if len(m.PackedFloat) > 0 {
		for iNdEx := len(m.PackedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f8 := math.Float32bits(float32(m.PackedFloat[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f8))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedFloat)*4))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xaa
	}
	if len(m.PackedSfixed64) > 0 {
		for iNdEx := len(m.PackedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PackedSfixed64[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedSfixed64)*8))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xa2
	}
	if len(m.PackedSfixed32) > 0 {
		for iNdEx := len(m.PackedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.PackedSfixed32[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedSfixed32)*4))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x9a
	}
	if len(m.PackedFixed64) > 0 {
		for iNdEx := len(m.PackedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PackedFixed64[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedFixed64)*8))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x92
	}
	if len(m.PackedFixed32) > 0 {
		for iNdEx := len(m.PackedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.PackedFixed32[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.PackedFixed32)*4))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x8a
	}
	if len(m.PackedSint64) > 0 {
		var pksize10 int
		for _, num := range m.PackedSint64 {
			pksize10 += soz(uint64(num))
		}
		i -= pksize10
		j9 := i
		for _, num := range m.PackedSint64 {
			x11 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x11 >= 1<<7 {
				dAtA[j9] = uint8(uint64(x11)&0x7f | 0x80)
				j9++
				x11 >>= 7
			}
			dAtA[j9] = uint8(x11)
			j9++
		}
		i = encodeVarint(dAtA, i, uint64(pksize10))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x82
	}
	if len(m.PackedSint32) > 0 {
		var pksize13 int
		for _, num := range m.PackedSint32 {
			pksize13 += soz(uint64(num))
		}
		i -= pksize13
		j12 := i
		for _, num := range m.PackedSint32 {
			x14 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x14 >= 1<<7 {
				dAtA[j12] = uint8(uint64(x14)&0x7f | 0x80)
				j12++
				x14 >>= 7
			}
			dAtA[j12] = uint8(x14)
			j12++
		}
		i = encodeVarint(dAtA, i, uint64(pksize13))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xfa
	}
	if len(m.PackedUint64) > 0 {
		var pksize16 int
		for _, num := range m.PackedUint64 {
			pksize16 += sov(uint64(num))
		}
		i -= pksize16
		j15 := i
		for _, num := range m.PackedUint64 {
			for num >= 1<<7 {
				dAtA[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA[j15] = uint8(num)
			j15++
		}
		i = encodeVarint(dAtA, i, uint64(pksize16))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
	}
	if len(m.PackedUint32) > 0 {
		var pksize18 int
		for _, num := range m.PackedUint32 {
			pksize18 += sov(uint64(num))
		}
		i -= pksize18
		j17 := i
		for _, num := range m.PackedUint32 {
			for num >= 1<<7 {
				dAtA[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA[j17] = uint8(num)
			j17++
		}
		i = encodeVarint(dAtA, i, uint64(pksize18))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xea
	}
	if len(m.PackedInt64) > 0 {
		var pksize20 int
		for _, num := range m.PackedInt64 {
			pksize20 += sov(uint64(num))
		}
		i -= pksize20
		j19 := i
		for _, num1 := range m.PackedInt64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA[j19] = uint8(num)
			j19++
		}
		i = encodeVarint(dAtA, i, uint64(pksize20))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe2
	}
	if len(m.PackedInt32) > 0 {
		var pksize22 int
		for _, num := range m.PackedInt32 {
			pksize22 += sov(uint64(num))
		}
		i -= pksize22
		j21 := i
		for _, num1 := range m.PackedInt32 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA[j21] = uint8(num)
			j21++
		}
		i = encodeVarint(dAtA, i, uint64(pksize22))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xda
	}
	if len(m.MapStringForeignEnum) > 0 {
		for k := range m.MapStringForeignEnum {
			v := m.MapStringForeignEnum[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.MapStringNestedEnum) > 0 {
		for k := range m.MapStringNestedEnum {
			v := m.MapStringNestedEnum[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.MapStringForeignMessage) > 0 {
		for k := range m.MapStringForeignMessage {
			v := m.MapStringForeignMessage[k]
			baseI := i
			size, err := v.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.MapStringNestedMessage) > 0 {
		for k := range m.MapStringNestedMessage {
			v := m.MapStringNestedMessage[k]
			baseI := i
			size, err := v.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.MapStringBytes) > 0 {
		for k := range m.MapStringBytes {
			v := m.MapStringBytes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarint(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.MapStringString) > 0 {
		for k := range m.MapStringString {
			v := m.MapStringString[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarint(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.MapBoolBool) > 0 {
		for k := range m.MapBoolBool {
			v := m.MapBoolBool[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i--
			if k {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.MapInt32Double) > 0 {
		for k := range m.MapInt32Double {
			v := m.MapInt32Double[k]
			baseI := i
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i--
			dAtA[i] = 0x11
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.MapInt32Float) > 0 {
		for k := range m.MapInt32Float {
			v := m.MapInt32Float[k]
			baseI := i
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(v))))
			i--
			dAtA[i] = 0x15
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.MapSfixed64Sfixed64) > 0 {
		for k := range m.MapSfixed64Sfixed64 {
			v := m.MapSfixed64Sfixed64[k]
			baseI := i
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(v))
			i--
			dAtA[i] = 0x11
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(k))
			i--
			dAtA[i] = 0x9
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.MapSfixed32Sfixed32) > 0 {
		for k := range m.MapSfixed32Sfixed32 {
			v := m.MapSfixed32Sfixed32[k]
			baseI := i
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(v))
			i--
			dAtA[i] = 0x15
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.MapFixed64Fixed64) > 0 {
		for k := range m.MapFixed64Fixed64 {
			v := m.MapFixed64Fixed64[k]
			baseI := i
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(v))
			i--
			dAtA[i] = 0x11
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(k))
			i--
			dAtA[i] = 0x9
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.MapFixed32Fixed32) > 0 {
		for k := range m.MapFixed32Fixed32 {
			v := m.MapFixed32Fixed32[k]
			baseI := i
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(v))
			i--
			dAtA[i] = 0x15
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.MapSint64Sint64) > 0 {
		for k := range m.MapSint64Sint64 {
			v := m.MapSint64Sint64[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64((uint64(v)<<1)^uint64((v>>63))))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64((uint64(k)<<1)^uint64((k>>63))))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.MapSint32Sint32) > 0 {
		for k := range m.MapSint32Sint32 {
			v := m.MapSint32Sint32[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64((uint32(v)<<1)^uint32((v>>31))))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64((uint32(k)<<1)^uint32((k>>31))))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.MapUint64Uint64) > 0 {
		for k := range m.MapUint64Uint64 {
			v := m.MapUint64Uint64[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.MapUint32Uint32) > 0 {
		for k := range m.MapUint32Uint32 {
			v := m.MapUint32Uint32[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.MapInt64Int64) > 0 {
		for k := range m.MapInt64Int64 {
			v := m.MapInt64Int64[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.MapInt32Int32) > 0 {
		for k := range m.MapInt32Int32 {
			v := m.MapInt32Int32[k]
			baseI := i
			i = encodeVarint(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.RepeatedCord) > 0 {
		for iNdEx := len(m.RepeatedCord) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedCord[iNdEx])
			copy(dAtA[i:], m.RepeatedCord[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedCord[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.RepeatedStringPiece) > 0 {
		for iNdEx := len(m.RepeatedStringPiece) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedStringPiece[iNdEx])
			copy(dAtA[i:], m.RepeatedStringPiece[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedStringPiece[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.RepeatedForeignEnum) > 0 {
		var pksize24 int
		for _, num := range m.RepeatedForeignEnum {
			pksize24 += sov(uint64(num))
		}
		i -= pksize24
		j23 := i
		for _, num1 := range m.RepeatedForeignEnum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA[j23] = uint8(num)
			j23++
		}
		i = encodeVarint(dAtA, i, uint64(pksize24))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	if len(m.RepeatedNestedEnum) > 0 {
		var pksize26 int
		for _, num := range m.RepeatedNestedEnum {
			pksize26 += sov(uint64(num))
		}
		i -= pksize26
		j25 := i
		for _, num1 := range m.RepeatedNestedEnum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA[j25] = uint8(num)
			j25++
		}
		i = encodeVarint(dAtA, i, uint64(pksize26))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	if len(m.RepeatedForeignMessage) > 0 {
		for iNdEx := len(m.RepeatedForeignMessage) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.RepeatedForeignMessage[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.RepeatedNestedMessage) > 0 {
		for iNdEx := len(m.RepeatedNestedMessage) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.RepeatedNestedMessage[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.RepeatedBytes) > 0 {
		for iNdEx := len(m.RepeatedBytes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedBytes[iNdEx])
			copy(dAtA[i:], m.RepeatedBytes[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedBytes[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.RepeatedString) > 0 {
		for iNdEx := len(m.RepeatedString) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedString[iNdEx])
			copy(dAtA[i:], m.RepeatedString[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.RepeatedString[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.RepeatedBool) > 0 {
		for iNdEx := len(m.RepeatedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.RepeatedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedBool)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if len(m.RepeatedDouble) > 0 {
		for iNdEx := len(m.RepeatedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f27 := math.Float64bits(float64(m.RepeatedDouble[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f27))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedDouble)*8))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if len(m.RepeatedFloat) > 0 {
		for iNdEx := len(m.RepeatedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f28 := math.Float32bits(float32(m.RepeatedFloat[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f28))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedFloat)*4))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if len(m.RepeatedSfixed64) > 0 {
		for iNdEx := len(m.RepeatedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RepeatedSfixed64[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedSfixed64)*8))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if len(m.RepeatedSfixed32) > 0 {
		for iNdEx := len(m.RepeatedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RepeatedSfixed32[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedSfixed32)*4))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if len(m.RepeatedFixed64) > 0 {
		for iNdEx := len(m.RepeatedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RepeatedFixed64[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedFixed64)*8))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if len(m.RepeatedFixed32) > 0 {
		for iNdEx := len(m.RepeatedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RepeatedFixed32[iNdEx]))
		}
		i = encodeVarint(dAtA, i, uint64(len(m.RepeatedFixed32)*4))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if len(m.RepeatedSint64) > 0 {
		var pksize30 int
		for _, num := range m.RepeatedSint64 {
			pksize30 += soz(uint64(num))
		}
		i -= pksize30
		j29 := i
		for _, num := range m.RepeatedSint64 {
			x31 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x31 >= 1<<7 {
				dAtA[j29] = uint8(uint64(x31)&0x7f | 0x80)
				j29++
				x31 >>= 7
			}
			dAtA[j29] = uint8(x31)
			j29++
		}
		i = encodeVarint(dAtA, i, uint64(pksize30))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if len(m.RepeatedSint32) > 0 {
		var pksize33 int
		for _, num := range m.RepeatedSint32 {
			pksize33 += soz(uint64(num))
		}
		i -= pksize33
		j32 := i
		for _, num := range m.RepeatedSint32 {
			x34 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x34 >= 1<<7 {
				dAtA[j32] = uint8(uint64(x34)&0x7f | 0x80)
				j32++
				x34 >>= 7
			}
			dAtA[j32] = uint8(x34)
			j32++
		}
		i = encodeVarint(dAtA, i, uint64(pksize33))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if len(m.RepeatedUint64) > 0 {
		var pksize36 int
		for _, num := range m.RepeatedUint64 {
			pksize36 += sov(uint64(num))
		}
		i -= pksize36
		j35 := i
		for _, num := range m.RepeatedUint64 {
			for num >= 1<<7 {
				dAtA[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA[j35] = uint8(num)
			j35++
		}
		i = encodeVarint(dAtA, i, uint64(pksize36))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if len(m.RepeatedUint32) > 0 {
		var pksize38 int
		for _, num := range m.RepeatedUint32 {
			pksize38 += sov(uint64(num))
		}
		i -= pksize38
		j37 := i
		for _, num := range m.RepeatedUint32 {
			for num >= 1<<7 {
				dAtA[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA[j37] = uint8(num)
			j37++
		}
		i = encodeVarint(dAtA, i, uint64(pksize38))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.RepeatedInt64) > 0 {
		var pksize40 int
		for _, num := range m.RepeatedInt64 {
			pksize40 += sov(uint64(num))
		}
		i -= pksize40
		j39 := i
		for _, num1 := range m.RepeatedInt64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA[j39] = uint8(num)
			j39++
		}
		i = encodeVarint(dAtA, i, uint64(pksize40))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.RepeatedInt32) > 0 {
		var pksize42 int
		for _, num := range m.RepeatedInt32 {
			pksize42 += sov(uint64(num))
		}
		i -= pksize42
		j41 := i
		for _, num1 := range m.RepeatedInt32 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA[j41] = uint8(num)
			j41++
		}
		i = encodeVarint(dAtA, i, uint64(pksize42))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.RecursiveMessage != nil {
		size, err := m.RecursiveMessage.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.OptionalCord) > 0 {
		i -= len(m.OptionalCord)
		copy(dAtA[i:], m.OptionalCord)
		i = encodeVarint(dAtA, i, uint64(len(m.OptionalCord)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.OptionalStringPiece) > 0 {
		i -= len(m.OptionalStringPiece)
		copy(dAtA[i:], m.OptionalStringPiece)
		i = encodeVarint(dAtA, i, uint64(len(m.OptionalStringPiece)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.OptionalAliasedEnum != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalAliasedEnum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.OptionalForeignEnum != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalForeignEnum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.OptionalNestedEnum != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalNestedEnum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.OptionalForeignMessage != nil {
		size, err := m.OptionalForeignMessage.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.OptionalNestedMessage != nil {
		size, err := m.OptionalNestedMessage.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.OptionalBytes) > 0 {
		i -= len(m.OptionalBytes)
		copy(dAtA[i:], m.OptionalBytes)
		i = encodeVarint(dAtA, i, uint64(len(m.OptionalBytes)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.OptionalString) > 0 {
		i -= len(m.OptionalString)
		copy(dAtA[i:], m.OptionalString)
		i = encodeVarint(dAtA, i, uint64(len(m.OptionalString)))
		i--
		dAtA[i] = 0x72
	}
	if m.OptionalBool {
		i--
		if m.OptionalBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.OptionalDouble != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OptionalDouble))))
		i--
		dAtA[i] = 0x61
	}
	if m.OptionalFloat != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.OptionalFloat))))
		i--
		dAtA[i] = 0x5d
	}
	if m.OptionalSfixed64 != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.OptionalSfixed64))
		i--
		dAtA[i] = 0x51
	}
	if m.OptionalSfixed32 != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.OptionalSfixed32))
		i--
		dAtA[i] = 0x4d
	}
	if m.OptionalFixed64 != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.OptionalFixed64))
		i--
		dAtA[i] = 0x41
	}
	if m.OptionalFixed32 != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.OptionalFixed32))
		i--
		dAtA[i] = 0x3d
	}
	if m.OptionalSint64 != 0 {
		i = encodeVarint(dAtA, i, uint64((uint64(m.OptionalSint64)<<1)^uint64((m.OptionalSint64>>63))))
		i--
		dAtA[i] = 0x30
	}
	if m.OptionalSint32 != 0 {
		i = encodeVarint(dAtA, i, uint64((uint32(m.OptionalSint32)<<1)^uint32((m.OptionalSint32>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.OptionalUint64 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalUint64))
		i--
		dAtA[i] = 0x20
	}
	if m.OptionalUint32 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalUint32))
		i--
		dAtA[i] = 0x18
	}
	if m.OptionalInt64 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalInt64))
		i--
		dAtA[i] = 0x10
	}
	if m.OptionalInt32 != 0 {
		i = encodeVarint(dAtA, i, uint64(m.OptionalInt32))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto3_OneofUint32) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofUint32) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofUint32))
	i--
	dAtA[i] = 0x6
	i--
	dAtA[i] = 0xf8
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofNestedMessage) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofNestedMessage) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OneofNestedMessage != nil {
		size, err := m.OneofNestedMessage.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofString) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofString) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.OneofString)
	copy(dAtA[i:], m.OneofString)
	i = encodeVarint(dAtA, i, uint64(len(m.OneofString)))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0x8a
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofBytes) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofBytes) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.OneofBytes)
	copy(dAtA[i:], m.OneofBytes)
	i = encodeVarint(dAtA, i, uint64(len(m.OneofBytes)))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0x92
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofBool) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofBool) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.OneofBool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0x98
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofUint64) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofUint64) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofUint64))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xa0
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofFloat) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofFloat) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.OneofFloat))))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xad
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofDouble) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofDouble) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OneofDouble))))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xb1
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofEnum) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofEnum) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofEnum))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xb8
	return len(dAtA) - i, nil
}
func (m *TestAllTypesProto3_OneofNullValue) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TestAllTypesProto3_OneofNullValue) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.OneofNullValue))
	i--
	dAtA[i] = 0x7
	i--
	dAtA[i] = 0xc0
	return len(dAtA) - i, nil
}
func (m *ForeignMessage) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignMessage) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ForeignMessage) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.C != 0 {
		i = encodeVarint(dAtA, i, uint64(m.C))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NullHypothesisProto3) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullHypothesisProto3) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *NullHypothesisProto3) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	return len(dAtA) - i, nil
}

func (m *EnumOnlyProto3) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumOnlyProto3) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnumOnlyProto3) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	return len(dAtA) - i, nil
}

func (m *TestAllTypesProto3_NestedMessage) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A != 0 {
		n += 1 + sov(uint64(m.A))
	}
	if m.Corecursive != nil {
		l = m.Corecursive.SizeVT()
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *TestAllTypesProto3) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionalInt32 != 0 {
		n += 1 + sov(uint64(m.OptionalInt32))
	}
	if m.OptionalInt64 != 0 {
		n += 1 + sov(uint64(m.OptionalInt64))
	}
	if m.OptionalUint32 != 0 {
		n += 1 + sov(uint64(m.OptionalUint32))
	}
	if m.OptionalUint64 != 0 {
		n += 1 + sov(uint64(m.OptionalUint64))
	}
	if m.OptionalSint32 != 0 {
		n += 1 + soz(uint64(m.OptionalSint32))
	}
	if m.OptionalSint64 != 0 {
		n += 1 + soz(uint64(m.OptionalSint64))
	}
	if m.OptionalFixed32 != 0 {
		n += 5
	}
	if m.OptionalFixed64 != 0 {
		n += 9
	}
	if m.OptionalSfixed32 != 0 {
		n += 5
	}
	if m.OptionalSfixed64 != 0 {
		n += 9
	}
	if m.OptionalFloat != 0 {
		n += 5
	}
	if m.OptionalDouble != 0 {
		n += 9
	}
	if m.OptionalBool {
		n += 2
	}
	l = len(m.OptionalString)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.OptionalBytes)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.OptionalNestedMessage != nil {
		l = m.OptionalNestedMessage.SizeVT()
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalForeignMessage != nil {
		l = m.OptionalForeignMessage.SizeVT()
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalNestedEnum != 0 {
		n += 2 + sov(uint64(m.OptionalNestedEnum))
	}
	if m.OptionalForeignEnum != 0 {
		n += 2 + sov(uint64(m.OptionalForeignEnum))
	}
	if m.OptionalAliasedEnum != 0 {
		n += 2 + sov(uint64(m.OptionalAliasedEnum))
	}
	l = len(m.OptionalStringPiece)
	if l > 0 {
		n += 2 + l + sov(uint64(l))
	}
	l = len(m.OptionalCord)
	if l > 0 {
		n += 2 + l + sov(uint64(l))
	}
	if m.RecursiveMessage != nil {
		l = m.RecursiveMessage.SizeVT()
		n += 2 + l + sov(uint64(l))
	}
	if len(m.RepeatedInt32) > 0 {
		l = 0
		for _, e := range m.RepeatedInt32 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedInt64) > 0 {
		l = 0
		for _, e := range m.RepeatedInt64 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedUint32) > 0 {
		l = 0
		for _, e := range m.RepeatedUint32 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedUint64) > 0 {
		l = 0
		for _, e := range m.RepeatedUint64 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedSint32) > 0 {
		l = 0
		for _, e := range m.RepeatedSint32 {
			l += soz(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedSint64) > 0 {
		l = 0
		for _, e := range m.RepeatedSint64 {
			l += soz(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedFixed32) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedFixed32)*4)) + len(m.RepeatedFixed32)*4
	}
	if len(m.RepeatedFixed64) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedFixed64)*8)) + len(m.RepeatedFixed64)*8
	}
	if len(m.RepeatedSfixed32) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedSfixed32)*4)) + len(m.RepeatedSfixed32)*4
	}
	if len(m.RepeatedSfixed64) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedSfixed64)*8)) + len(m.RepeatedSfixed64)*8
	}
	if len(m.RepeatedFloat) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedFloat)*4)) + len(m.RepeatedFloat)*4
	}
	if len(m.RepeatedDouble) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedDouble)*8)) + len(m.RepeatedDouble)*8
	}
	if len(m.RepeatedBool) > 0 {
		n += 2 + sov(uint64(len(m.RepeatedBool))) + len(m.RepeatedBool)*1
	}
	if len(m.RepeatedString) > 0 {
		for _, s := range m.RepeatedString {
			l = len(s)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedBytes) > 0 {
		for _, b := range m.RepeatedBytes {
			l = len(b)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedNestedMessage) > 0 {
		for _, e := range m.RepeatedNestedMessage {
			l = e.SizeVT()
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedForeignMessage) > 0 {
		for _, e := range m.RepeatedForeignMessage {
			l = e.SizeVT()
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedNestedEnum) > 0 {
		l = 0
		for _, e := range m.RepeatedNestedEnum {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedForeignEnum) > 0 {
		l = 0
		for _, e := range m.RepeatedForeignEnum {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.RepeatedStringPiece) > 0 {
		for _, s := range m.RepeatedStringPiece {
			l = len(s)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedCord) > 0 {
		for _, s := range m.RepeatedCord {
			l = len(s)
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.MapInt32Int32) > 0 {
		for k, v := range m.MapInt32Int32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt64Int64) > 0 {
		for k, v := range m.MapInt64Int64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapUint32Uint32) > 0 {
		for k, v := range m.MapUint32Uint32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapUint64Uint64) > 0 {
		for k, v := range m.MapUint64Uint64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapSint32Sint32) > 0 {
		for k, v := range m.MapSint32Sint32 {
			_ = k
			_ = v
			mapEntrySize := 1 + soz(uint64(k)) + 1 + soz(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapSint64Sint64) > 0 {
		for k, v := range m.MapSint64Sint64 {
			_ = k
			_ = v
			mapEntrySize := 1 + soz(uint64(k)) + 1 + soz(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapFixed32Fixed32) > 0 {
		for k, v := range m.MapFixed32Fixed32 {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapFixed64Fixed64) > 0 {
		for k, v := range m.MapFixed64Fixed64 {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapSfixed32Sfixed32) > 0 {
		for k, v := range m.MapSfixed32Sfixed32 {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapSfixed64Sfixed64) > 0 {
		for k, v := range m.MapSfixed64Sfixed64 {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt32Float) > 0 {
		for k, v := range m.MapInt32Float {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + 4
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt32Double) > 0 {
		for k, v := range m.MapInt32Double {
			_ = k
			_ = v
			mapEntrySize := 1 + sov(uint64(k)) + 1 + 8
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapBoolBool) > 0 {
		for k, v := range m.MapBoolBool {
			_ = k
			_ = v
			mapEntrySize := 1 + 1 + 1 + 1
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringString) > 0 {
		for k, v := range m.MapStringString {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + 1 + len(v) + sov(uint64(len(v)))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringBytes) > 0 {
		for k, v := range m.MapStringBytes {
			_ = k
			_ = v
			l = 1 + len(v) + sov(uint64(len(v)))
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + l
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringNestedMessage) > 0 {
		for k, v := range m.MapStringNestedMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.SizeVT()
			}
			l += 1 + sov(uint64(l))
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + l
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringForeignMessage) > 0 {
		for k, v := range m.MapStringForeignMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.SizeVT()
			}
			l += 1 + sov(uint64(l))
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + l
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringNestedEnum) > 0 {
		for k, v := range m.MapStringNestedEnum {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringForeignEnum) > 0 {
		for k, v := range m.MapStringForeignEnum {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + 1 + sov(uint64(v))
			n += mapEntrySize + 2 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.PackedInt32) > 0 {
		l = 0
		for _, e := range m.PackedInt32 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedInt64) > 0 {
		l = 0
		for _, e := range m.PackedInt64 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedUint32) > 0 {
		l = 0
		for _, e := range m.PackedUint32 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedUint64) > 0 {
		l = 0
		for _, e := range m.PackedUint64 {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedSint32) > 0 {
		l = 0
		for _, e := range m.PackedSint32 {
			l += soz(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedSint64) > 0 {
		l = 0
		for _, e := range m.PackedSint64 {
			l += soz(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.PackedFixed32) > 0 {
		n += 2 + sov(uint64(len(m.PackedFixed32)*4)) + len(m.PackedFixed32)*4
	}
	if len(m.PackedFixed64) > 0 {
		n += 2 + sov(uint64(len(m.PackedFixed64)*8)) + len(m.PackedFixed64)*8
	}
	if len(m.PackedSfixed32) > 0 {
		n += 2 + sov(uint64(len(m.PackedSfixed32)*4)) + len(m.PackedSfixed32)*4
	}
	if len(m.PackedSfixed64) > 0 {
		n += 2 + sov(uint64(len(m.PackedSfixed64)*8)) + len(m.PackedSfixed64)*8
	}
	if len(m.PackedFloat) > 0 {
		n += 2 + sov(uint64(len(m.PackedFloat)*4)) + len(m.PackedFloat)*4
	}
	if len(m.PackedDouble) > 0 {
		n += 2 + sov(uint64(len(m.PackedDouble)*8)) + len(m.PackedDouble)*8
	}
	if len(m.PackedBool) > 0 {
		n += 2 + sov(uint64(len(m.PackedBool))) + len(m.PackedBool)*1
	}
	if len(m.PackedNestedEnum) > 0 {
		l = 0
		for _, e := range m.PackedNestedEnum {
			l += sov(uint64(e))
		}
		n += 2 + sov(uint64(l)) + l
	}
	if len(m.UnpackedInt32) > 0 {
		for _, e := range m.UnpackedInt32 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.UnpackedInt64) > 0 {
		for _, e := range m.UnpackedInt64 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.UnpackedUint32) > 0 {
		for _, e := range m.UnpackedUint32 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.UnpackedUint64) > 0 {
		for _, e := range m.UnpackedUint64 {
			n += 2 + sov(uint64(e))
		}
	}
	if len(m.UnpackedSint32) > 0 {
		for _, e := range m.UnpackedSint32 {
			n += 2 + soz(uint64(e))
		}
	}
	if len(m.UnpackedSint64) > 0 {
		for _, e := range m.UnpackedSint64 {
			n += 2 + soz(uint64(e))
		}
	}
	if len(m.UnpackedFixed32) > 0 {
		n += 6 * len(m.UnpackedFixed32)
	}
	if len(m.UnpackedFixed64) > 0 {
		n += 10 * len(m.UnpackedFixed64)
	}
	if len(m.UnpackedSfixed32) > 0 {
		n += 6 * len(m.UnpackedSfixed32)
	}
	if len(m.UnpackedSfixed64) > 0 {
		n += 10 * len(m.UnpackedSfixed64)
	}
	if len(m.UnpackedFloat) > 0 {
		n += 6 * len(m.UnpackedFloat)
	}
	if len(m.UnpackedDouble) > 0 {
		n += 10 * len(m.UnpackedDouble)
	}
	if len(m.UnpackedBool) > 0 {
		n += 3 * len(m.UnpackedBool)
	}
	if len(m.UnpackedNestedEnum) > 0 {
		for _, e := range m.UnpackedNestedEnum {
			n += 2 + sov(uint64(e))
		}
	}
	if vtmsg, ok := m.OneofField.(interface{ SizeVT() int }); ok {
		n += vtmsg.SizeVT()
	}
	if m.OptionalBoolWrapper != nil {
		if size, ok := interface{}(m.OptionalBoolWrapper).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalBoolWrapper)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalInt32Wrapper != nil {
		if size, ok := interface{}(m.OptionalInt32Wrapper).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalInt32Wrapper)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalInt64Wrapper != nil {
		if size, ok := interface{}(m.OptionalInt64Wrapper).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalInt64Wrapper)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalUint32Wrapper != nil {
		if size, ok := interface{}(m.OptionalUint32Wrapper).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalUint32Wrapper)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalUint64Wrapper != nil {
		if size, ok := interface{}(m.OptionalUint64Wrapper).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalUint64Wrapper)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalFloatWrapper != nil {
		if size, ok := interface{}(m.OptionalFloatWrapper).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalFloatWrapper)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalDoubleWrapper != nil {
		if size, ok := interface{}(m.OptionalDoubleWrapper).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalDoubleWrapper)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalStringWrapper != nil {
		if size, ok := interface{}(m.OptionalStringWrapper).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalStringWrapper)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalBytesWrapper != nil {
		if size, ok := interface{}(m.OptionalBytesWrapper).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalBytesWrapper)
		}
		n += 2 + l + sov(uint64(l))
	}
	if len(m.RepeatedBoolWrapper) > 0 {
		for _, e := range m.RepeatedBoolWrapper {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedInt32Wrapper) > 0 {
		for _, e := range m.RepeatedInt32Wrapper {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedInt64Wrapper) > 0 {
		for _, e := range m.RepeatedInt64Wrapper {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedUint32Wrapper) > 0 {
		for _, e := range m.RepeatedUint32Wrapper {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedUint64Wrapper) > 0 {
		for _, e := range m.RepeatedUint64Wrapper {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedFloatWrapper) > 0 {
		for _, e := range m.RepeatedFloatWrapper {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedDoubleWrapper) > 0 {
		for _, e := range m.RepeatedDoubleWrapper {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedStringWrapper) > 0 {
		for _, e := range m.RepeatedStringWrapper {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedBytesWrapper) > 0 {
		for _, e := range m.RepeatedBytesWrapper {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if m.OptionalDuration != nil {
		if size, ok := interface{}(m.OptionalDuration).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalDuration)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalTimestamp != nil {
		if size, ok := interface{}(m.OptionalTimestamp).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalTimestamp)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalFieldMask != nil {
		if size, ok := interface{}(m.OptionalFieldMask).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalFieldMask)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalStruct != nil {
		if size, ok := interface{}(m.OptionalStruct).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalStruct)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalAny != nil {
		if size, ok := interface{}(m.OptionalAny).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalAny)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalValue != nil {
		if size, ok := interface{}(m.OptionalValue).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OptionalValue)
		}
		n += 2 + l + sov(uint64(l))
	}
	if m.OptionalNullValue != 0 {
		n += 2 + sov(uint64(m.OptionalNullValue))
	}
	if len(m.RepeatedDuration) > 0 {
		for _, e := range m.RepeatedDuration {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedTimestamp) > 0 {
		for _, e := range m.RepeatedTimestamp {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedFieldmask) > 0 {
		for _, e := range m.RepeatedFieldmask {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedAny) > 0 {
		for _, e := range m.RepeatedAny {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedValue) > 0 {
		for _, e := range m.RepeatedValue {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedListValue) > 0 {
		for _, e := range m.RepeatedListValue {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if len(m.RepeatedStruct) > 0 {
		for _, e := range m.RepeatedStruct {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 2 + l + sov(uint64(l))
		}
	}
	if m.Fieldname1 != 0 {
		n += 2 + sov(uint64(m.Fieldname1))
	}
	if m.FieldName2 != 0 {
		n += 2 + sov(uint64(m.FieldName2))
	}
	if m.XFieldName3 != 0 {
		n += 2 + sov(uint64(m.XFieldName3))
	}
	if m.Field_Name4_ != 0 {
		n += 2 + sov(uint64(m.Field_Name4_))
	}
	if m.Field0Name5 != 0 {
		n += 2 + sov(uint64(m.Field0Name5))
	}
	if m.Field_0Name6 != 0 {
		n += 2 + sov(uint64(m.Field_0Name6))
	}
	if m.FieldName7 != 0 {
		n += 2 + sov(uint64(m.FieldName7))
	}
	if m.FieldName8 != 0 {
		n += 2 + sov(uint64(m.FieldName8))
	}
	if m.Field_Name9 != 0 {
		n += 2 + sov(uint64(m.Field_Name9))
	}
	if m.Field_Name10 != 0 {
		n += 2 + sov(uint64(m.Field_Name10))
	}
	if m.FIELD_NAME11 != 0 {
		n += 2 + sov(uint64(m.FIELD_NAME11))
	}
	if m.FIELDName12 != 0 {
		n += 2 + sov(uint64(m.FIELDName12))
	}
	if m.XFieldName13 != 0 {
		n += 2 + sov(uint64(m.XFieldName13))
	}
	if m.X_FieldName14 != 0 {
		n += 2 + sov(uint64(m.X_FieldName14))
	}
	if m.Field_Name15 != 0 {
		n += 2 + sov(uint64(m.Field_Name15))
	}
	if m.Field__Name16 != 0 {
		n += 2 + sov(uint64(m.Field__Name16))
	}
	if m.FieldName17__ != 0 {
		n += 2 + sov(uint64(m.FieldName17__))
	}
	if m.FieldName18__ != 0 {
		n += 2 + sov(uint64(m.FieldName18__))
	}
	n += len(m.unknownFields)
	return n
}

func (m *TestAllTypesProto3_OneofUint32) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sov(uint64(m.OneofUint32))
	return n
}
func (m *TestAllTypesProto3_OneofNestedMessage) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OneofNestedMessage != nil {
		l = m.OneofNestedMessage.SizeVT()
		n += 2 + l + sov(uint64(l))
	}
	return n
}
func (m *TestAllTypesProto3_OneofString) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OneofString)
	n += 2 + l + sov(uint64(l))
	return n
}
func (m *TestAllTypesProto3_OneofBytes) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OneofBytes)
	n += 2 + l + sov(uint64(l))
	return n
}
func (m *TestAllTypesProto3_OneofBool) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *TestAllTypesProto3_OneofUint64) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sov(uint64(m.OneofUint64))
	return n
}
func (m *TestAllTypesProto3_OneofFloat) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 6
	return n
}
func (m *TestAllTypesProto3_OneofDouble) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 10
	return n
}
func (m *TestAllTypesProto3_OneofEnum) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sov(uint64(m.OneofEnum))
	return n
}
func (m *TestAllTypesProto3_OneofNullValue) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sov(uint64(m.OneofNullValue))
	return n
}
func (m *ForeignMessage) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.C != 0 {
		n += 1 + sov(uint64(m.C))
	}
	n += len(m.unknownFields)
	return n
}

func (m *NullHypothesisProto3) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += len(m.unknownFields)
	return n
}

func (m *EnumOnlyProto3) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += len(m.unknownFields)
	return n
}

func (m *TestAllTypesProto3_NestedMessage) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestAllTypesProto3_NestedMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestAllTypesProto3_NestedMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corecursive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Corecursive == nil {
				m.Corecursive = &TestAllTypesProto3{}
			}
			if err := m.Corecursive.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestAllTypesProto3) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestAllTypesProto3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestAllTypesProto3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt32", wireType)
			}
			m.OptionalInt32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalInt32 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt64", wireType)
			}
			m.OptionalInt64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalInt64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint32", wireType)
			}
			m.OptionalUint32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalUint32 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint64", wireType)
			}
			m.OptionalUint64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalUint64 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSint32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OptionalSint32 = v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.OptionalSint64 = int64(v)
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFixed32", wireType)
			}
			m.OptionalFixed32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalFixed32 = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFixed64", wireType)
			}
			m.OptionalFixed64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalFixed64 = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSfixed32", wireType)
			}
			m.OptionalSfixed32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalSfixed32 = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSfixed64", wireType)
			}
			m.OptionalSfixed64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalSfixed64 = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.OptionalFloat = float32(math.Float32frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OptionalDouble = float64(math.Float64frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalBool = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalBytes = append(m.OptionalBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.OptionalBytes == nil {
				m.OptionalBytes = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalNestedMessage == nil {
				m.OptionalNestedMessage = &TestAllTypesProto3_NestedMessage{}
			}
			if err := m.OptionalNestedMessage.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalForeignMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalForeignMessage == nil {
				m.OptionalForeignMessage = &ForeignMessage{}
			}
			if err := m.OptionalForeignMessage.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalNestedEnum", wireType)
			}
			m.OptionalNestedEnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalNestedEnum |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalForeignEnum", wireType)
			}
			m.OptionalForeignEnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalForeignEnum |= ForeignEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalAliasedEnum", wireType)
			}
			m.OptionalAliasedEnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalAliasedEnum |= TestAllTypesProto3_AliasedEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalStringPiece", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalStringPiece = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalCord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalCord = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecursiveMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecursiveMessage == nil {
				m.RecursiveMessage = &TestAllTypesProto3{}
			}
			if err := m.RecursiveMessage.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt32 = append(m.RepeatedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedInt32) == 0 {
					m.RepeatedInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt32 = append(m.RepeatedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt32", wireType)
			}
		case 32:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt64 = append(m.RepeatedInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedInt64) == 0 {
					m.RepeatedInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt64 = append(m.RepeatedInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt64", wireType)
			}
		case 33:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedUint32 = append(m.RepeatedUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedUint32) == 0 {
					m.RepeatedUint32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedUint32 = append(m.RepeatedUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint32", wireType)
			}
		case 34:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedUint64 = append(m.RepeatedUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedUint64) == 0 {
					m.RepeatedUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedUint64 = append(m.RepeatedUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint64", wireType)
			}
		case 35:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RepeatedSint32 = append(m.RepeatedSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedSint32) == 0 {
					m.RepeatedSint32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RepeatedSint32 = append(m.RepeatedSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSint32", wireType)
			}
		case 36:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.RepeatedSint64 = append(m.RepeatedSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedSint64) == 0 {
					m.RepeatedSint64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.RepeatedSint64 = append(m.RepeatedSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSint64", wireType)
			}
		case 37:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.RepeatedFixed32 = append(m.RepeatedFixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedFixed32) == 0 {
					m.RepeatedFixed32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.RepeatedFixed32 = append(m.RepeatedFixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFixed32", wireType)
			}
		case 38:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.RepeatedFixed64 = append(m.RepeatedFixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedFixed64) == 0 {
					m.RepeatedFixed64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.RepeatedFixed64 = append(m.RepeatedFixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFixed64", wireType)
			}
		case 39:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.RepeatedSfixed32 = append(m.RepeatedSfixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedSfixed32) == 0 {
					m.RepeatedSfixed32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.RepeatedSfixed32 = append(m.RepeatedSfixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSfixed32", wireType)
			}
		case 40:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.RepeatedSfixed64 = append(m.RepeatedSfixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedSfixed64) == 0 {
					m.RepeatedSfixed64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.RepeatedSfixed64 = append(m.RepeatedSfixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSfixed64", wireType)
			}
		case 41:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.RepeatedFloat = append(m.RepeatedFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedFloat) == 0 {
					m.RepeatedFloat = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.RepeatedFloat = append(m.RepeatedFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFloat", wireType)
			}
		case 42:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.RepeatedDouble = append(m.RepeatedDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedDouble) == 0 {
					m.RepeatedDouble = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.RepeatedDouble = append(m.RepeatedDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedDouble", wireType)
			}
		case 43:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedBool = append(m.RepeatedBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.RepeatedBool) == 0 {
					m.RepeatedBool = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedBool = append(m.RepeatedBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBool", wireType)
			}
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedString = append(m.RepeatedString, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedBytes = append(m.RepeatedBytes, make([]byte, postIndex-iNdEx))
			copy(m.RepeatedBytes[len(m.RepeatedBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedNestedMessage = append(m.RepeatedNestedMessage, &TestAllTypesProto3_NestedMessage{})
			if err := m.RepeatedNestedMessage[len(m.RepeatedNestedMessage)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedForeignMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedForeignMessage = append(m.RepeatedForeignMessage, &ForeignMessage{})
			if err := m.RepeatedForeignMessage[len(m.RepeatedForeignMessage)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType == 0 {
				var v TestAllTypesProto3_NestedEnum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedNestedEnum = append(m.RepeatedNestedEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RepeatedNestedEnum) == 0 {
					m.RepeatedNestedEnum = make([]TestAllTypesProto3_NestedEnum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TestAllTypesProto3_NestedEnum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedNestedEnum = append(m.RepeatedNestedEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedNestedEnum", wireType)
			}
		case 52:
			if wireType == 0 {
				var v ForeignEnum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ForeignEnum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedForeignEnum = append(m.RepeatedForeignEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RepeatedForeignEnum) == 0 {
					m.RepeatedForeignEnum = make([]ForeignEnum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ForeignEnum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ForeignEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedForeignEnum = append(m.RepeatedForeignEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedForeignEnum", wireType)
			}
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedStringPiece", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedStringPiece = append(m.RepeatedStringPiece, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedCord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedCord = append(m.RepeatedCord, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Int32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32Int32 == nil {
				m.MapInt32Int32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32Int32[mapkey] = mapvalue
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt64Int64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt64Int64 == nil {
				m.MapInt64Int64 = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt64Int64[mapkey] = mapvalue
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapUint32Uint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapUint32Uint32 == nil {
				m.MapUint32Uint32 = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapUint32Uint32[mapkey] = mapvalue
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapUint64Uint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapUint64Uint64 == nil {
				m.MapUint64Uint64 = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapUint64Uint64[mapkey] = mapvalue
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSint32Sint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSint32Sint32 == nil {
				m.MapSint32Sint32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = int32((uint32(mapkeytemp) >> 1) ^ uint32(((mapkeytemp&1)<<31)>>31))
					mapkey = int32(mapkeytemp)
				} else if fieldNum == 2 {
					var mapvaluetemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = int32((uint32(mapvaluetemp) >> 1) ^ uint32(((mapvaluetemp&1)<<31)>>31))
					mapvalue = int32(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSint32Sint32[mapkey] = mapvalue
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSint64Sint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSint64Sint64 == nil {
				m.MapSint64Sint64 = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = (mapkeytemp >> 1) ^ uint64((int64(mapkeytemp&1)<<63)>>63)
					mapkey = int64(mapkeytemp)
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = (mapvaluetemp >> 1) ^ uint64((int64(mapvaluetemp&1)<<63)>>63)
					mapvalue = int64(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSint64Sint64[mapkey] = mapvalue
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapFixed32Fixed32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapFixed32Fixed32 == nil {
				m.MapFixed32Fixed32 = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapFixed32Fixed32[mapkey] = mapvalue
			iNdEx = postIndex
		case 63:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapFixed64Fixed64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapFixed64Fixed64 == nil {
				m.MapFixed64Fixed64 = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapFixed64Fixed64[mapkey] = mapvalue
			iNdEx = postIndex
		case 64:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSfixed32Sfixed32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSfixed32Sfixed32 == nil {
				m.MapSfixed32Sfixed32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSfixed32Sfixed32[mapkey] = mapvalue
			iNdEx = postIndex
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSfixed64Sfixed64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSfixed64Sfixed64 == nil {
				m.MapSfixed64Sfixed64 = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSfixed64Sfixed64[mapkey] = mapvalue
			iNdEx = postIndex
		case 66:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Float", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32Float == nil {
				m.MapInt32Float = make(map[int32]float32)
			}
			var mapkey int32
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32Float[mapkey] = mapvalue
			iNdEx = postIndex
		case 67:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Double", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32Double == nil {
				m.MapInt32Double = make(map[int32]float64)
			}
			var mapkey int32
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32Double[mapkey] = mapvalue
			iNdEx = postIndex
		case 68:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBoolBool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapBoolBool == nil {
				m.MapBoolBool = make(map[bool]bool)
			}
			var mapkey bool
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkey = bool(mapkeytemp != 0)
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapBoolBool[mapkey] = mapvalue
			iNdEx = postIndex
		case 69:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringString == nil {
				m.MapStringString = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringString[mapkey] = mapvalue
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringBytes == nil {
				m.MapStringBytes = make(map[string][]byte)
			}
			var mapkey string
			var mapvalue []byte
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLength
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLength
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringBytes[mapkey] = mapvalue
			iNdEx = postIndex
		case 71:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringNestedMessage == nil {
				m.MapStringNestedMessage = make(map[string]*TestAllTypesProto3_NestedMessage)
			}
			var mapkey string
			var mapvalue *TestAllTypesProto3_NestedMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TestAllTypesProto3_NestedMessage{}
					if err := mapvalue.UnmarshalVT(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringNestedMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 72:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringForeignMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringForeignMessage == nil {
				m.MapStringForeignMessage = make(map[string]*ForeignMessage)
			}
			var mapkey string
			var mapvalue *ForeignMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ForeignMessage{}
					if err := mapvalue.UnmarshalVT(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringForeignMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 73:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringNestedEnum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringNestedEnum == nil {
				m.MapStringNestedEnum = make(map[string]TestAllTypesProto3_NestedEnum)
			}
			var mapkey string
			var mapvalue TestAllTypesProto3_NestedEnum
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringNestedEnum[mapkey] = mapvalue
			iNdEx = postIndex
		case 74:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringForeignEnum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringForeignEnum == nil {
				m.MapStringForeignEnum = make(map[string]ForeignEnum)
			}
			var mapkey string
			var mapvalue ForeignEnum
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= ForeignEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringForeignEnum[mapkey] = mapvalue
			iNdEx = postIndex
		case 75:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedInt32 = append(m.PackedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedInt32) == 0 {
					m.PackedInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedInt32 = append(m.PackedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedInt32", wireType)
			}
		case 76:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedInt64 = append(m.PackedInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedInt64) == 0 {
					m.PackedInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedInt64 = append(m.PackedInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedInt64", wireType)
			}
		case 77:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedUint32 = append(m.PackedUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedUint32) == 0 {
					m.PackedUint32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedUint32 = append(m.PackedUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedUint32", wireType)
			}
		case 78:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedUint64 = append(m.PackedUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedUint64) == 0 {
					m.PackedUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedUint64 = append(m.PackedUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedUint64", wireType)
			}
		case 79:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.PackedSint32 = append(m.PackedSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedSint32) == 0 {
					m.PackedSint32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.PackedSint32 = append(m.PackedSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedSint32", wireType)
			}
		case 80:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.PackedSint64 = append(m.PackedSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PackedSint64) == 0 {
					m.PackedSint64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.PackedSint64 = append(m.PackedSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedSint64", wireType)
			}
		case 81:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.PackedFixed32 = append(m.PackedFixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.PackedFixed32) == 0 {
					m.PackedFixed32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.PackedFixed32 = append(m.PackedFixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedFixed32", wireType)
			}
		case 82:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.PackedFixed64 = append(m.PackedFixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.PackedFixed64) == 0 {
					m.PackedFixed64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.PackedFixed64 = append(m.PackedFixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedFixed64", wireType)
			}
		case 83:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.PackedSfixed32 = append(m.PackedSfixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.PackedSfixed32) == 0 {
					m.PackedSfixed32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.PackedSfixed32 = append(m.PackedSfixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedSfixed32", wireType)
			}
		case 84:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.PackedSfixed64 = append(m.PackedSfixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.PackedSfixed64) == 0 {
					m.PackedSfixed64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.PackedSfixed64 = append(m.PackedSfixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedSfixed64", wireType)
			}
		case 85:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.PackedFloat = append(m.PackedFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.PackedFloat) == 0 {
					m.PackedFloat = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.PackedFloat = append(m.PackedFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedFloat", wireType)
			}
		case 86:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.PackedDouble = append(m.PackedDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.PackedDouble) == 0 {
					m.PackedDouble = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.PackedDouble = append(m.PackedDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedDouble", wireType)
			}
		case 87:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedBool = append(m.PackedBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.PackedBool) == 0 {
					m.PackedBool = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedBool = append(m.PackedBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedBool", wireType)
			}
		case 88:
			if wireType == 0 {
				var v TestAllTypesProto3_NestedEnum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedNestedEnum = append(m.PackedNestedEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.PackedNestedEnum) == 0 {
					m.PackedNestedEnum = make([]TestAllTypesProto3_NestedEnum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TestAllTypesProto3_NestedEnum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedNestedEnum = append(m.PackedNestedEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedNestedEnum", wireType)
			}
		case 89:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedInt32 = append(m.UnpackedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedInt32) == 0 {
					m.UnpackedInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedInt32 = append(m.UnpackedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedInt32", wireType)
			}
		case 90:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedInt64 = append(m.UnpackedInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedInt64) == 0 {
					m.UnpackedInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedInt64 = append(m.UnpackedInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedInt64", wireType)
			}
		case 91:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedUint32 = append(m.UnpackedUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedUint32) == 0 {
					m.UnpackedUint32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedUint32 = append(m.UnpackedUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedUint32", wireType)
			}
		case 92:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedUint64 = append(m.UnpackedUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedUint64) == 0 {
					m.UnpackedUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedUint64 = append(m.UnpackedUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedUint64", wireType)
			}
		case 93:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UnpackedSint32 = append(m.UnpackedSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedSint32) == 0 {
					m.UnpackedSint32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UnpackedSint32 = append(m.UnpackedSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedSint32", wireType)
			}
		case 94:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.UnpackedSint64 = append(m.UnpackedSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnpackedSint64) == 0 {
					m.UnpackedSint64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.UnpackedSint64 = append(m.UnpackedSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedSint64", wireType)
			}
		case 95:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.UnpackedFixed32 = append(m.UnpackedFixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.UnpackedFixed32) == 0 {
					m.UnpackedFixed32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.UnpackedFixed32 = append(m.UnpackedFixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedFixed32", wireType)
			}
		case 96:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.UnpackedFixed64 = append(m.UnpackedFixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.UnpackedFixed64) == 0 {
					m.UnpackedFixed64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.UnpackedFixed64 = append(m.UnpackedFixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedFixed64", wireType)
			}
		case 97:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.UnpackedSfixed32 = append(m.UnpackedSfixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.UnpackedSfixed32) == 0 {
					m.UnpackedSfixed32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.UnpackedSfixed32 = append(m.UnpackedSfixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedSfixed32", wireType)
			}
		case 98:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.UnpackedSfixed64 = append(m.UnpackedSfixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.UnpackedSfixed64) == 0 {
					m.UnpackedSfixed64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.UnpackedSfixed64 = append(m.UnpackedSfixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedSfixed64", wireType)
			}
		case 99:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.UnpackedFloat = append(m.UnpackedFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.UnpackedFloat) == 0 {
					m.UnpackedFloat = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.UnpackedFloat = append(m.UnpackedFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedFloat", wireType)
			}
		case 100:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.UnpackedDouble = append(m.UnpackedDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.UnpackedDouble) == 0 {
					m.UnpackedDouble = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.UnpackedDouble = append(m.UnpackedDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedDouble", wireType)
			}
		case 101:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedBool = append(m.UnpackedBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.UnpackedBool) == 0 {
					m.UnpackedBool = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedBool = append(m.UnpackedBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedBool", wireType)
			}
		case 102:
			if wireType == 0 {
				var v TestAllTypesProto3_NestedEnum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnpackedNestedEnum = append(m.UnpackedNestedEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.UnpackedNestedEnum) == 0 {
					m.UnpackedNestedEnum = make([]TestAllTypesProto3_NestedEnum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TestAllTypesProto3_NestedEnum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnpackedNestedEnum = append(m.UnpackedNestedEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnpackedNestedEnum", wireType)
			}
		case 111:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofUint32", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofField = &TestAllTypesProto3_OneofUint32{OneofUint32: v}
		case 112:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.OneofField.(*TestAllTypesProto3_OneofNestedMessage); ok {
				if err := oneof.OneofNestedMessage.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &TestAllTypesProto3_NestedMessage{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.OneofField = &TestAllTypesProto3_OneofNestedMessage{OneofNestedMessage: v}
			}
			iNdEx = postIndex
		case 113:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneofField = &TestAllTypesProto3_OneofString{OneofString: string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.OneofField = &TestAllTypesProto3_OneofBytes{OneofBytes: v}
			iNdEx = postIndex
		case 115:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OneofField = &TestAllTypesProto3_OneofBool{OneofBool: b}
		case 116:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofUint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofField = &TestAllTypesProto3_OneofUint64{OneofUint64: v}
		case 117:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.OneofField = &TestAllTypesProto3_OneofFloat{OneofFloat: float32(math.Float32frombits(v))}
		case 118:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OneofField = &TestAllTypesProto3_OneofDouble{OneofDouble: float64(math.Float64frombits(v))}
		case 119:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofEnum", wireType)
			}
			var v TestAllTypesProto3_NestedEnum
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= TestAllTypesProto3_NestedEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofField = &TestAllTypesProto3_OneofEnum{OneofEnum: v}
		case 120:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofNullValue", wireType)
			}
			var v structpb.NullValue
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= structpb.NullValue(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofField = &TestAllTypesProto3_OneofNullValue{OneofNullValue: v}
		case 201:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBoolWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalBoolWrapper == nil {
				m.OptionalBoolWrapper = &wrapperspb.BoolValue{}
			}
			if unmarshal, ok := interface{}(m.OptionalBoolWrapper).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalBoolWrapper); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 202:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt32Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalInt32Wrapper == nil {
				m.OptionalInt32Wrapper = &wrapperspb.Int32Value{}
			}
			if unmarshal, ok := interface{}(m.OptionalInt32Wrapper).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalInt32Wrapper); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 203:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt64Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalInt64Wrapper == nil {
				m.OptionalInt64Wrapper = &wrapperspb.Int64Value{}
			}
			if unmarshal, ok := interface{}(m.OptionalInt64Wrapper).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalInt64Wrapper); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 204:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint32Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalUint32Wrapper == nil {
				m.OptionalUint32Wrapper = &wrapperspb.UInt32Value{}
			}
			if unmarshal, ok := interface{}(m.OptionalUint32Wrapper).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalUint32Wrapper); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 205:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint64Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalUint64Wrapper == nil {
				m.OptionalUint64Wrapper = &wrapperspb.UInt64Value{}
			}
			if unmarshal, ok := interface{}(m.OptionalUint64Wrapper).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalUint64Wrapper); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 206:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFloatWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalFloatWrapper == nil {
				m.OptionalFloatWrapper = &wrapperspb.FloatValue{}
			}
			if unmarshal, ok := interface{}(m.OptionalFloatWrapper).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalFloatWrapper); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 207:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalDoubleWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalDoubleWrapper == nil {
				m.OptionalDoubleWrapper = &wrapperspb.DoubleValue{}
			}
			if unmarshal, ok := interface{}(m.OptionalDoubleWrapper).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalDoubleWrapper); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 208:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalStringWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalStringWrapper == nil {
				m.OptionalStringWrapper = &wrapperspb.StringValue{}
			}
			if unmarshal, ok := interface{}(m.OptionalStringWrapper).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalStringWrapper); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 209:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBytesWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalBytesWrapper == nil {
				m.OptionalBytesWrapper = &wrapperspb.BytesValue{}
			}
			if unmarshal, ok := interface{}(m.OptionalBytesWrapper).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalBytesWrapper); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 211:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBoolWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedBoolWrapper = append(m.RepeatedBoolWrapper, &wrapperspb.BoolValue{})
			if unmarshal, ok := interface{}(m.RepeatedBoolWrapper[len(m.RepeatedBoolWrapper)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedBoolWrapper[len(m.RepeatedBoolWrapper)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 212:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt32Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedInt32Wrapper = append(m.RepeatedInt32Wrapper, &wrapperspb.Int32Value{})
			if unmarshal, ok := interface{}(m.RepeatedInt32Wrapper[len(m.RepeatedInt32Wrapper)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedInt32Wrapper[len(m.RepeatedInt32Wrapper)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 213:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt64Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedInt64Wrapper = append(m.RepeatedInt64Wrapper, &wrapperspb.Int64Value{})
			if unmarshal, ok := interface{}(m.RepeatedInt64Wrapper[len(m.RepeatedInt64Wrapper)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedInt64Wrapper[len(m.RepeatedInt64Wrapper)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 214:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint32Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedUint32Wrapper = append(m.RepeatedUint32Wrapper, &wrapperspb.UInt32Value{})
			if unmarshal, ok := interface{}(m.RepeatedUint32Wrapper[len(m.RepeatedUint32Wrapper)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedUint32Wrapper[len(m.RepeatedUint32Wrapper)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 215:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint64Wrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedUint64Wrapper = append(m.RepeatedUint64Wrapper, &wrapperspb.UInt64Value{})
			if unmarshal, ok := interface{}(m.RepeatedUint64Wrapper[len(m.RepeatedUint64Wrapper)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedUint64Wrapper[len(m.RepeatedUint64Wrapper)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 216:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFloatWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedFloatWrapper = append(m.RepeatedFloatWrapper, &wrapperspb.FloatValue{})
			if unmarshal, ok := interface{}(m.RepeatedFloatWrapper[len(m.RepeatedFloatWrapper)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedFloatWrapper[len(m.RepeatedFloatWrapper)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 217:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedDoubleWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedDoubleWrapper = append(m.RepeatedDoubleWrapper, &wrapperspb.DoubleValue{})
			if unmarshal, ok := interface{}(m.RepeatedDoubleWrapper[len(m.RepeatedDoubleWrapper)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedDoubleWrapper[len(m.RepeatedDoubleWrapper)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 218:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedStringWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedStringWrapper = append(m.RepeatedStringWrapper, &wrapperspb.StringValue{})
			if unmarshal, ok := interface{}(m.RepeatedStringWrapper[len(m.RepeatedStringWrapper)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedStringWrapper[len(m.RepeatedStringWrapper)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 219:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBytesWrapper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedBytesWrapper = append(m.RepeatedBytesWrapper, &wrapperspb.BytesValue{})
			if unmarshal, ok := interface{}(m.RepeatedBytesWrapper[len(m.RepeatedBytesWrapper)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedBytesWrapper[len(m.RepeatedBytesWrapper)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 301:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalDuration == nil {
				m.OptionalDuration = &durationpb.Duration{}
			}
			if unmarshal, ok := interface{}(m.OptionalDuration).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalDuration); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 302:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalTimestamp == nil {
				m.OptionalTimestamp = &timestamppb.Timestamp{}
			}
			if unmarshal, ok := interface{}(m.OptionalTimestamp).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalTimestamp); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 303:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFieldMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalFieldMask == nil {
				m.OptionalFieldMask = &fieldmaskpb.FieldMask{}
			}
			if unmarshal, ok := interface{}(m.OptionalFieldMask).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalFieldMask); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 304:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalStruct", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalStruct == nil {
				m.OptionalStruct = &structpb.Struct{}
			}
			if unmarshal, ok := interface{}(m.OptionalStruct).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalStruct); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 305:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalAny", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalAny == nil {
				m.OptionalAny = &anypb.Any{}
			}
			if unmarshal, ok := interface{}(m.OptionalAny).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalAny); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 306:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalValue == nil {
				m.OptionalValue = &structpb.Value{}
			}
			if unmarshal, ok := interface{}(m.OptionalValue).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OptionalValue); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 307:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalNullValue", wireType)
			}
			m.OptionalNullValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalNullValue |= structpb.NullValue(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 311:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedDuration = append(m.RepeatedDuration, &durationpb.Duration{})
			if unmarshal, ok := interface{}(m.RepeatedDuration[len(m.RepeatedDuration)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedDuration[len(m.RepeatedDuration)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 312:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedTimestamp = append(m.RepeatedTimestamp, &timestamppb.Timestamp{})
			if unmarshal, ok := interface{}(m.RepeatedTimestamp[len(m.RepeatedTimestamp)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedTimestamp[len(m.RepeatedTimestamp)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 313:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFieldmask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedFieldmask = append(m.RepeatedFieldmask, &fieldmaskpb.FieldMask{})
			if unmarshal, ok := interface{}(m.RepeatedFieldmask[len(m.RepeatedFieldmask)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedFieldmask[len(m.RepeatedFieldmask)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 315:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedAny", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedAny = append(m.RepeatedAny, &anypb.Any{})
			if unmarshal, ok := interface{}(m.RepeatedAny[len(m.RepeatedAny)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedAny[len(m.RepeatedAny)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 316:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedValue = append(m.RepeatedValue, &structpb.Value{})
			if unmarshal, ok := interface{}(m.RepeatedValue[len(m.RepeatedValue)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedValue[len(m.RepeatedValue)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 317:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedListValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedListValue = append(m.RepeatedListValue, &structpb.ListValue{})
			if unmarshal, ok := interface{}(m.RepeatedListValue[len(m.RepeatedListValue)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedListValue[len(m.RepeatedListValue)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 324:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedStruct", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedStruct = append(m.RepeatedStruct, &structpb.Struct{})
			if unmarshal, ok := interface{}(m.RepeatedStruct[len(m.RepeatedStruct)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.RepeatedStruct[len(m.RepeatedStruct)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 401:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fieldname1", wireType)
			}
			m.Fieldname1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fieldname1 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 402:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName2", wireType)
			}
			m.FieldName2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldName2 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 403:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XFieldName3", wireType)
			}
			m.XFieldName3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XFieldName3 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 404:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_Name4_", wireType)
			}
			m.Field_Name4_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field_Name4_ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 405:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field0Name5", wireType)
			}
			m.Field0Name5 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field0Name5 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 406:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_0Name6", wireType)
			}
			m.Field_0Name6 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field_0Name6 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 407:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName7", wireType)
			}
			m.FieldName7 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldName7 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 408:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName8", wireType)
			}
			m.FieldName8 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldName8 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 409:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_Name9", wireType)
			}
			m.Field_Name9 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field_Name9 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 410:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_Name10", wireType)
			}
			m.Field_Name10 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field_Name10 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 411:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FIELD_NAME11", wireType)
			}
			m.FIELD_NAME11 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FIELD_NAME11 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 412:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FIELDName12", wireType)
			}
			m.FIELDName12 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FIELDName12 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 413:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XFieldName13", wireType)
			}
			m.XFieldName13 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XFieldName13 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 414:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X_FieldName14", wireType)
			}
			m.X_FieldName14 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X_FieldName14 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 415:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field_Name15", wireType)
			}
			m.Field_Name15 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field_Name15 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 416:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field__Name16", wireType)
			}
			m.Field__Name16 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field__Name16 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 417:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName17__", wireType)
			}
			m.FieldName17__ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldName17__ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 418:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName18__", wireType)
			}
			m.FieldName18__ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldName18__ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignMessage) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			m.C = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.C |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullHypothesisProto3) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullHypothesisProto3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullHypothesisProto3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumOnlyProto3) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnumOnlyProto3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnumOnlyProto3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
